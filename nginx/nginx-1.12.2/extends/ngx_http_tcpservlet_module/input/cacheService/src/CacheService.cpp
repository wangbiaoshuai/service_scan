/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "CacheService.h"

namespace com { namespace vrv { namespace cems { namespace service { namespace base { namespace interfaces {

uint32_t CacheService_getDataTS_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->checkCode);
          this->__isset.checkCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isZip);
          this->__isset.isZip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isEncrypt);
          this->__isset.isEncrypt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->flag);
          this->__isset.flag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_getDataTS_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_getDataTS_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("checkCode", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->checkCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isZip", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->isZip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isEncrypt", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->isEncrypt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flag", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->flag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_getDataTS_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_getDataTS_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("checkCode", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->checkCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isZip", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->isZip)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary((*(this->data)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isEncrypt", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool((*(this->isEncrypt)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flag", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32((*(this->flag)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_getDataTS_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_getDataTS_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_getDataTS_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeBinary(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_getDataTS_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_isExist_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->prefix);
          this->__isset.prefix = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_isExist_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_isExist_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prefix", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->prefix);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_isExist_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_isExist_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prefix", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->prefix)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_isExist_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_isExist_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_isExist_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_isExist_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_setExpireTimeByString_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->expireTime);
          this->__isset.expireTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_setExpireTimeByString_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_setExpireTimeByString_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expireTime", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->expireTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_setExpireTimeByString_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_setExpireTimeByString_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expireTime", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->expireTime)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_setExpireTimeByString_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_setExpireTimeByString_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_setExpireTimeByString_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_setExpireTimeByString_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_setExpireTimeByBinary_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->expireTime);
          this->__isset.expireTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_setExpireTimeByBinary_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_setExpireTimeByBinary_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expireTime", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->expireTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_setExpireTimeByBinary_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_setExpireTimeByBinary_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expireTime", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->expireTime)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_setExpireTimeByBinary_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_setExpireTimeByBinary_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_setExpireTimeByBinary_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_setExpireTimeByBinary_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchDel_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->keyList.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->keyList.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readString(this->keyList[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.keyList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchDel_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchDel_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("keyList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->keyList.size()));
    std::vector<std::string> ::const_iterator _iter5;
    for (_iter5 = this->keyList.begin(); _iter5 != this->keyList.end(); ++_iter5)
    {
      xfer += oprot->writeString((*_iter5));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchDel_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchDel_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("keyList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->keyList)).size()));
    std::vector<std::string> ::const_iterator _iter6;
    for (_iter6 = (*(this->keyList)).begin(); _iter6 != (*(this->keyList)).end(); ++_iter6)
    {
      xfer += oprot->writeString((*_iter6));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchDel_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchDel_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_batchDel_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchDel_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDevice_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->deviceCache.read(iprot);
          this->__isset.deviceCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDevice_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveDevice_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->deviceCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDevice_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveDevice_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->deviceCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDevice_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDevice_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveDevice_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDevice_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDevice_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->deviceCache.read(iprot);
          this->__isset.deviceCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDevice_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateDevice_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->deviceCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDevice_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateDevice_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->deviceCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDevice_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDevice_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateDevice_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDevice_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceByField_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->fieldValueMap.clear();
            uint32_t _size7;
            ::apache::thrift::protocol::TType _ktype8;
            ::apache::thrift::protocol::TType _vtype9;
            xfer += iprot->readMapBegin(_ktype8, _vtype9, _size7);
            uint32_t _i11;
            for (_i11 = 0; _i11 < _size7; ++_i11)
            {
              std::string _key12;
              xfer += iprot->readString(_key12);
              std::string& _val13 = this->fieldValueMap[_key12];
              xfer += iprot->readString(_val13);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fieldValueMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceByField_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateDeviceByField_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldValueMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fieldValueMap.size()));
    std::map<std::string, std::string> ::const_iterator _iter14;
    for (_iter14 = this->fieldValueMap.begin(); _iter14 != this->fieldValueMap.end(); ++_iter14)
    {
      xfer += oprot->writeString(_iter14->first);
      xfer += oprot->writeString(_iter14->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceByField_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateDeviceByField_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldValueMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->fieldValueMap)).size()));
    std::map<std::string, std::string> ::const_iterator _iter15;
    for (_iter15 = (*(this->fieldValueMap)).begin(); _iter15 != (*(this->fieldValueMap)).end(); ++_iter15)
    {
      xfer += oprot->writeString(_iter15->first);
      xfer += oprot->writeString(_iter15->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceByField_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceByField_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateDeviceByField_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceByField_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDevice_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->deviceCache.read(iprot);
          this->__isset.deviceCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDevice_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDevice_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->deviceCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDevice_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDevice_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->deviceCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDevice_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDevice_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryDevice_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDevice_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceByDevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceByDevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceByDevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceByDevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceByDevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceByDevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceByDevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryDeviceByDevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceByDevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceByIp_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceByIp_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceByIp_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceByIp_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceByIp_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->ip)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceByIp_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceByIp_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryDeviceByIp_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceByIp_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDevice_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->deviceCache.read(iprot);
          this->__isset.deviceCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDevice_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDevice_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->deviceCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDevice_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDevice_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->deviceCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDevice_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDevice_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteDevice_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDevice_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceByDevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceByDevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceByDevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceByDevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceByDevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceByDevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceByDevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteDeviceByDevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceByDevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceByIp_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceByIp_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceByIp_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceByIp_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceByIp_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->ip)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceByIp_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceByIp_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteDeviceByIp_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceByIp_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchSaveDevice_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->deviceCacheList.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->deviceCacheList.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += this->deviceCacheList[_i20].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.deviceCacheList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchSaveDevice_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchSaveDevice_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceCacheList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->deviceCacheList.size()));
    std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceCache> ::const_iterator _iter21;
    for (_iter21 = this->deviceCacheList.begin(); _iter21 != this->deviceCacheList.end(); ++_iter21)
    {
      xfer += (*_iter21).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchSaveDevice_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchSaveDevice_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceCacheList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->deviceCacheList)).size()));
    std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceCache> ::const_iterator _iter22;
    for (_iter22 = (*(this->deviceCacheList)).begin(); _iter22 != (*(this->deviceCacheList)).end(); ++_iter22)
    {
      xfer += (*_iter22).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchSaveDevice_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size23;
            ::apache::thrift::protocol::TType _etype26;
            xfer += iprot->readListBegin(_etype26, _size23);
            this->success.resize(_size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              xfer += this->success[_i27].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchSaveDevice_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_batchSaveDevice_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector< ::com::vrv::cems::service::base::bean::cache::Result> ::const_iterator _iter28;
      for (_iter28 = this->success.begin(); _iter28 != this->success.end(); ++_iter28)
      {
        xfer += (*_iter28).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchSaveDevice_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size29;
            ::apache::thrift::protocol::TType _etype32;
            xfer += iprot->readListBegin(_etype32, _size29);
            (*(this->success)).resize(_size29);
            uint32_t _i33;
            for (_i33 = 0; _i33 < _size29; ++_i33)
            {
              xfer += (*(this->success))[_i33].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchUpdateDevice_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->deviceCacheList.clear();
            uint32_t _size34;
            ::apache::thrift::protocol::TType _etype37;
            xfer += iprot->readListBegin(_etype37, _size34);
            this->deviceCacheList.resize(_size34);
            uint32_t _i38;
            for (_i38 = 0; _i38 < _size34; ++_i38)
            {
              xfer += this->deviceCacheList[_i38].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.deviceCacheList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchUpdateDevice_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchUpdateDevice_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceCacheList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->deviceCacheList.size()));
    std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceCache> ::const_iterator _iter39;
    for (_iter39 = this->deviceCacheList.begin(); _iter39 != this->deviceCacheList.end(); ++_iter39)
    {
      xfer += (*_iter39).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchUpdateDevice_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchUpdateDevice_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceCacheList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->deviceCacheList)).size()));
    std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceCache> ::const_iterator _iter40;
    for (_iter40 = (*(this->deviceCacheList)).begin(); _iter40 != (*(this->deviceCacheList)).end(); ++_iter40)
    {
      xfer += (*_iter40).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchUpdateDevice_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size41;
            ::apache::thrift::protocol::TType _etype44;
            xfer += iprot->readListBegin(_etype44, _size41);
            this->success.resize(_size41);
            uint32_t _i45;
            for (_i45 = 0; _i45 < _size41; ++_i45)
            {
              xfer += this->success[_i45].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchUpdateDevice_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_batchUpdateDevice_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector< ::com::vrv::cems::service::base::bean::cache::Result> ::const_iterator _iter46;
      for (_iter46 = this->success.begin(); _iter46 != this->success.end(); ++_iter46)
      {
        xfer += (*_iter46).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchUpdateDevice_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            (*(this->success)).resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              xfer += (*(this->success))[_i51].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchQueryDevice_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->deviceCacheList.clear();
            uint32_t _size52;
            ::apache::thrift::protocol::TType _etype55;
            xfer += iprot->readListBegin(_etype55, _size52);
            this->deviceCacheList.resize(_size52);
            uint32_t _i56;
            for (_i56 = 0; _i56 < _size52; ++_i56)
            {
              xfer += this->deviceCacheList[_i56].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.deviceCacheList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchQueryDevice_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchQueryDevice_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceCacheList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->deviceCacheList.size()));
    std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceCache> ::const_iterator _iter57;
    for (_iter57 = this->deviceCacheList.begin(); _iter57 != this->deviceCacheList.end(); ++_iter57)
    {
      xfer += (*_iter57).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchQueryDevice_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchQueryDevice_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceCacheList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->deviceCacheList)).size()));
    std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceCache> ::const_iterator _iter58;
    for (_iter58 = (*(this->deviceCacheList)).begin(); _iter58 != (*(this->deviceCacheList)).end(); ++_iter58)
    {
      xfer += (*_iter58).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchQueryDevice_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size59;
            ::apache::thrift::protocol::TType _etype62;
            xfer += iprot->readListBegin(_etype62, _size59);
            this->success.resize(_size59);
            uint32_t _i63;
            for (_i63 = 0; _i63 < _size59; ++_i63)
            {
              xfer += this->success[_i63].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchQueryDevice_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_batchQueryDevice_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceCache> ::const_iterator _iter64;
      for (_iter64 = this->success.begin(); _iter64 != this->success.end(); ++_iter64)
      {
        xfer += (*_iter64).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchQueryDevice_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size65;
            ::apache::thrift::protocol::TType _etype68;
            xfer += iprot->readListBegin(_etype68, _size65);
            (*(this->success)).resize(_size65);
            uint32_t _i69;
            for (_i69 = 0; _i69 < _size65; ++_i69)
            {
              xfer += (*(this->success))[_i69].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchQueryDeviceByDevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->devOnlyIdList.clear();
            uint32_t _size70;
            ::apache::thrift::protocol::TType _etype73;
            xfer += iprot->readListBegin(_etype73, _size70);
            this->devOnlyIdList.resize(_size70);
            uint32_t _i74;
            for (_i74 = 0; _i74 < _size70; ++_i74)
            {
              xfer += iprot->readString(this->devOnlyIdList[_i74]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.devOnlyIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchQueryDeviceByDevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchQueryDeviceByDevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyIdList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->devOnlyIdList.size()));
    std::vector<std::string> ::const_iterator _iter75;
    for (_iter75 = this->devOnlyIdList.begin(); _iter75 != this->devOnlyIdList.end(); ++_iter75)
    {
      xfer += oprot->writeString((*_iter75));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchQueryDeviceByDevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchQueryDeviceByDevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyIdList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->devOnlyIdList)).size()));
    std::vector<std::string> ::const_iterator _iter76;
    for (_iter76 = (*(this->devOnlyIdList)).begin(); _iter76 != (*(this->devOnlyIdList)).end(); ++_iter76)
    {
      xfer += oprot->writeString((*_iter76));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchQueryDeviceByDevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _etype80;
            xfer += iprot->readListBegin(_etype80, _size77);
            this->success.resize(_size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              xfer += this->success[_i81].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchQueryDeviceByDevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_batchQueryDeviceByDevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceCache> ::const_iterator _iter82;
      for (_iter82 = this->success.begin(); _iter82 != this->success.end(); ++_iter82)
      {
        xfer += (*_iter82).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchQueryDeviceByDevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size83;
            ::apache::thrift::protocol::TType _etype86;
            xfer += iprot->readListBegin(_etype86, _size83);
            (*(this->success)).resize(_size83);
            uint32_t _i87;
            for (_i87 = 0; _i87 < _size83; ++_i87)
            {
              xfer += (*(this->success))[_i87].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchDeleteDevice_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->deviceCacheList.clear();
            uint32_t _size88;
            ::apache::thrift::protocol::TType _etype91;
            xfer += iprot->readListBegin(_etype91, _size88);
            this->deviceCacheList.resize(_size88);
            uint32_t _i92;
            for (_i92 = 0; _i92 < _size88; ++_i92)
            {
              xfer += this->deviceCacheList[_i92].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.deviceCacheList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchDeleteDevice_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchDeleteDevice_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceCacheList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->deviceCacheList.size()));
    std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceCache> ::const_iterator _iter93;
    for (_iter93 = this->deviceCacheList.begin(); _iter93 != this->deviceCacheList.end(); ++_iter93)
    {
      xfer += (*_iter93).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchDeleteDevice_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchDeleteDevice_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceCacheList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->deviceCacheList)).size()));
    std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceCache> ::const_iterator _iter94;
    for (_iter94 = (*(this->deviceCacheList)).begin(); _iter94 != (*(this->deviceCacheList)).end(); ++_iter94)
    {
      xfer += (*_iter94).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchDeleteDevice_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size95;
            ::apache::thrift::protocol::TType _etype98;
            xfer += iprot->readListBegin(_etype98, _size95);
            this->success.resize(_size95);
            uint32_t _i99;
            for (_i99 = 0; _i99 < _size95; ++_i99)
            {
              xfer += this->success[_i99].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchDeleteDevice_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_batchDeleteDevice_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector< ::com::vrv::cems::service::base::bean::cache::Result> ::const_iterator _iter100;
      for (_iter100 = this->success.begin(); _iter100 != this->success.end(); ++_iter100)
      {
        xfer += (*_iter100).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchDeleteDevice_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size101;
            ::apache::thrift::protocol::TType _etype104;
            xfer += iprot->readListBegin(_etype104, _size101);
            (*(this->success)).resize(_size101);
            uint32_t _i105;
            for (_i105 = 0; _i105 < _size101; ++_i105)
            {
              xfer += (*(this->success))[_i105].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchDeleteDeviceByDevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->devOnlyIdList.clear();
            uint32_t _size106;
            ::apache::thrift::protocol::TType _etype109;
            xfer += iprot->readListBegin(_etype109, _size106);
            this->devOnlyIdList.resize(_size106);
            uint32_t _i110;
            for (_i110 = 0; _i110 < _size106; ++_i110)
            {
              xfer += iprot->readString(this->devOnlyIdList[_i110]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.devOnlyIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchDeleteDeviceByDevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchDeleteDeviceByDevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyIdList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->devOnlyIdList.size()));
    std::vector<std::string> ::const_iterator _iter111;
    for (_iter111 = this->devOnlyIdList.begin(); _iter111 != this->devOnlyIdList.end(); ++_iter111)
    {
      xfer += oprot->writeString((*_iter111));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchDeleteDeviceByDevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchDeleteDeviceByDevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyIdList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->devOnlyIdList)).size()));
    std::vector<std::string> ::const_iterator _iter112;
    for (_iter112 = (*(this->devOnlyIdList)).begin(); _iter112 != (*(this->devOnlyIdList)).end(); ++_iter112)
    {
      xfer += oprot->writeString((*_iter112));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchDeleteDeviceByDevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size113;
            ::apache::thrift::protocol::TType _etype116;
            xfer += iprot->readListBegin(_etype116, _size113);
            this->success.resize(_size113);
            uint32_t _i117;
            for (_i117 = 0; _i117 < _size113; ++_i117)
            {
              xfer += this->success[_i117].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchDeleteDeviceByDevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_batchDeleteDeviceByDevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector< ::com::vrv::cems::service::base::bean::cache::Result> ::const_iterator _iter118;
      for (_iter118 = this->success.begin(); _iter118 != this->success.end(); ++_iter118)
      {
        xfer += (*_iter118).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchDeleteDeviceByDevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size119;
            ::apache::thrift::protocol::TType _etype122;
            xfer += iprot->readListBegin(_etype122, _size119);
            (*(this->success)).resize(_size119);
            uint32_t _i123;
            for (_i123 = 0; _i123 < _size119; ++_i123)
            {
              xfer += (*(this->success))[_i123].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDeviceOnline_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->deviceOnlineCache.read(iprot);
          this->__isset.deviceOnlineCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDeviceOnline_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveDeviceOnline_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceOnlineCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->deviceOnlineCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDeviceOnline_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveDeviceOnline_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceOnlineCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->deviceOnlineCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDeviceOnline_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDeviceOnline_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveDeviceOnline_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDeviceOnline_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceOnline_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->deviceOnlineCache.read(iprot);
          this->__isset.deviceOnlineCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceOnline_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateDeviceOnline_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceOnlineCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->deviceOnlineCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceOnline_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateDeviceOnline_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceOnlineCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->deviceOnlineCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceOnline_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceOnline_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateDeviceOnline_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceOnline_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceOnlineByField_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->fieldValueMap.clear();
            uint32_t _size124;
            ::apache::thrift::protocol::TType _ktype125;
            ::apache::thrift::protocol::TType _vtype126;
            xfer += iprot->readMapBegin(_ktype125, _vtype126, _size124);
            uint32_t _i128;
            for (_i128 = 0; _i128 < _size124; ++_i128)
            {
              std::string _key129;
              xfer += iprot->readString(_key129);
              std::string& _val130 = this->fieldValueMap[_key129];
              xfer += iprot->readString(_val130);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fieldValueMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceOnlineByField_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateDeviceOnlineByField_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldValueMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fieldValueMap.size()));
    std::map<std::string, std::string> ::const_iterator _iter131;
    for (_iter131 = this->fieldValueMap.begin(); _iter131 != this->fieldValueMap.end(); ++_iter131)
    {
      xfer += oprot->writeString(_iter131->first);
      xfer += oprot->writeString(_iter131->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceOnlineByField_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateDeviceOnlineByField_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldValueMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->fieldValueMap)).size()));
    std::map<std::string, std::string> ::const_iterator _iter132;
    for (_iter132 = (*(this->fieldValueMap)).begin(); _iter132 != (*(this->fieldValueMap)).end(); ++_iter132)
    {
      xfer += oprot->writeString(_iter132->first);
      xfer += oprot->writeString(_iter132->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceOnlineByField_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceOnlineByField_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateDeviceOnlineByField_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceOnlineByField_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceOnline_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->deviceOnlineCache.read(iprot);
          this->__isset.deviceOnlineCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceOnline_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceOnline_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceOnlineCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->deviceOnlineCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceOnline_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceOnline_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceOnlineCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->deviceOnlineCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceOnline_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceOnline_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryDeviceOnline_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceOnline_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceOnlineByDevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceOnlineByDevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceOnlineByDevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceOnlineByDevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceOnlineByDevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceOnlineByDevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceOnlineByDevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryDeviceOnlineByDevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceOnlineByDevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceOnlineByIp_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceOnlineByIp_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceOnlineByIp_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceOnlineByIp_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceOnlineByIp_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->ip)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceOnlineByIp_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceOnlineByIp_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryDeviceOnlineByIp_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceOnlineByIp_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceOnline_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->deviceOnlineCache.read(iprot);
          this->__isset.deviceOnlineCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceOnline_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceOnline_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceOnlineCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->deviceOnlineCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceOnline_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceOnline_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceOnlineCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->deviceOnlineCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceOnline_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceOnline_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteDeviceOnline_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceOnline_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceOnlineByDevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceOnlineByDevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceOnlineByDevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceOnlineByDevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceOnlineByDevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceOnlineByDevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceOnlineByDevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteDeviceOnlineByDevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceOnlineByDevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceOnlineByIp_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceOnlineByIp_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceOnlineByIp_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceOnlineByIp_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceOnlineByIp_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->ip)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceOnlineByIp_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceOnlineByIp_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteDeviceOnlineByIp_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceOnlineByIp_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryAllDeviceOnlineCache_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryAllDeviceOnlineCache_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryAllDeviceOnlineCache_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryAllDeviceOnlineCache_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryAllDeviceOnlineCache_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryAllDeviceOnlineCache_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size133;
            ::apache::thrift::protocol::TType _etype136;
            xfer += iprot->readListBegin(_etype136, _size133);
            this->success.resize(_size133);
            uint32_t _i137;
            for (_i137 = 0; _i137 < _size133; ++_i137)
            {
              xfer += this->success[_i137].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryAllDeviceOnlineCache_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryAllDeviceOnlineCache_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceOnlineCache> ::const_iterator _iter138;
      for (_iter138 = this->success.begin(); _iter138 != this->success.end(); ++_iter138)
      {
        xfer += (*_iter138).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryAllDeviceOnlineCache_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size139;
            ::apache::thrift::protocol::TType _etype142;
            xfer += iprot->readListBegin(_etype142, _size139);
            (*(this->success)).resize(_size139);
            uint32_t _i143;
            for (_i143 = 0; _i143 < _size139; ++_i143)
            {
              xfer += (*(this->success))[_i143].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryOnlineDevOnlyIdsByUserOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userOnlyId);
          this->__isset.userOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryOnlineDevOnlyIdsByUserOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryOnlineDevOnlyIdsByUserOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->userOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryOnlineDevOnlyIdsByUserOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryOnlineDevOnlyIdsByUserOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->userOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryOnlineDevOnlyIdsByUserOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size144;
            ::apache::thrift::protocol::TType _etype147;
            xfer += iprot->readListBegin(_etype147, _size144);
            this->success.resize(_size144);
            uint32_t _i148;
            for (_i148 = 0; _i148 < _size144; ++_i148)
            {
              xfer += iprot->readString(this->success[_i148]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryOnlineDevOnlyIdsByUserOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryOnlineDevOnlyIdsByUserOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::vector<std::string> ::const_iterator _iter149;
      for (_iter149 = this->success.begin(); _iter149 != this->success.end(); ++_iter149)
      {
        xfer += oprot->writeString((*_iter149));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryOnlineDevOnlyIdsByUserOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size150;
            ::apache::thrift::protocol::TType _etype153;
            xfer += iprot->readListBegin(_etype153, _size150);
            (*(this->success)).resize(_size150);
            uint32_t _i154;
            for (_i154 = 0; _i154 < _size150; ++_i154)
            {
              xfer += iprot->readString((*(this->success))[_i154]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchQueryDeviceOnlinesByDevOnlyIdList_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->devOnlyIdList.clear();
            uint32_t _size155;
            ::apache::thrift::protocol::TType _etype158;
            xfer += iprot->readListBegin(_etype158, _size155);
            this->devOnlyIdList.resize(_size155);
            uint32_t _i159;
            for (_i159 = 0; _i159 < _size155; ++_i159)
            {
              xfer += iprot->readString(this->devOnlyIdList[_i159]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.devOnlyIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchQueryDeviceOnlinesByDevOnlyIdList_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchQueryDeviceOnlinesByDevOnlyIdList_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyIdList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->devOnlyIdList.size()));
    std::vector<std::string> ::const_iterator _iter160;
    for (_iter160 = this->devOnlyIdList.begin(); _iter160 != this->devOnlyIdList.end(); ++_iter160)
    {
      xfer += oprot->writeString((*_iter160));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchQueryDeviceOnlinesByDevOnlyIdList_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchQueryDeviceOnlinesByDevOnlyIdList_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyIdList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->devOnlyIdList)).size()));
    std::vector<std::string> ::const_iterator _iter161;
    for (_iter161 = (*(this->devOnlyIdList)).begin(); _iter161 != (*(this->devOnlyIdList)).end(); ++_iter161)
    {
      xfer += oprot->writeString((*_iter161));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchQueryDeviceOnlinesByDevOnlyIdList_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size162;
            ::apache::thrift::protocol::TType _etype165;
            xfer += iprot->readListBegin(_etype165, _size162);
            this->success.resize(_size162);
            uint32_t _i166;
            for (_i166 = 0; _i166 < _size162; ++_i166)
            {
              xfer += this->success[_i166].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchQueryDeviceOnlinesByDevOnlyIdList_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_batchQueryDeviceOnlinesByDevOnlyIdList_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceOnlineCache> ::const_iterator _iter167;
      for (_iter167 = this->success.begin(); _iter167 != this->success.end(); ++_iter167)
      {
        xfer += (*_iter167).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchQueryDeviceOnlinesByDevOnlyIdList_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size168;
            ::apache::thrift::protocol::TType _etype171;
            xfer += iprot->readListBegin(_etype171, _size168);
            (*(this->success)).resize(_size168);
            uint32_t _i172;
            for (_i172 = 0; _i172 < _size168; ++_i172)
            {
              xfer += (*(this->success))[_i172].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDeviceKey_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->deviceKeyCache.read(iprot);
          this->__isset.deviceKeyCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDeviceKey_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveDeviceKey_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceKeyCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->deviceKeyCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDeviceKey_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveDeviceKey_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceKeyCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->deviceKeyCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDeviceKey_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDeviceKey_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveDeviceKey_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDeviceKey_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceKey_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->deviceKeyCache.read(iprot);
          this->__isset.deviceKeyCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceKey_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateDeviceKey_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceKeyCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->deviceKeyCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceKey_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateDeviceKey_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceKeyCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->deviceKeyCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceKey_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceKey_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateDeviceKey_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceKey_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceKeyByField_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sessionId);
          this->__isset.sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->fieldValueMap.clear();
            uint32_t _size173;
            ::apache::thrift::protocol::TType _ktype174;
            ::apache::thrift::protocol::TType _vtype175;
            xfer += iprot->readMapBegin(_ktype174, _vtype175, _size173);
            uint32_t _i177;
            for (_i177 = 0; _i177 < _size173; ++_i177)
            {
              std::string _key178;
              xfer += iprot->readString(_key178);
              std::string& _val179 = this->fieldValueMap[_key178];
              xfer += iprot->readString(_val179);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fieldValueMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceKeyByField_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateDeviceKeyByField_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldValueMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fieldValueMap.size()));
    std::map<std::string, std::string> ::const_iterator _iter180;
    for (_iter180 = this->fieldValueMap.begin(); _iter180 != this->fieldValueMap.end(); ++_iter180)
    {
      xfer += oprot->writeString(_iter180->first);
      xfer += oprot->writeString(_iter180->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceKeyByField_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateDeviceKeyByField_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->sessionId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldValueMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->fieldValueMap)).size()));
    std::map<std::string, std::string> ::const_iterator _iter181;
    for (_iter181 = (*(this->fieldValueMap)).begin(); _iter181 != (*(this->fieldValueMap)).end(); ++_iter181)
    {
      xfer += oprot->writeString(_iter181->first);
      xfer += oprot->writeString(_iter181->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceKeyByField_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceKeyByField_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateDeviceKeyByField_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceKeyByField_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceKey_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->deviceKeyCache.read(iprot);
          this->__isset.deviceKeyCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceKey_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceKey_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceKeyCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->deviceKeyCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceKey_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceKey_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceKeyCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->deviceKeyCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceKey_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceKey_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryDeviceKey_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceKey_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceKeyBySessionId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sessionId);
          this->__isset.sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceKeyBySessionId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceKeyBySessionId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceKeyBySessionId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceKeyBySessionId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->sessionId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceKeyBySessionId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceKeyBySessionId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryDeviceKeyBySessionId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceKeyBySessionId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceKeyByDevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceKeyByDevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceKeyByDevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceKeyByDevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceKeyByDevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceKeyByDevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceKeyByDevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryDeviceKeyByDevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceKeyByDevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceKey_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->deviceKeyCache.read(iprot);
          this->__isset.deviceKeyCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceKey_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceKey_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceKeyCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->deviceKeyCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceKey_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceKey_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceKeyCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->deviceKeyCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceKey_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceKey_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteDeviceKey_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceKey_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceKeyBySessionId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sessionId);
          this->__isset.sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceKeyBySessionId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceKeyBySessionId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceKeyBySessionId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceKeyBySessionId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->sessionId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceKeyBySessionId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceKeyBySessionId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteDeviceKeyBySessionId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceKeyBySessionId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceKeyByDevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceKeyByDevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceKeyByDevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceKeyByDevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceKeyByDevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceKeyByDevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceKeyByDevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteDeviceKeyByDevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceKeyByDevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_isExistSessionIdInDeviceKeyCache_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sessionId);
          this->__isset.sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_isExistSessionIdInDeviceKeyCache_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_isExistSessionIdInDeviceKeyCache_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_isExistSessionIdInDeviceKeyCache_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_isExistSessionIdInDeviceKeyCache_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->sessionId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_isExistSessionIdInDeviceKeyCache_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_isExistSessionIdInDeviceKeyCache_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_isExistSessionIdInDeviceKeyCache_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_isExistSessionIdInDeviceKeyCache_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchQueryDeviceKeysBySessionIdList_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sessionIdList.clear();
            uint32_t _size182;
            ::apache::thrift::protocol::TType _etype185;
            xfer += iprot->readListBegin(_etype185, _size182);
            this->sessionIdList.resize(_size182);
            uint32_t _i186;
            for (_i186 = 0; _i186 < _size182; ++_i186)
            {
              xfer += iprot->readString(this->sessionIdList[_i186]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sessionIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchQueryDeviceKeysBySessionIdList_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchQueryDeviceKeysBySessionIdList_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionIdList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->sessionIdList.size()));
    std::vector<std::string> ::const_iterator _iter187;
    for (_iter187 = this->sessionIdList.begin(); _iter187 != this->sessionIdList.end(); ++_iter187)
    {
      xfer += oprot->writeString((*_iter187));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchQueryDeviceKeysBySessionIdList_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchQueryDeviceKeysBySessionIdList_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionIdList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->sessionIdList)).size()));
    std::vector<std::string> ::const_iterator _iter188;
    for (_iter188 = (*(this->sessionIdList)).begin(); _iter188 != (*(this->sessionIdList)).end(); ++_iter188)
    {
      xfer += oprot->writeString((*_iter188));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchQueryDeviceKeysBySessionIdList_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size189;
            ::apache::thrift::protocol::TType _etype192;
            xfer += iprot->readListBegin(_etype192, _size189);
            this->success.resize(_size189);
            uint32_t _i193;
            for (_i193 = 0; _i193 < _size189; ++_i193)
            {
              xfer += this->success[_i193].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchQueryDeviceKeysBySessionIdList_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_batchQueryDeviceKeysBySessionIdList_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceKeyCache> ::const_iterator _iter194;
      for (_iter194 = this->success.begin(); _iter194 != this->success.end(); ++_iter194)
      {
        xfer += (*_iter194).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchQueryDeviceKeysBySessionIdList_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size195;
            ::apache::thrift::protocol::TType _etype198;
            xfer += iprot->readListBegin(_etype198, _size195);
            (*(this->success)).resize(_size195);
            uint32_t _i199;
            for (_i199 = 0; _i199 < _size195; ++_i199)
            {
              xfer += (*(this->success))[_i199].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDeviceInsProOld_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->deviceProductList.clear();
            uint32_t _size200;
            ::apache::thrift::protocol::TType _etype203;
            xfer += iprot->readListBegin(_etype203, _size200);
            this->deviceProductList.resize(_size200);
            uint32_t _i204;
            for (_i204 = 0; _i204 < _size200; ++_i204)
            {
              xfer += this->deviceProductList[_i204].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.deviceProductList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDeviceInsProOld_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveDeviceInsProOld_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceProductList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->deviceProductList.size()));
    std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceProduct> ::const_iterator _iter205;
    for (_iter205 = this->deviceProductList.begin(); _iter205 != this->deviceProductList.end(); ++_iter205)
    {
      xfer += (*_iter205).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDeviceInsProOld_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveDeviceInsProOld_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceProductList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->deviceProductList)).size()));
    std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceProduct> ::const_iterator _iter206;
    for (_iter206 = (*(this->deviceProductList)).begin(); _iter206 != (*(this->deviceProductList)).end(); ++_iter206)
    {
      xfer += (*_iter206).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDeviceInsProOld_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDeviceInsProOld_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveDeviceInsProOld_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDeviceInsProOld_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceInsProOld_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->deviceProductList.clear();
            uint32_t _size207;
            ::apache::thrift::protocol::TType _etype210;
            xfer += iprot->readListBegin(_etype210, _size207);
            this->deviceProductList.resize(_size207);
            uint32_t _i211;
            for (_i211 = 0; _i211 < _size207; ++_i211)
            {
              xfer += this->deviceProductList[_i211].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.deviceProductList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceInsProOld_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateDeviceInsProOld_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceProductList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->deviceProductList.size()));
    std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceProduct> ::const_iterator _iter212;
    for (_iter212 = this->deviceProductList.begin(); _iter212 != this->deviceProductList.end(); ++_iter212)
    {
      xfer += (*_iter212).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceInsProOld_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateDeviceInsProOld_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceProductList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->deviceProductList)).size()));
    std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceProduct> ::const_iterator _iter213;
    for (_iter213 = (*(this->deviceProductList)).begin(); _iter213 != (*(this->deviceProductList)).end(); ++_iter213)
    {
      xfer += (*_iter213).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceInsProOld_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceInsProOld_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateDeviceInsProOld_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceInsProOld_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceInsProOldByDevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceInsProOldByDevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceInsProOldByDevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceInsProOldByDevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceInsProOldByDevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceInsProOldByDevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size214;
            ::apache::thrift::protocol::TType _etype217;
            xfer += iprot->readListBegin(_etype217, _size214);
            this->success.resize(_size214);
            uint32_t _i218;
            for (_i218 = 0; _i218 < _size214; ++_i218)
            {
              xfer += this->success[_i218].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceInsProOldByDevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryDeviceInsProOldByDevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceProduct> ::const_iterator _iter219;
      for (_iter219 = this->success.begin(); _iter219 != this->success.end(); ++_iter219)
      {
        xfer += (*_iter219).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceInsProOldByDevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size220;
            ::apache::thrift::protocol::TType _etype223;
            xfer += iprot->readListBegin(_etype223, _size220);
            (*(this->success)).resize(_size220);
            uint32_t _i224;
            for (_i224 = 0; _i224 < _size220; ++_i224)
            {
              xfer += (*(this->success))[_i224].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceInsProOldByDevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceInsProOldByDevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceInsProOldByDevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceInsProOldByDevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceInsProOldByDevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceInsProOldByDevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceInsProOldByDevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteDeviceInsProOldByDevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceInsProOldByDevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDeviceInsProNew_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->deviceProductList.clear();
            uint32_t _size225;
            ::apache::thrift::protocol::TType _etype228;
            xfer += iprot->readListBegin(_etype228, _size225);
            this->deviceProductList.resize(_size225);
            uint32_t _i229;
            for (_i229 = 0; _i229 < _size225; ++_i229)
            {
              xfer += this->deviceProductList[_i229].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.deviceProductList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDeviceInsProNew_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveDeviceInsProNew_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceProductList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->deviceProductList.size()));
    std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceProduct> ::const_iterator _iter230;
    for (_iter230 = this->deviceProductList.begin(); _iter230 != this->deviceProductList.end(); ++_iter230)
    {
      xfer += (*_iter230).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDeviceInsProNew_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveDeviceInsProNew_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceProductList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->deviceProductList)).size()));
    std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceProduct> ::const_iterator _iter231;
    for (_iter231 = (*(this->deviceProductList)).begin(); _iter231 != (*(this->deviceProductList)).end(); ++_iter231)
    {
      xfer += (*_iter231).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDeviceInsProNew_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDeviceInsProNew_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveDeviceInsProNew_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDeviceInsProNew_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceInsProNew_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->deviceProductList.clear();
            uint32_t _size232;
            ::apache::thrift::protocol::TType _etype235;
            xfer += iprot->readListBegin(_etype235, _size232);
            this->deviceProductList.resize(_size232);
            uint32_t _i236;
            for (_i236 = 0; _i236 < _size232; ++_i236)
            {
              xfer += this->deviceProductList[_i236].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.deviceProductList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceInsProNew_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateDeviceInsProNew_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceProductList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->deviceProductList.size()));
    std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceProduct> ::const_iterator _iter237;
    for (_iter237 = this->deviceProductList.begin(); _iter237 != this->deviceProductList.end(); ++_iter237)
    {
      xfer += (*_iter237).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceInsProNew_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateDeviceInsProNew_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceProductList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->deviceProductList)).size()));
    std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceProduct> ::const_iterator _iter238;
    for (_iter238 = (*(this->deviceProductList)).begin(); _iter238 != (*(this->deviceProductList)).end(); ++_iter238)
    {
      xfer += (*_iter238).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceInsProNew_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceInsProNew_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateDeviceInsProNew_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceInsProNew_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceInsProNewByDevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceInsProNewByDevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceInsProNewByDevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceInsProNewByDevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceInsProNewByDevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceInsProNewByDevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size239;
            ::apache::thrift::protocol::TType _etype242;
            xfer += iprot->readListBegin(_etype242, _size239);
            this->success.resize(_size239);
            uint32_t _i243;
            for (_i243 = 0; _i243 < _size239; ++_i243)
            {
              xfer += this->success[_i243].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceInsProNewByDevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryDeviceInsProNewByDevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceProduct> ::const_iterator _iter244;
      for (_iter244 = this->success.begin(); _iter244 != this->success.end(); ++_iter244)
      {
        xfer += (*_iter244).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceInsProNewByDevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size245;
            ::apache::thrift::protocol::TType _etype248;
            xfer += iprot->readListBegin(_etype248, _size245);
            (*(this->success)).resize(_size245);
            uint32_t _i249;
            for (_i249 = 0; _i249 < _size245; ++_i249)
            {
              xfer += (*(this->success))[_i249].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceInsProNewByDevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceInsProNewByDevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceInsProNewByDevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceInsProNewByDevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceInsProNewByDevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceInsProNewByDevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceInsProNewByDevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteDeviceInsProNewByDevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceInsProNewByDevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDevicePolicy_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->devicePolicyCache.read(iprot);
          this->__isset.devicePolicyCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDevicePolicy_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveDevicePolicy_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devicePolicyCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->devicePolicyCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDevicePolicy_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveDevicePolicy_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devicePolicyCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->devicePolicyCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDevicePolicy_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDevicePolicy_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveDevicePolicy_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDevicePolicy_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDevicePolicy_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->devicePolicyCache.read(iprot);
          this->__isset.devicePolicyCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDevicePolicy_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateDevicePolicy_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devicePolicyCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->devicePolicyCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDevicePolicy_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateDevicePolicy_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devicePolicyCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->devicePolicyCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDevicePolicy_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDevicePolicy_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateDevicePolicy_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDevicePolicy_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDevicePolicyByDevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDevicePolicyByDevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDevicePolicyByDevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDevicePolicyByDevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDevicePolicyByDevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDevicePolicyByDevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDevicePolicyByDevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryDevicePolicyByDevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDevicePolicyByDevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDevicePolicyByIp_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDevicePolicyByIp_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDevicePolicyByIp_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDevicePolicyByIp_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDevicePolicyByIp_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->ip)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDevicePolicyByIp_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDevicePolicyByIp_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryDevicePolicyByIp_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDevicePolicyByIp_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDevicePolicyByDevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDevicePolicyByDevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDevicePolicyByDevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDevicePolicyByDevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDevicePolicyByDevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDevicePolicyByDevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDevicePolicyByDevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteDevicePolicyByDevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDevicePolicyByDevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDevicePolicyByIp_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDevicePolicyByIp_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDevicePolicyByIp_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDevicePolicyByIp_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDevicePolicyByIp_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->ip)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDevicePolicyByIp_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDevicePolicyByIp_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteDevicePolicyByIp_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDevicePolicyByIp_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchSaveDevicePolicy_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->devicePolicyList.clear();
            uint32_t _size250;
            ::apache::thrift::protocol::TType _etype253;
            xfer += iprot->readListBegin(_etype253, _size250);
            this->devicePolicyList.resize(_size250);
            uint32_t _i254;
            for (_i254 = 0; _i254 < _size250; ++_i254)
            {
              {
                this->devicePolicyList[_i254].clear();
                uint32_t _size255;
                ::apache::thrift::protocol::TType _ktype256;
                ::apache::thrift::protocol::TType _vtype257;
                xfer += iprot->readMapBegin(_ktype256, _vtype257, _size255);
                uint32_t _i259;
                for (_i259 = 0; _i259 < _size255; ++_i259)
                {
                  std::string _key260;
                  xfer += iprot->readString(_key260);
                  std::string& _val261 = this->devicePolicyList[_i254][_key260];
                  xfer += iprot->readString(_val261);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.devicePolicyList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchSaveDevicePolicy_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchSaveDevicePolicy_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devicePolicyList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->devicePolicyList.size()));
    std::vector<std::map<std::string, std::string> > ::const_iterator _iter262;
    for (_iter262 = this->devicePolicyList.begin(); _iter262 != this->devicePolicyList.end(); ++_iter262)
    {
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter262).size()));
        std::map<std::string, std::string> ::const_iterator _iter263;
        for (_iter263 = (*_iter262).begin(); _iter263 != (*_iter262).end(); ++_iter263)
        {
          xfer += oprot->writeString(_iter263->first);
          xfer += oprot->writeString(_iter263->second);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchSaveDevicePolicy_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchSaveDevicePolicy_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devicePolicyList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>((*(this->devicePolicyList)).size()));
    std::vector<std::map<std::string, std::string> > ::const_iterator _iter264;
    for (_iter264 = (*(this->devicePolicyList)).begin(); _iter264 != (*(this->devicePolicyList)).end(); ++_iter264)
    {
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter264).size()));
        std::map<std::string, std::string> ::const_iterator _iter265;
        for (_iter265 = (*_iter264).begin(); _iter265 != (*_iter264).end(); ++_iter265)
        {
          xfer += oprot->writeString(_iter265->first);
          xfer += oprot->writeString(_iter265->second);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchSaveDevicePolicy_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchSaveDevicePolicy_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_batchSaveDevicePolicy_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchSaveDevicePolicy_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveUser_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userCache.read(iprot);
          this->__isset.userCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveUser_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveUser_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->userCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveUser_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveUser_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->userCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveUser_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveUser_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveUser_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveUser_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateUser_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userCache.read(iprot);
          this->__isset.userCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateUser_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateUser_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->userCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateUser_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateUser_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->userCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateUser_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateUser_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateUser_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateUser_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateUserByField_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userOnlyId);
          this->__isset.userOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->fieldValueMap.clear();
            uint32_t _size266;
            ::apache::thrift::protocol::TType _ktype267;
            ::apache::thrift::protocol::TType _vtype268;
            xfer += iprot->readMapBegin(_ktype267, _vtype268, _size266);
            uint32_t _i270;
            for (_i270 = 0; _i270 < _size266; ++_i270)
            {
              std::string _key271;
              xfer += iprot->readString(_key271);
              std::string& _val272 = this->fieldValueMap[_key271];
              xfer += iprot->readString(_val272);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fieldValueMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateUserByField_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateUserByField_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->userOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldValueMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fieldValueMap.size()));
    std::map<std::string, std::string> ::const_iterator _iter273;
    for (_iter273 = this->fieldValueMap.begin(); _iter273 != this->fieldValueMap.end(); ++_iter273)
    {
      xfer += oprot->writeString(_iter273->first);
      xfer += oprot->writeString(_iter273->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateUserByField_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateUserByField_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->userOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldValueMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->fieldValueMap)).size()));
    std::map<std::string, std::string> ::const_iterator _iter274;
    for (_iter274 = (*(this->fieldValueMap)).begin(); _iter274 != (*(this->fieldValueMap)).end(); ++_iter274)
    {
      xfer += oprot->writeString(_iter274->first);
      xfer += oprot->writeString(_iter274->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateUserByField_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateUserByField_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateUserByField_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateUserByField_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryUserByUserOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userOnlyId);
          this->__isset.userOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryUserByUserOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryUserByUserOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->userOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryUserByUserOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryUserByUserOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->userOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryUserByUserOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryUserByUserOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryUserByUserOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryUserByUserOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteUserByUserOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userOnlyId);
          this->__isset.userOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteUserByUserOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteUserByUserOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->userOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteUserByUserOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteUserByUserOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->userOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteUserByUserOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteUserByUserOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteUserByUserOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteUserByUserOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchSaveUser_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->userCacheList.clear();
            uint32_t _size275;
            ::apache::thrift::protocol::TType _etype278;
            xfer += iprot->readListBegin(_etype278, _size275);
            this->userCacheList.resize(_size275);
            uint32_t _i279;
            for (_i279 = 0; _i279 < _size275; ++_i279)
            {
              xfer += this->userCacheList[_i279].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.userCacheList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchSaveUser_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchSaveUser_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userCacheList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->userCacheList.size()));
    std::vector< ::com::vrv::cems::service::base::bean::cache::UserCache> ::const_iterator _iter280;
    for (_iter280 = this->userCacheList.begin(); _iter280 != this->userCacheList.end(); ++_iter280)
    {
      xfer += (*_iter280).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchSaveUser_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchSaveUser_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userCacheList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->userCacheList)).size()));
    std::vector< ::com::vrv::cems::service::base::bean::cache::UserCache> ::const_iterator _iter281;
    for (_iter281 = (*(this->userCacheList)).begin(); _iter281 != (*(this->userCacheList)).end(); ++_iter281)
    {
      xfer += (*_iter281).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchSaveUser_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchSaveUser_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_batchSaveUser_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchSaveUser_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveUserOnline_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userOnlineCache.read(iprot);
          this->__isset.userOnlineCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveUserOnline_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveUserOnline_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlineCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->userOnlineCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveUserOnline_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveUserOnline_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlineCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->userOnlineCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveUserOnline_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveUserOnline_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveUserOnline_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveUserOnline_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateUserOnline_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userOnlineCache.read(iprot);
          this->__isset.userOnlineCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateUserOnline_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateUserOnline_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlineCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->userOnlineCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateUserOnline_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateUserOnline_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlineCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->userOnlineCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateUserOnline_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateUserOnline_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateUserOnline_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateUserOnline_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateUserOnlineByField_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userDevId);
          this->__isset.userDevId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->fieldValueMap.clear();
            uint32_t _size282;
            ::apache::thrift::protocol::TType _ktype283;
            ::apache::thrift::protocol::TType _vtype284;
            xfer += iprot->readMapBegin(_ktype283, _vtype284, _size282);
            uint32_t _i286;
            for (_i286 = 0; _i286 < _size282; ++_i286)
            {
              std::string _key287;
              xfer += iprot->readString(_key287);
              std::string& _val288 = this->fieldValueMap[_key287];
              xfer += iprot->readString(_val288);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fieldValueMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateUserOnlineByField_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateUserOnlineByField_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userDevId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->userDevId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldValueMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fieldValueMap.size()));
    std::map<std::string, std::string> ::const_iterator _iter289;
    for (_iter289 = this->fieldValueMap.begin(); _iter289 != this->fieldValueMap.end(); ++_iter289)
    {
      xfer += oprot->writeString(_iter289->first);
      xfer += oprot->writeString(_iter289->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateUserOnlineByField_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateUserOnlineByField_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userDevId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->userDevId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldValueMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->fieldValueMap)).size()));
    std::map<std::string, std::string> ::const_iterator _iter290;
    for (_iter290 = (*(this->fieldValueMap)).begin(); _iter290 != (*(this->fieldValueMap)).end(); ++_iter290)
    {
      xfer += oprot->writeString(_iter290->first);
      xfer += oprot->writeString(_iter290->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateUserOnlineByField_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateUserOnlineByField_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateUserOnlineByField_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateUserOnlineByField_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryUserOnlineByUserDevId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userDevId);
          this->__isset.userDevId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryUserOnlineByUserDevId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryUserOnlineByUserDevId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userDevId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->userDevId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryUserOnlineByUserDevId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryUserOnlineByUserDevId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userDevId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->userDevId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryUserOnlineByUserDevId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryUserOnlineByUserDevId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryUserOnlineByUserDevId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryUserOnlineByUserDevId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteUserOnlineByUserDevId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userDevId);
          this->__isset.userDevId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteUserOnlineByUserDevId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteUserOnlineByUserDevId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userDevId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->userDevId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteUserOnlineByUserDevId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteUserOnlineByUserDevId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userDevId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->userDevId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteUserOnlineByUserDevId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteUserOnlineByUserDevId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteUserOnlineByUserDevId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteUserOnlineByUserDevId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryAllUserOnlineDevice_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryAllUserOnlineDevice_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryAllUserOnlineDevice_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryAllUserOnlineDevice_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryAllUserOnlineDevice_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryAllUserOnlineDevice_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size291;
            ::apache::thrift::protocol::TType _ktype292;
            ::apache::thrift::protocol::TType _vtype293;
            xfer += iprot->readMapBegin(_ktype292, _vtype293, _size291);
            uint32_t _i295;
            for (_i295 = 0; _i295 < _size291; ++_i295)
            {
              std::string _key296;
              xfer += iprot->readString(_key296);
              std::set<std::string> & _val297 = this->success[_key296];
              {
                _val297.clear();
                uint32_t _size298;
                ::apache::thrift::protocol::TType _etype301;
                xfer += iprot->readSetBegin(_etype301, _size298);
                uint32_t _i302;
                for (_i302 = 0; _i302 < _size298; ++_i302)
                {
                  std::string _elem303;
                  xfer += iprot->readString(_elem303);
                  _val297.insert(_elem303);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryAllUserOnlineDevice_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryAllUserOnlineDevice_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::set<std::string> > ::const_iterator _iter304;
      for (_iter304 = this->success.begin(); _iter304 != this->success.end(); ++_iter304)
      {
        xfer += oprot->writeString(_iter304->first);
        {
          xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter304->second.size()));
          std::set<std::string> ::const_iterator _iter305;
          for (_iter305 = _iter304->second.begin(); _iter305 != _iter304->second.end(); ++_iter305)
          {
            xfer += oprot->writeString((*_iter305));
          }
          xfer += oprot->writeSetEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryAllUserOnlineDevice_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size306;
            ::apache::thrift::protocol::TType _ktype307;
            ::apache::thrift::protocol::TType _vtype308;
            xfer += iprot->readMapBegin(_ktype307, _vtype308, _size306);
            uint32_t _i310;
            for (_i310 = 0; _i310 < _size306; ++_i310)
            {
              std::string _key311;
              xfer += iprot->readString(_key311);
              std::set<std::string> & _val312 = (*(this->success))[_key311];
              {
                _val312.clear();
                uint32_t _size313;
                ::apache::thrift::protocol::TType _etype316;
                xfer += iprot->readSetBegin(_etype316, _size313);
                uint32_t _i317;
                for (_i317 = 0; _i317 < _size313; ++_i317)
                {
                  std::string _elem318;
                  xfer += iprot->readString(_elem318);
                  _val312.insert(_elem318);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveUserPolicy_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userPolicyCache.read(iprot);
          this->__isset.userPolicyCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveUserPolicy_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveUserPolicy_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userPolicyCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->userPolicyCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveUserPolicy_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveUserPolicy_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userPolicyCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->userPolicyCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveUserPolicy_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveUserPolicy_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveUserPolicy_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveUserPolicy_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateUserPolicy_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userPolicyCache.read(iprot);
          this->__isset.userPolicyCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateUserPolicy_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateUserPolicy_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userPolicyCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->userPolicyCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateUserPolicy_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateUserPolicy_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userPolicyCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->userPolicyCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateUserPolicy_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateUserPolicy_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateUserPolicy_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateUserPolicy_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryUserPolicyByUserOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userOnlyId);
          this->__isset.userOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryUserPolicyByUserOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryUserPolicyByUserOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->userOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryUserPolicyByUserOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryUserPolicyByUserOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->userOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryUserPolicyByUserOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryUserPolicyByUserOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryUserPolicyByUserOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryUserPolicyByUserOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteUserPolicyByUserOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userOnlyId);
          this->__isset.userOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteUserPolicyByUserOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteUserPolicyByUserOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->userOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteUserPolicyByUserOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteUserPolicyByUserOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->userOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteUserPolicyByUserOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteUserPolicyByUserOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteUserPolicyByUserOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteUserPolicyByUserOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchSaveUserPolicy_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->userPolicyist.clear();
            uint32_t _size319;
            ::apache::thrift::protocol::TType _etype322;
            xfer += iprot->readListBegin(_etype322, _size319);
            this->userPolicyist.resize(_size319);
            uint32_t _i323;
            for (_i323 = 0; _i323 < _size319; ++_i323)
            {
              {
                this->userPolicyist[_i323].clear();
                uint32_t _size324;
                ::apache::thrift::protocol::TType _ktype325;
                ::apache::thrift::protocol::TType _vtype326;
                xfer += iprot->readMapBegin(_ktype325, _vtype326, _size324);
                uint32_t _i328;
                for (_i328 = 0; _i328 < _size324; ++_i328)
                {
                  std::string _key329;
                  xfer += iprot->readString(_key329);
                  std::string& _val330 = this->userPolicyist[_i323][_key329];
                  xfer += iprot->readString(_val330);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.userPolicyist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchSaveUserPolicy_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchSaveUserPolicy_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userPolicyist", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->userPolicyist.size()));
    std::vector<std::map<std::string, std::string> > ::const_iterator _iter331;
    for (_iter331 = this->userPolicyist.begin(); _iter331 != this->userPolicyist.end(); ++_iter331)
    {
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter331).size()));
        std::map<std::string, std::string> ::const_iterator _iter332;
        for (_iter332 = (*_iter331).begin(); _iter332 != (*_iter331).end(); ++_iter332)
        {
          xfer += oprot->writeString(_iter332->first);
          xfer += oprot->writeString(_iter332->second);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchSaveUserPolicy_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchSaveUserPolicy_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userPolicyist", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>((*(this->userPolicyist)).size()));
    std::vector<std::map<std::string, std::string> > ::const_iterator _iter333;
    for (_iter333 = (*(this->userPolicyist)).begin(); _iter333 != (*(this->userPolicyist)).end(); ++_iter333)
    {
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter333).size()));
        std::map<std::string, std::string> ::const_iterator _iter334;
        for (_iter334 = (*_iter333).begin(); _iter334 != (*_iter333).end(); ++_iter334)
        {
          xfer += oprot->writeString(_iter334->first);
          xfer += oprot->writeString(_iter334->second);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchSaveUserPolicy_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchSaveUserPolicy_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_batchSaveUserPolicy_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchSaveUserPolicy_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveProductCInstallPack_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cInstallPackCache.read(iprot);
          this->__isset.cInstallPackCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveProductCInstallPack_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveProductCInstallPack_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cInstallPackCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cInstallPackCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveProductCInstallPack_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveProductCInstallPack_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cInstallPackCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->cInstallPackCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveProductCInstallPack_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveProductCInstallPack_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveProductCInstallPack_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveProductCInstallPack_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateProductCInstallPack_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cInstallPackCache.read(iprot);
          this->__isset.cInstallPackCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateProductCInstallPack_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateProductCInstallPack_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cInstallPackCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cInstallPackCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateProductCInstallPack_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateProductCInstallPack_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cInstallPackCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->cInstallPackCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateProductCInstallPack_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateProductCInstallPack_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateProductCInstallPack_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateProductCInstallPack_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateProductCInstallPackByField_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cInstallPackId);
          this->__isset.cInstallPackId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->fieldValueMap.clear();
            uint32_t _size335;
            ::apache::thrift::protocol::TType _ktype336;
            ::apache::thrift::protocol::TType _vtype337;
            xfer += iprot->readMapBegin(_ktype336, _vtype337, _size335);
            uint32_t _i339;
            for (_i339 = 0; _i339 < _size335; ++_i339)
            {
              std::string _key340;
              xfer += iprot->readString(_key340);
              std::string& _val341 = this->fieldValueMap[_key340];
              xfer += iprot->readString(_val341);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fieldValueMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateProductCInstallPackByField_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateProductCInstallPackByField_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cInstallPackId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->cInstallPackId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldValueMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fieldValueMap.size()));
    std::map<std::string, std::string> ::const_iterator _iter342;
    for (_iter342 = this->fieldValueMap.begin(); _iter342 != this->fieldValueMap.end(); ++_iter342)
    {
      xfer += oprot->writeString(_iter342->first);
      xfer += oprot->writeString(_iter342->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateProductCInstallPackByField_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateProductCInstallPackByField_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cInstallPackId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->cInstallPackId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldValueMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->fieldValueMap)).size()));
    std::map<std::string, std::string> ::const_iterator _iter343;
    for (_iter343 = (*(this->fieldValueMap)).begin(); _iter343 != (*(this->fieldValueMap)).end(); ++_iter343)
    {
      xfer += oprot->writeString(_iter343->first);
      xfer += oprot->writeString(_iter343->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateProductCInstallPackByField_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateProductCInstallPackByField_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateProductCInstallPackByField_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateProductCInstallPackByField_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryProductCInstallPackById_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cInstallPackId);
          this->__isset.cInstallPackId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryProductCInstallPackById_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryProductCInstallPackById_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cInstallPackId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->cInstallPackId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryProductCInstallPackById_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryProductCInstallPackById_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cInstallPackId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->cInstallPackId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryProductCInstallPackById_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryProductCInstallPackById_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryProductCInstallPackById_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryProductCInstallPackById_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteProductCInstallPackById_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cInstallPackId);
          this->__isset.cInstallPackId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteProductCInstallPackById_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteProductCInstallPackById_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cInstallPackId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->cInstallPackId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteProductCInstallPackById_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteProductCInstallPackById_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cInstallPackId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->cInstallPackId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteProductCInstallPackById_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteProductCInstallPackById_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteProductCInstallPackById_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteProductCInstallPackById_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_savePolicy_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->policyCache.read(iprot);
          this->__isset.policyCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_savePolicy_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_savePolicy_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("policyCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->policyCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_savePolicy_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_savePolicy_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("policyCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->policyCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_savePolicy_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_savePolicy_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_savePolicy_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_savePolicy_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updatePolicy_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->policyCache.read(iprot);
          this->__isset.policyCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updatePolicy_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updatePolicy_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("policyCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->policyCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updatePolicy_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updatePolicy_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("policyCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->policyCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updatePolicy_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updatePolicy_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updatePolicy_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updatePolicy_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updatePolicyByField_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->policyId);
          this->__isset.policyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->fieldValueMap.clear();
            uint32_t _size344;
            ::apache::thrift::protocol::TType _ktype345;
            ::apache::thrift::protocol::TType _vtype346;
            xfer += iprot->readMapBegin(_ktype345, _vtype346, _size344);
            uint32_t _i348;
            for (_i348 = 0; _i348 < _size344; ++_i348)
            {
              std::string _key349;
              xfer += iprot->readString(_key349);
              std::string& _val350 = this->fieldValueMap[_key349];
              xfer += iprot->readString(_val350);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fieldValueMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updatePolicyByField_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updatePolicyByField_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("policyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->policyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldValueMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fieldValueMap.size()));
    std::map<std::string, std::string> ::const_iterator _iter351;
    for (_iter351 = this->fieldValueMap.begin(); _iter351 != this->fieldValueMap.end(); ++_iter351)
    {
      xfer += oprot->writeString(_iter351->first);
      xfer += oprot->writeString(_iter351->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updatePolicyByField_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updatePolicyByField_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("policyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->policyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldValueMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->fieldValueMap)).size()));
    std::map<std::string, std::string> ::const_iterator _iter352;
    for (_iter352 = (*(this->fieldValueMap)).begin(); _iter352 != (*(this->fieldValueMap)).end(); ++_iter352)
    {
      xfer += oprot->writeString(_iter352->first);
      xfer += oprot->writeString(_iter352->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updatePolicyByField_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updatePolicyByField_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updatePolicyByField_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updatePolicyByField_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryPolicyByPolicyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->policyId);
          this->__isset.policyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryPolicyByPolicyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryPolicyByPolicyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("policyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->policyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryPolicyByPolicyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryPolicyByPolicyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("policyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->policyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryPolicyByPolicyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryPolicyByPolicyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryPolicyByPolicyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryPolicyByPolicyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deletePolicyByPolicyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->policyId);
          this->__isset.policyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deletePolicyByPolicyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deletePolicyByPolicyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("policyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->policyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deletePolicyByPolicyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deletePolicyByPolicyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("policyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->policyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deletePolicyByPolicyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deletePolicyByPolicyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deletePolicyByPolicyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deletePolicyByPolicyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveIPMAC2DevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mac);
          this->__isset.mac = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveIPMAC2DevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveIPMAC2DevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mac", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->mac);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveIPMAC2DevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveIPMAC2DevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->ip)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mac", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->mac)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveIPMAC2DevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveIPMAC2DevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveIPMAC2DevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveIPMAC2DevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateIPMAC2DevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mac);
          this->__isset.mac = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateIPMAC2DevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateIPMAC2DevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mac", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->mac);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateIPMAC2DevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateIPMAC2DevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->ip)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mac", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->mac)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateIPMAC2DevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateIPMAC2DevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateIPMAC2DevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateIPMAC2DevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryIPMAC2DevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mac);
          this->__isset.mac = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryIPMAC2DevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryIPMAC2DevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mac", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->mac);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryIPMAC2DevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryIPMAC2DevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->ip)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mac", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->mac)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryIPMAC2DevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryIPMAC2DevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryIPMAC2DevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryIPMAC2DevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteIPMAC2DevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mac);
          this->__isset.mac = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteIPMAC2DevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteIPMAC2DevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mac", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->mac);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteIPMAC2DevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteIPMAC2DevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->ip)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mac", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->mac)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteIPMAC2DevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteIPMAC2DevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteIPMAC2DevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteIPMAC2DevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveIP2DevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveIP2DevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveIP2DevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveIP2DevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveIP2DevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->ip)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveIP2DevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveIP2DevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveIP2DevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveIP2DevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateIP2DevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateIP2DevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateIP2DevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateIP2DevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateIP2DevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->ip)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateIP2DevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateIP2DevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateIP2DevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateIP2DevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryIP2DevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryIP2DevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryIP2DevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryIP2DevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryIP2DevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->ip)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryIP2DevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryIP2DevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryIP2DevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryIP2DevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteIP2DevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteIP2DevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteIP2DevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteIP2DevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteIP2DevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->ip)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteIP2DevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteIP2DevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteIP2DevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteIP2DevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveProductCUpgradePack_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cUpgradePackCache.read(iprot);
          this->__isset.cUpgradePackCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveProductCUpgradePack_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveProductCUpgradePack_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cUpgradePackCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cUpgradePackCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveProductCUpgradePack_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveProductCUpgradePack_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cUpgradePackCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->cUpgradePackCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveProductCUpgradePack_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveProductCUpgradePack_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveProductCUpgradePack_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveProductCUpgradePack_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateProductCUpgradePack_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cUpgradePackCache.read(iprot);
          this->__isset.cUpgradePackCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateProductCUpgradePack_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateProductCUpgradePack_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cUpgradePackCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cUpgradePackCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateProductCUpgradePack_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateProductCUpgradePack_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cUpgradePackCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->cUpgradePackCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateProductCUpgradePack_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateProductCUpgradePack_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateProductCUpgradePack_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateProductCUpgradePack_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateProductCUpgradePackByField_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cUpgradePackId);
          this->__isset.cUpgradePackId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->fieldValueMap.clear();
            uint32_t _size353;
            ::apache::thrift::protocol::TType _ktype354;
            ::apache::thrift::protocol::TType _vtype355;
            xfer += iprot->readMapBegin(_ktype354, _vtype355, _size353);
            uint32_t _i357;
            for (_i357 = 0; _i357 < _size353; ++_i357)
            {
              std::string _key358;
              xfer += iprot->readString(_key358);
              std::string& _val359 = this->fieldValueMap[_key358];
              xfer += iprot->readString(_val359);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fieldValueMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateProductCUpgradePackByField_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateProductCUpgradePackByField_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cUpgradePackId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->cUpgradePackId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldValueMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fieldValueMap.size()));
    std::map<std::string, std::string> ::const_iterator _iter360;
    for (_iter360 = this->fieldValueMap.begin(); _iter360 != this->fieldValueMap.end(); ++_iter360)
    {
      xfer += oprot->writeString(_iter360->first);
      xfer += oprot->writeString(_iter360->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateProductCUpgradePackByField_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateProductCUpgradePackByField_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cUpgradePackId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->cUpgradePackId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldValueMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->fieldValueMap)).size()));
    std::map<std::string, std::string> ::const_iterator _iter361;
    for (_iter361 = (*(this->fieldValueMap)).begin(); _iter361 != (*(this->fieldValueMap)).end(); ++_iter361)
    {
      xfer += oprot->writeString(_iter361->first);
      xfer += oprot->writeString(_iter361->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateProductCUpgradePackByField_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateProductCUpgradePackByField_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateProductCUpgradePackByField_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateProductCUpgradePackByField_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryProductCUpgradePackById_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cUpgradePackId);
          this->__isset.cUpgradePackId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryProductCUpgradePackById_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryProductCUpgradePackById_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cUpgradePackId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->cUpgradePackId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryProductCUpgradePackById_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryProductCUpgradePackById_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cUpgradePackId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->cUpgradePackId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryProductCUpgradePackById_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryProductCUpgradePackById_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryProductCUpgradePackById_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryProductCUpgradePackById_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteProductCUpgradePackById_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cUpgradePackId);
          this->__isset.cUpgradePackId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteProductCUpgradePackById_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteProductCUpgradePackById_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cUpgradePackId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->cUpgradePackId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteProductCUpgradePackById_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteProductCUpgradePackById_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cUpgradePackId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->cUpgradePackId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteProductCUpgradePackById_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteProductCUpgradePackById_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteProductCUpgradePackById_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteProductCUpgradePackById_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveAccount2UserOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->account);
          this->__isset.account = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userOnlyId);
          this->__isset.userOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveAccount2UserOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveAccount2UserOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("account", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->account);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->userOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveAccount2UserOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveAccount2UserOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("account", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->account)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->userOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveAccount2UserOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveAccount2UserOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveAccount2UserOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveAccount2UserOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateAccount2UserOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->account);
          this->__isset.account = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userOnlyId);
          this->__isset.userOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateAccount2UserOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateAccount2UserOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("account", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->account);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->userOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateAccount2UserOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateAccount2UserOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("account", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->account)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->userOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateAccount2UserOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateAccount2UserOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateAccount2UserOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateAccount2UserOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryAccount2UserOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->account);
          this->__isset.account = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryAccount2UserOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryAccount2UserOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("account", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->account);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryAccount2UserOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryAccount2UserOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("account", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->account)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryAccount2UserOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryAccount2UserOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryAccount2UserOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryAccount2UserOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteAccount2UserOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->account);
          this->__isset.account = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteAccount2UserOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteAccount2UserOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("account", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->account);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteAccount2UserOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteAccount2UserOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("account", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->account)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteAccount2UserOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteAccount2UserOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteAccount2UserOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteAccount2UserOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchSaveAccount2UserOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->userCacheList.clear();
            uint32_t _size362;
            ::apache::thrift::protocol::TType _etype365;
            xfer += iprot->readListBegin(_etype365, _size362);
            this->userCacheList.resize(_size362);
            uint32_t _i366;
            for (_i366 = 0; _i366 < _size362; ++_i366)
            {
              xfer += this->userCacheList[_i366].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.userCacheList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchSaveAccount2UserOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchSaveAccount2UserOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userCacheList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->userCacheList.size()));
    std::vector< ::com::vrv::cems::service::base::bean::cache::UserCache> ::const_iterator _iter367;
    for (_iter367 = this->userCacheList.begin(); _iter367 != this->userCacheList.end(); ++_iter367)
    {
      xfer += (*_iter367).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchSaveAccount2UserOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_batchSaveAccount2UserOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userCacheList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->userCacheList)).size()));
    std::vector< ::com::vrv::cems::service::base::bean::cache::UserCache> ::const_iterator _iter368;
    for (_iter368 = (*(this->userCacheList)).begin(); _iter368 != (*(this->userCacheList)).end(); ++_iter368)
    {
      xfer += (*_iter368).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchSaveAccount2UserOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_batchSaveAccount2UserOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_batchSaveAccount2UserOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_batchSaveAccount2UserOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_savePtp_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uuid);
          this->__isset.uuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ptpResult);
          this->__isset.ptpResult = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_savePtp_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_savePtp_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uuid", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->uuid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ptpResult", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->ptpResult);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_savePtp_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_savePtp_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uuid", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->uuid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ptpResult", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->ptpResult)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_savePtp_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_savePtp_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_savePtp_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_savePtp_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updatePtp_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uuid);
          this->__isset.uuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ptpResult);
          this->__isset.ptpResult = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updatePtp_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updatePtp_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uuid", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->uuid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ptpResult", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->ptpResult);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updatePtp_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updatePtp_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uuid", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->uuid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ptpResult", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->ptpResult)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updatePtp_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updatePtp_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updatePtp_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updatePtp_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryPtp_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uuid);
          this->__isset.uuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryPtp_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryPtp_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uuid", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->uuid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryPtp_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryPtp_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uuid", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->uuid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryPtp_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryPtp_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryPtp_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryPtp_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deletePtp_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uuid);
          this->__isset.uuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deletePtp_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deletePtp_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uuid", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->uuid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deletePtp_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deletePtp_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uuid", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->uuid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deletePtp_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deletePtp_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deletePtp_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deletePtp_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveSensitive_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sensitiveCache.read(iprot);
          this->__isset.sensitiveCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveSensitive_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveSensitive_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sensitiveCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->sensitiveCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveSensitive_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveSensitive_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sensitiveCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->sensitiveCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveSensitive_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveSensitive_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveSensitive_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveSensitive_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateSensitive_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sensitiveCache.read(iprot);
          this->__isset.sensitiveCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateSensitive_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateSensitive_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sensitiveCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->sensitiveCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateSensitive_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateSensitive_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sensitiveCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->sensitiveCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateSensitive_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateSensitive_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateSensitive_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateSensitive_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_querySensitive_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_querySensitive_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_querySensitive_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_querySensitive_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_querySensitive_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->name)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_querySensitive_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_querySensitive_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_querySensitive_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_querySensitive_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_querySensitiveByField_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fieldKey);
          this->__isset.fieldKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_querySensitiveByField_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_querySensitiveByField_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldKey", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->fieldKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_querySensitiveByField_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_querySensitiveByField_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->name)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldKey", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->fieldKey)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_querySensitiveByField_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_querySensitiveByField_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_querySensitiveByField_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_querySensitiveByField_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteSensitive_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteSensitive_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteSensitive_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteSensitive_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteSensitive_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->name)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteSensitive_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteSensitive_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteSensitive_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteSensitive_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDeviceMsgDigest_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->fieldValueMap.clear();
            uint32_t _size369;
            ::apache::thrift::protocol::TType _ktype370;
            ::apache::thrift::protocol::TType _vtype371;
            xfer += iprot->readMapBegin(_ktype370, _vtype371, _size369);
            uint32_t _i373;
            for (_i373 = 0; _i373 < _size369; ++_i373)
            {
              std::string _key374;
              xfer += iprot->readString(_key374);
              std::vector<std::string> & _val375 = this->fieldValueMap[_key374];
              {
                _val375.clear();
                uint32_t _size376;
                ::apache::thrift::protocol::TType _etype379;
                xfer += iprot->readListBegin(_etype379, _size376);
                _val375.resize(_size376);
                uint32_t _i380;
                for (_i380 = 0; _i380 < _size376; ++_i380)
                {
                  xfer += iprot->readString(_val375[_i380]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fieldValueMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDeviceMsgDigest_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveDeviceMsgDigest_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldValueMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->fieldValueMap.size()));
    std::map<std::string, std::vector<std::string> > ::const_iterator _iter381;
    for (_iter381 = this->fieldValueMap.begin(); _iter381 != this->fieldValueMap.end(); ++_iter381)
    {
      xfer += oprot->writeString(_iter381->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter381->second.size()));
        std::vector<std::string> ::const_iterator _iter382;
        for (_iter382 = _iter381->second.begin(); _iter382 != _iter381->second.end(); ++_iter382)
        {
          xfer += oprot->writeString((*_iter382));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDeviceMsgDigest_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveDeviceMsgDigest_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldValueMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*(this->fieldValueMap)).size()));
    std::map<std::string, std::vector<std::string> > ::const_iterator _iter383;
    for (_iter383 = (*(this->fieldValueMap)).begin(); _iter383 != (*(this->fieldValueMap)).end(); ++_iter383)
    {
      xfer += oprot->writeString(_iter383->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter383->second.size()));
        std::vector<std::string> ::const_iterator _iter384;
        for (_iter384 = _iter383->second.begin(); _iter384 != _iter383->second.end(); ++_iter384)
        {
          xfer += oprot->writeString((*_iter384));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDeviceMsgDigest_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDeviceMsgDigest_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveDeviceMsgDigest_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDeviceMsgDigest_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgType_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msgType);
          this->__isset.msgType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->msgIdList.clear();
            uint32_t _size385;
            ::apache::thrift::protocol::TType _etype388;
            xfer += iprot->readListBegin(_etype388, _size385);
            this->msgIdList.resize(_size385);
            uint32_t _i389;
            for (_i389 = 0; _i389 < _size385; ++_i389)
            {
              xfer += iprot->readString(this->msgIdList[_i389]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.msgIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgType_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgType_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->msgType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgIdList", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->msgIdList.size()));
    std::vector<std::string> ::const_iterator _iter390;
    for (_iter390 = this->msgIdList.begin(); _iter390 != this->msgIdList.end(); ++_iter390)
    {
      xfer += oprot->writeString((*_iter390));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgType_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgType_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->msgType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgIdList", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->msgIdList)).size()));
    std::vector<std::string> ::const_iterator _iter391;
    for (_iter391 = (*(this->msgIdList)).begin(); _iter391 != (*(this->msgIdList)).end(); ++_iter391)
    {
      xfer += oprot->writeString((*_iter391));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgType_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgType_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgType_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgType_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msgType);
          this->__isset.msgType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msgId);
          this->__isset.msgId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->msgType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgId", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->msgId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->msgType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgId", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->msgId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceMsgDigestByDevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceMsgDigestByDevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceMsgDigestByDevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceMsgDigestByDevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceMsgDigestByDevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceMsgDigestByDevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceMsgDigestByDevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteDeviceMsgDigestByDevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceMsgDigestByDevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgType_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msgType);
          this->__isset.msgType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgType_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgType_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->msgType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgType_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgType_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->msgType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgType_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgType_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgType_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgType_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msgType);
          this->__isset.msgType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msgId);
          this->__isset.msgId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->msgType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgId", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->msgId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->msgType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgId", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->msgId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceMsgDigest_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msgType);
          this->__isset.msgType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msgId);
          this->__isset.msgId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceMsgDigest_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateDeviceMsgDigest_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->msgType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgId", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->msgId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceMsgDigest_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateDeviceMsgDigest_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->msgType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgId", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->msgId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceMsgDigest_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateDeviceMsgDigest_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateDeviceMsgDigest_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateDeviceMsgDigest_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceMsgDigestByDevOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceMsgDigestByDevOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceMsgDigestByDevOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceMsgDigestByDevOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceMsgDigestByDevOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceMsgDigestByDevOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size392;
            ::apache::thrift::protocol::TType _ktype393;
            ::apache::thrift::protocol::TType _vtype394;
            xfer += iprot->readMapBegin(_ktype393, _vtype394, _size392);
            uint32_t _i396;
            for (_i396 = 0; _i396 < _size392; ++_i396)
            {
              std::string _key397;
              xfer += iprot->readString(_key397);
              std::vector<std::string> & _val398 = this->success[_key397];
              {
                _val398.clear();
                uint32_t _size399;
                ::apache::thrift::protocol::TType _etype402;
                xfer += iprot->readListBegin(_etype402, _size399);
                _val398.resize(_size399);
                uint32_t _i403;
                for (_i403 = 0; _i403 < _size399; ++_i403)
                {
                  xfer += iprot->readString(_val398[_i403]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceMsgDigestByDevOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryDeviceMsgDigestByDevOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::vector<std::string> > ::const_iterator _iter404;
      for (_iter404 = this->success.begin(); _iter404 != this->success.end(); ++_iter404)
      {
        xfer += oprot->writeString(_iter404->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter404->second.size()));
          std::vector<std::string> ::const_iterator _iter405;
          for (_iter405 = _iter404->second.begin(); _iter405 != _iter404->second.end(); ++_iter405)
          {
            xfer += oprot->writeString((*_iter405));
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceMsgDigestByDevOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size406;
            ::apache::thrift::protocol::TType _ktype407;
            ::apache::thrift::protocol::TType _vtype408;
            xfer += iprot->readMapBegin(_ktype407, _vtype408, _size406);
            uint32_t _i410;
            for (_i410 = 0; _i410 < _size406; ++_i410)
            {
              std::string _key411;
              xfer += iprot->readString(_key411);
              std::vector<std::string> & _val412 = (*(this->success))[_key411];
              {
                _val412.clear();
                uint32_t _size413;
                ::apache::thrift::protocol::TType _etype416;
                xfer += iprot->readListBegin(_etype416, _size413);
                _val412.resize(_size413);
                uint32_t _i417;
                for (_i417 = 0; _i417 < _size413; ++_i417)
                {
                  xfer += iprot->readString(_val412[_i417]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceMsgDigestByDevIdAndMsgType_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devOnlyId);
          this->__isset.devOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msgType);
          this->__isset.msgType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceMsgDigestByDevIdAndMsgType_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceMsgDigestByDevIdAndMsgType_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->devOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->msgType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceMsgDigestByDevIdAndMsgType_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceMsgDigestByDevIdAndMsgType_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->devOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->msgType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceMsgDigestByDevIdAndMsgType_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size418;
            ::apache::thrift::protocol::TType _etype421;
            xfer += iprot->readListBegin(_etype421, _size418);
            this->success.resize(_size418);
            uint32_t _i422;
            for (_i422 = 0; _i422 < _size418; ++_i422)
            {
              xfer += iprot->readString(this->success[_i422]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceMsgDigestByDevIdAndMsgType_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryDeviceMsgDigestByDevIdAndMsgType_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::vector<std::string> ::const_iterator _iter423;
      for (_iter423 = this->success.begin(); _iter423 != this->success.end(); ++_iter423)
      {
        xfer += oprot->writeString((*_iter423));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceMsgDigestByDevIdAndMsgType_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size424;
            ::apache::thrift::protocol::TType _etype427;
            xfer += iprot->readListBegin(_etype427, _size424);
            (*(this->success)).resize(_size424);
            uint32_t _i428;
            for (_i428 = 0; _i428 < _size424; ++_i428)
            {
              xfer += iprot->readString((*(this->success))[_i428]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveUserMsgDigest_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userOnlyId);
          this->__isset.userOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->fieldValueMap.clear();
            uint32_t _size429;
            ::apache::thrift::protocol::TType _ktype430;
            ::apache::thrift::protocol::TType _vtype431;
            xfer += iprot->readMapBegin(_ktype430, _vtype431, _size429);
            uint32_t _i433;
            for (_i433 = 0; _i433 < _size429; ++_i433)
            {
              std::string _key434;
              xfer += iprot->readString(_key434);
              std::vector<std::string> & _val435 = this->fieldValueMap[_key434];
              {
                _val435.clear();
                uint32_t _size436;
                ::apache::thrift::protocol::TType _etype439;
                xfer += iprot->readListBegin(_etype439, _size436);
                _val435.resize(_size436);
                uint32_t _i440;
                for (_i440 = 0; _i440 < _size436; ++_i440)
                {
                  xfer += iprot->readString(_val435[_i440]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fieldValueMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveUserMsgDigest_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveUserMsgDigest_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->userOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldValueMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->fieldValueMap.size()));
    std::map<std::string, std::vector<std::string> > ::const_iterator _iter441;
    for (_iter441 = this->fieldValueMap.begin(); _iter441 != this->fieldValueMap.end(); ++_iter441)
    {
      xfer += oprot->writeString(_iter441->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter441->second.size()));
        std::vector<std::string> ::const_iterator _iter442;
        for (_iter442 = _iter441->second.begin(); _iter442 != _iter441->second.end(); ++_iter442)
        {
          xfer += oprot->writeString((*_iter442));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveUserMsgDigest_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveUserMsgDigest_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->userOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldValueMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*(this->fieldValueMap)).size()));
    std::map<std::string, std::vector<std::string> > ::const_iterator _iter443;
    for (_iter443 = (*(this->fieldValueMap)).begin(); _iter443 != (*(this->fieldValueMap)).end(); ++_iter443)
    {
      xfer += oprot->writeString(_iter443->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter443->second.size()));
        std::vector<std::string> ::const_iterator _iter444;
        for (_iter444 = _iter443->second.begin(); _iter444 != _iter443->second.end(); ++_iter444)
        {
          xfer += oprot->writeString((*_iter444));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveUserMsgDigest_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveUserMsgDigest_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveUserMsgDigest_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveUserMsgDigest_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgType_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userOnlyId);
          this->__isset.userOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msgType);
          this->__isset.msgType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->msgIdList.clear();
            uint32_t _size445;
            ::apache::thrift::protocol::TType _etype448;
            xfer += iprot->readListBegin(_etype448, _size445);
            this->msgIdList.resize(_size445);
            uint32_t _i449;
            for (_i449 = 0; _i449 < _size445; ++_i449)
            {
              xfer += iprot->readString(this->msgIdList[_i449]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.msgIdList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgType_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgType_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->userOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->msgType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgIdList", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->msgIdList.size()));
    std::vector<std::string> ::const_iterator _iter450;
    for (_iter450 = this->msgIdList.begin(); _iter450 != this->msgIdList.end(); ++_iter450)
    {
      xfer += oprot->writeString((*_iter450));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgType_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgType_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->userOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->msgType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgIdList", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->msgIdList)).size()));
    std::vector<std::string> ::const_iterator _iter451;
    for (_iter451 = (*(this->msgIdList)).begin(); _iter451 != (*(this->msgIdList)).end(); ++_iter451)
    {
      xfer += oprot->writeString((*_iter451));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgType_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgType_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgType_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgType_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userOnlyId);
          this->__isset.userOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msgType);
          this->__isset.msgType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msgId);
          this->__isset.msgId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->userOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->msgType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgId", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->msgId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->userOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->msgType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgId", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->msgId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteUserMsgDigestByUserOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userOnlyId);
          this->__isset.userOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteUserMsgDigestByUserOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteUserMsgDigestByUserOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->userOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteUserMsgDigestByUserOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteUserMsgDigestByUserOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->userOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteUserMsgDigestByUserOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteUserMsgDigestByUserOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteUserMsgDigestByUserOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteUserMsgDigestByUserOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgType_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userOnlyId);
          this->__isset.userOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msgType);
          this->__isset.msgType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgType_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgType_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->userOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->msgType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgType_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgType_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->userOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->msgType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgType_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgType_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgType_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgType_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userOnlyId);
          this->__isset.userOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msgType);
          this->__isset.msgType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msgId);
          this->__isset.msgId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->userOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->msgType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgId", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->msgId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->userOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->msgType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgId", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->msgId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateUserMsgDigest_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userOnlyId);
          this->__isset.userOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msgType);
          this->__isset.msgType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msgId);
          this->__isset.msgId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateUserMsgDigest_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateUserMsgDigest_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->userOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->msgType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgId", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->msgId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateUserMsgDigest_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateUserMsgDigest_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->userOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->msgType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgId", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->msgId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateUserMsgDigest_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateUserMsgDigest_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateUserMsgDigest_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateUserMsgDigest_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryUserMsgDigestByUserOnlyId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userOnlyId);
          this->__isset.userOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryUserMsgDigestByUserOnlyId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryUserMsgDigestByUserOnlyId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->userOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryUserMsgDigestByUserOnlyId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryUserMsgDigestByUserOnlyId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->userOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryUserMsgDigestByUserOnlyId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size452;
            ::apache::thrift::protocol::TType _ktype453;
            ::apache::thrift::protocol::TType _vtype454;
            xfer += iprot->readMapBegin(_ktype453, _vtype454, _size452);
            uint32_t _i456;
            for (_i456 = 0; _i456 < _size452; ++_i456)
            {
              std::string _key457;
              xfer += iprot->readString(_key457);
              std::vector<std::string> & _val458 = this->success[_key457];
              {
                _val458.clear();
                uint32_t _size459;
                ::apache::thrift::protocol::TType _etype462;
                xfer += iprot->readListBegin(_etype462, _size459);
                _val458.resize(_size459);
                uint32_t _i463;
                for (_i463 = 0; _i463 < _size459; ++_i463)
                {
                  xfer += iprot->readString(_val458[_i463]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryUserMsgDigestByUserOnlyId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryUserMsgDigestByUserOnlyId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::vector<std::string> > ::const_iterator _iter464;
      for (_iter464 = this->success.begin(); _iter464 != this->success.end(); ++_iter464)
      {
        xfer += oprot->writeString(_iter464->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter464->second.size()));
          std::vector<std::string> ::const_iterator _iter465;
          for (_iter465 = _iter464->second.begin(); _iter465 != _iter464->second.end(); ++_iter465)
          {
            xfer += oprot->writeString((*_iter465));
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryUserMsgDigestByUserOnlyId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size466;
            ::apache::thrift::protocol::TType _ktype467;
            ::apache::thrift::protocol::TType _vtype468;
            xfer += iprot->readMapBegin(_ktype467, _vtype468, _size466);
            uint32_t _i470;
            for (_i470 = 0; _i470 < _size466; ++_i470)
            {
              std::string _key471;
              xfer += iprot->readString(_key471);
              std::vector<std::string> & _val472 = (*(this->success))[_key471];
              {
                _val472.clear();
                uint32_t _size473;
                ::apache::thrift::protocol::TType _etype476;
                xfer += iprot->readListBegin(_etype476, _size473);
                _val472.resize(_size473);
                uint32_t _i477;
                for (_i477 = 0; _i477 < _size473; ++_i477)
                {
                  xfer += iprot->readString(_val472[_i477]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceMsgDigestByUserOnlyIdAndMsgType_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userOnlyId);
          this->__isset.userOnlyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msgType);
          this->__isset.msgType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceMsgDigestByUserOnlyIdAndMsgType_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceMsgDigestByUserOnlyIdAndMsgType_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->userOnlyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->msgType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceMsgDigestByUserOnlyIdAndMsgType_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryDeviceMsgDigestByUserOnlyIdAndMsgType_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userOnlyId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->userOnlyId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->msgType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceMsgDigestByUserOnlyIdAndMsgType_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size478;
            ::apache::thrift::protocol::TType _etype481;
            xfer += iprot->readListBegin(_etype481, _size478);
            this->success.resize(_size478);
            uint32_t _i482;
            for (_i482 = 0; _i482 < _size478; ++_i482)
            {
              xfer += iprot->readString(this->success[_i482]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryDeviceMsgDigestByUserOnlyIdAndMsgType_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryDeviceMsgDigestByUserOnlyIdAndMsgType_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::vector<std::string> ::const_iterator _iter483;
      for (_iter483 = this->success.begin(); _iter483 != this->success.end(); ++_iter483)
      {
        xfer += oprot->writeString((*_iter483));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryDeviceMsgDigestByUserOnlyIdAndMsgType_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size484;
            ::apache::thrift::protocol::TType _etype487;
            xfer += iprot->readListBegin(_etype487, _size484);
            (*(this->success)).resize(_size484);
            uint32_t _i488;
            for (_i488 = 0; _i488 < _size484; ++_i488)
            {
              xfer += iprot->readString((*(this->success))[_i488]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveMsg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->msgCache.read(iprot);
          this->__isset.msgCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveMsg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveMsg_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->msgCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveMsg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveMsg_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->msgCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveMsg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveMsg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveMsg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveMsg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteMsg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msgId);
          this->__isset.msgId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteMsg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteMsg_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->msgId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteMsg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteMsg_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->msgId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteMsg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteMsg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteMsg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteMsg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryMsg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msgId);
          this->__isset.msgId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryMsg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryMsg_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->msgId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryMsg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryMsg_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->msgId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryMsg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryMsg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryMsg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryMsg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveToken_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tokenCache.read(iprot);
          this->__isset.tokenCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveToken_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveToken_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tokenCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->tokenCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveToken_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveToken_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tokenCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->tokenCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveToken_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveToken_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveToken_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveToken_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteTokenByAppId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appId);
          this->__isset.appId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteTokenByAppId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteTokenByAppId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("appId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->appId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteTokenByAppId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteTokenByAppId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("appId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->appId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteTokenByAppId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteTokenByAppId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteTokenByAppId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteTokenByAppId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateTokenByAppId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tokenCache.read(iprot);
          this->__isset.tokenCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateTokenByAppId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateTokenByAppId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tokenCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->tokenCache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateTokenByAppId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateTokenByAppId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tokenCache", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->tokenCache)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateTokenByAppId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateTokenByAppId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateTokenByAppId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateTokenByAppId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryTokenByAppId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appId);
          this->__isset.appId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryTokenByAppId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryTokenByAppId_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("appId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->appId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryTokenByAppId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_queryTokenByAppId_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("appId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->appId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryTokenByAppId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_queryTokenByAppId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_queryTokenByAppId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_queryTokenByAppId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveSession_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->sId);
          this->__isset.sId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->hashMap.clear();
            uint32_t _size489;
            ::apache::thrift::protocol::TType _ktype490;
            ::apache::thrift::protocol::TType _vtype491;
            xfer += iprot->readMapBegin(_ktype490, _vtype491, _size489);
            uint32_t _i493;
            for (_i493 = 0; _i493 < _size489; ++_i493)
            {
              std::string _key494;
              xfer += iprot->readBinary(_key494);
              std::string& _val495 = this->hashMap[_key494];
              xfer += iprot->readBinary(_val495);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.hashMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveSession_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveSession_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->sId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hashMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->hashMap.size()));
    std::map<std::string, std::string> ::const_iterator _iter496;
    for (_iter496 = this->hashMap.begin(); _iter496 != this->hashMap.end(); ++_iter496)
    {
      xfer += oprot->writeBinary(_iter496->first);
      xfer += oprot->writeBinary(_iter496->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveSession_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveSession_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->sId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hashMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->hashMap)).size()));
    std::map<std::string, std::string> ::const_iterator _iter497;
    for (_iter497 = (*(this->hashMap)).begin(); _iter497 != (*(this->hashMap)).end(); ++_iter497)
    {
      xfer += oprot->writeBinary(_iter497->first);
      xfer += oprot->writeBinary(_iter497->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveSession_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveSession_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveSession_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveSession_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveSessionByDetail_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->sId);
          this->__isset.sId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveSessionByDetail_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveSessionByDetail_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->sId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveSessionByDetail_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_saveSessionByDetail_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->sId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary((*(this->value)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveSessionByDetail_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_saveSessionByDetail_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_saveSessionByDetail_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_saveSessionByDetail_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteSession_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->sId);
          this->__isset.sId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteSession_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteSession_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->sId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteSession_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteSession_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->sId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteSession_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteSession_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteSession_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteSession_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteSessionByDetail_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->sId);
          this->__isset.sId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteSessionByDetail_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteSessionByDetail_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->sId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteSessionByDetail_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_deleteSessionByDetail_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->sId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteSessionByDetail_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_deleteSessionByDetail_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_deleteSessionByDetail_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_deleteSessionByDetail_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updataSessionByDetail_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->sId);
          this->__isset.sId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updataSessionByDetail_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updataSessionByDetail_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->sId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updataSessionByDetail_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updataSessionByDetail_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->sId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary((*(this->value)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updataSessionByDetail_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updataSessionByDetail_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updataSessionByDetail_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updataSessionByDetail_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateSession_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->sId);
          this->__isset.sId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->hashMap.clear();
            uint32_t _size498;
            ::apache::thrift::protocol::TType _ktype499;
            ::apache::thrift::protocol::TType _vtype500;
            xfer += iprot->readMapBegin(_ktype499, _vtype500, _size498);
            uint32_t _i502;
            for (_i502 = 0; _i502 < _size498; ++_i502)
            {
              std::string _key503;
              xfer += iprot->readBinary(_key503);
              std::string& _val504 = this->hashMap[_key503];
              xfer += iprot->readBinary(_val504);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.hashMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateSession_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateSession_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->sId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hashMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->hashMap.size()));
    std::map<std::string, std::string> ::const_iterator _iter505;
    for (_iter505 = this->hashMap.begin(); _iter505 != this->hashMap.end(); ++_iter505)
    {
      xfer += oprot->writeBinary(_iter505->first);
      xfer += oprot->writeBinary(_iter505->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateSession_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_updateSession_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->sId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hashMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->hashMap)).size()));
    std::map<std::string, std::string> ::const_iterator _iter506;
    for (_iter506 = (*(this->hashMap)).begin(); _iter506 != (*(this->hashMap)).end(); ++_iter506)
    {
      xfer += oprot->writeBinary(_iter506->first);
      xfer += oprot->writeBinary(_iter506->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateSession_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_updateSession_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_updateSession_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_updateSession_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_querySessionByDetail_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->sId);
          this->__isset.sId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_querySessionByDetail_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_querySessionByDetail_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->sId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_querySessionByDetail_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_querySessionByDetail_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->sId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_querySessionByDetail_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_querySessionByDetail_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_querySessionByDetail_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeBinary(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_querySessionByDetail_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_querySession_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->sId);
          this->__isset.sId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_querySession_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_querySession_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->sId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_querySession_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_querySession_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->sId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_querySession_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size507;
            ::apache::thrift::protocol::TType _ktype508;
            ::apache::thrift::protocol::TType _vtype509;
            xfer += iprot->readMapBegin(_ktype508, _vtype509, _size507);
            uint32_t _i511;
            for (_i511 = 0; _i511 < _size507; ++_i511)
            {
              std::string _key512;
              xfer += iprot->readBinary(_key512);
              std::string& _val513 = this->success[_key512];
              xfer += iprot->readBinary(_val513);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_querySession_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_querySession_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::string> ::const_iterator _iter514;
      for (_iter514 = this->success.begin(); _iter514 != this->success.end(); ++_iter514)
      {
        xfer += oprot->writeBinary(_iter514->first);
        xfer += oprot->writeBinary(_iter514->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_querySession_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size515;
            ::apache::thrift::protocol::TType _ktype516;
            ::apache::thrift::protocol::TType _vtype517;
            xfer += iprot->readMapBegin(_ktype516, _vtype517, _size515);
            uint32_t _i519;
            for (_i519 = 0; _i519 < _size515; ++_i519)
            {
              std::string _key520;
              xfer += iprot->readBinary(_key520);
              std::string& _val521 = (*(this->success))[_key520];
              xfer += iprot->readBinary(_val521);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHset_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->field);
          this->__isset.field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHset_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonHset_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("field", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->field);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHset_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonHset_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("field", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->field)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->value)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHset_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHset_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonHset_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHset_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHmset_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->hashMap.clear();
            uint32_t _size522;
            ::apache::thrift::protocol::TType _ktype523;
            ::apache::thrift::protocol::TType _vtype524;
            xfer += iprot->readMapBegin(_ktype523, _vtype524, _size522);
            uint32_t _i526;
            for (_i526 = 0; _i526 < _size522; ++_i526)
            {
              std::string _key527;
              xfer += iprot->readString(_key527);
              std::string& _val528 = this->hashMap[_key527];
              xfer += iprot->readString(_val528);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.hashMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHmset_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonHmset_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hashMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->hashMap.size()));
    std::map<std::string, std::string> ::const_iterator _iter529;
    for (_iter529 = this->hashMap.begin(); _iter529 != this->hashMap.end(); ++_iter529)
    {
      xfer += oprot->writeString(_iter529->first);
      xfer += oprot->writeString(_iter529->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHmset_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonHmset_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hashMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->hashMap)).size()));
    std::map<std::string, std::string> ::const_iterator _iter530;
    for (_iter530 = (*(this->hashMap)).begin(); _iter530 != (*(this->hashMap)).end(); ++_iter530)
    {
      xfer += oprot->writeString(_iter530->first);
      xfer += oprot->writeString(_iter530->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHmset_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHmset_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonHmset_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHmset_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHsetnx_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->field);
          this->__isset.field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHsetnx_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonHsetnx_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("field", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->field);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHsetnx_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonHsetnx_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("field", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->field)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->value)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHsetnx_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHsetnx_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonHsetnx_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHsetnx_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHdel_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fields.clear();
            uint32_t _size531;
            ::apache::thrift::protocol::TType _etype534;
            xfer += iprot->readListBegin(_etype534, _size531);
            this->fields.resize(_size531);
            uint32_t _i535;
            for (_i535 = 0; _i535 < _size531; ++_i535)
            {
              xfer += iprot->readString(this->fields[_i535]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHdel_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonHdel_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fields.size()));
    std::vector<std::string> ::const_iterator _iter536;
    for (_iter536 = this->fields.begin(); _iter536 != this->fields.end(); ++_iter536)
    {
      xfer += oprot->writeString((*_iter536));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHdel_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonHdel_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->fields)).size()));
    std::vector<std::string> ::const_iterator _iter537;
    for (_iter537 = (*(this->fields)).begin(); _iter537 != (*(this->fields)).end(); ++_iter537)
    {
      xfer += oprot->writeString((*_iter537));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHdel_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHdel_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonHdel_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHdel_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonBatchHget_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->keys.clear();
            uint32_t _size538;
            ::apache::thrift::protocol::TType _etype541;
            xfer += iprot->readListBegin(_etype541, _size538);
            this->keys.resize(_size538);
            uint32_t _i542;
            for (_i542 = 0; _i542 < _size538; ++_i542)
            {
              xfer += iprot->readString(this->keys[_i542]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.keys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonBatchHget_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonBatchHget_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("keys", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->keys.size()));
    std::vector<std::string> ::const_iterator _iter543;
    for (_iter543 = this->keys.begin(); _iter543 != this->keys.end(); ++_iter543)
    {
      xfer += oprot->writeString((*_iter543));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonBatchHget_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonBatchHget_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("keys", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->keys)).size()));
    std::vector<std::string> ::const_iterator _iter544;
    for (_iter544 = (*(this->keys)).begin(); _iter544 != (*(this->keys)).end(); ++_iter544)
    {
      xfer += oprot->writeString((*_iter544));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonBatchHget_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size545;
            ::apache::thrift::protocol::TType _ktype546;
            ::apache::thrift::protocol::TType _vtype547;
            xfer += iprot->readMapBegin(_ktype546, _vtype547, _size545);
            uint32_t _i549;
            for (_i549 = 0; _i549 < _size545; ++_i549)
            {
              std::string _key550;
              xfer += iprot->readString(_key550);
              std::map<std::string, std::string> & _val551 = this->success[_key550];
              {
                _val551.clear();
                uint32_t _size552;
                ::apache::thrift::protocol::TType _ktype553;
                ::apache::thrift::protocol::TType _vtype554;
                xfer += iprot->readMapBegin(_ktype553, _vtype554, _size552);
                uint32_t _i556;
                for (_i556 = 0; _i556 < _size552; ++_i556)
                {
                  std::string _key557;
                  xfer += iprot->readString(_key557);
                  std::string& _val558 = _val551[_key557];
                  xfer += iprot->readString(_val558);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonBatchHget_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonBatchHget_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::map<std::string, std::string> > ::const_iterator _iter559;
      for (_iter559 = this->success.begin(); _iter559 != this->success.end(); ++_iter559)
      {
        xfer += oprot->writeString(_iter559->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter559->second.size()));
          std::map<std::string, std::string> ::const_iterator _iter560;
          for (_iter560 = _iter559->second.begin(); _iter560 != _iter559->second.end(); ++_iter560)
          {
            xfer += oprot->writeString(_iter560->first);
            xfer += oprot->writeString(_iter560->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonBatchHget_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size561;
            ::apache::thrift::protocol::TType _ktype562;
            ::apache::thrift::protocol::TType _vtype563;
            xfer += iprot->readMapBegin(_ktype562, _vtype563, _size561);
            uint32_t _i565;
            for (_i565 = 0; _i565 < _size561; ++_i565)
            {
              std::string _key566;
              xfer += iprot->readString(_key566);
              std::map<std::string, std::string> & _val567 = (*(this->success))[_key566];
              {
                _val567.clear();
                uint32_t _size568;
                ::apache::thrift::protocol::TType _ktype569;
                ::apache::thrift::protocol::TType _vtype570;
                xfer += iprot->readMapBegin(_ktype569, _vtype570, _size568);
                uint32_t _i572;
                for (_i572 = 0; _i572 < _size568; ++_i572)
                {
                  std::string _key573;
                  xfer += iprot->readString(_key573);
                  std::string& _val574 = _val567[_key573];
                  xfer += iprot->readString(_val574);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHgetAll_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHgetAll_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonHgetAll_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHgetAll_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonHgetAll_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHgetAll_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size575;
            ::apache::thrift::protocol::TType _ktype576;
            ::apache::thrift::protocol::TType _vtype577;
            xfer += iprot->readMapBegin(_ktype576, _vtype577, _size575);
            uint32_t _i579;
            for (_i579 = 0; _i579 < _size575; ++_i579)
            {
              std::string _key580;
              xfer += iprot->readString(_key580);
              std::string& _val581 = this->success[_key580];
              xfer += iprot->readString(_val581);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHgetAll_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonHgetAll_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::string> ::const_iterator _iter582;
      for (_iter582 = this->success.begin(); _iter582 != this->success.end(); ++_iter582)
      {
        xfer += oprot->writeString(_iter582->first);
        xfer += oprot->writeString(_iter582->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHgetAll_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size583;
            ::apache::thrift::protocol::TType _ktype584;
            ::apache::thrift::protocol::TType _vtype585;
            xfer += iprot->readMapBegin(_ktype584, _vtype585, _size583);
            uint32_t _i587;
            for (_i587 = 0; _i587 < _size583; ++_i587)
            {
              std::string _key588;
              xfer += iprot->readString(_key588);
              std::string& _val589 = (*(this->success))[_key588];
              xfer += iprot->readString(_val589);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHget_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->field);
          this->__isset.field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHget_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonHget_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("field", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->field);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHget_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonHget_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("field", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->field)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHget_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHget_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonHget_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHget_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHmget_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fields.clear();
            uint32_t _size590;
            ::apache::thrift::protocol::TType _etype593;
            xfer += iprot->readListBegin(_etype593, _size590);
            this->fields.resize(_size590);
            uint32_t _i594;
            for (_i594 = 0; _i594 < _size590; ++_i594)
            {
              xfer += iprot->readString(this->fields[_i594]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHmget_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonHmget_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fields.size()));
    std::vector<std::string> ::const_iterator _iter595;
    for (_iter595 = this->fields.begin(); _iter595 != this->fields.end(); ++_iter595)
    {
      xfer += oprot->writeString((*_iter595));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHmget_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonHmget_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->fields)).size()));
    std::vector<std::string> ::const_iterator _iter596;
    for (_iter596 = (*(this->fields)).begin(); _iter596 != (*(this->fields)).end(); ++_iter596)
    {
      xfer += oprot->writeString((*_iter596));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHmget_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size597;
            ::apache::thrift::protocol::TType _etype600;
            xfer += iprot->readListBegin(_etype600, _size597);
            this->success.resize(_size597);
            uint32_t _i601;
            for (_i601 = 0; _i601 < _size597; ++_i601)
            {
              xfer += iprot->readString(this->success[_i601]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHmget_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonHmget_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::vector<std::string> ::const_iterator _iter602;
      for (_iter602 = this->success.begin(); _iter602 != this->success.end(); ++_iter602)
      {
        xfer += oprot->writeString((*_iter602));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHmget_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size603;
            ::apache::thrift::protocol::TType _etype606;
            xfer += iprot->readListBegin(_etype606, _size603);
            (*(this->success)).resize(_size603);
            uint32_t _i607;
            for (_i607 = 0; _i607 < _size603; ++_i607)
            {
              xfer += iprot->readString((*(this->success))[_i607]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHscan_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cursor);
          this->__isset.cursor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->match);
          this->__isset.match = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHscan_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonHscan_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cursor", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->cursor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("match", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->match);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHscan_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonHscan_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cursor", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->cursor)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("match", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->match)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString((*(this->count)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHscan_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size608;
            ::apache::thrift::protocol::TType _ktype609;
            ::apache::thrift::protocol::TType _vtype610;
            xfer += iprot->readMapBegin(_ktype609, _vtype610, _size608);
            uint32_t _i612;
            for (_i612 = 0; _i612 < _size608; ++_i612)
            {
              std::string _key613;
              xfer += iprot->readString(_key613);
              std::string& _val614 = this->success[_key613];
              xfer += iprot->readString(_val614);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHscan_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonHscan_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::string> ::const_iterator _iter615;
      for (_iter615 = this->success.begin(); _iter615 != this->success.end(); ++_iter615)
      {
        xfer += oprot->writeString(_iter615->first);
        xfer += oprot->writeString(_iter615->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHscan_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size616;
            ::apache::thrift::protocol::TType _ktype617;
            ::apache::thrift::protocol::TType _vtype618;
            xfer += iprot->readMapBegin(_ktype617, _vtype618, _size616);
            uint32_t _i620;
            for (_i620 = 0; _i620 < _size616; ++_i620)
            {
              std::string _key621;
              xfer += iprot->readString(_key621);
              std::string& _val622 = (*(this->success))[_key621];
              xfer += iprot->readString(_val622);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHvals_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHvals_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonHvals_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHvals_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonHvals_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHvals_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size623;
            ::apache::thrift::protocol::TType _etype626;
            xfer += iprot->readListBegin(_etype626, _size623);
            this->success.resize(_size623);
            uint32_t _i627;
            for (_i627 = 0; _i627 < _size623; ++_i627)
            {
              xfer += iprot->readString(this->success[_i627]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHvals_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonHvals_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::vector<std::string> ::const_iterator _iter628;
      for (_iter628 = this->success.begin(); _iter628 != this->success.end(); ++_iter628)
      {
        xfer += oprot->writeString((*_iter628));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHvals_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size629;
            ::apache::thrift::protocol::TType _etype632;
            xfer += iprot->readListBegin(_etype632, _size629);
            (*(this->success)).resize(_size629);
            uint32_t _i633;
            for (_i633 = 0; _i633 < _size629; ++_i633)
            {
              xfer += iprot->readString((*(this->success))[_i633]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHexists_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->field);
          this->__isset.field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHexists_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonHexists_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("field", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->field);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHexists_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonHexists_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("field", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->field)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHexists_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHexists_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonHexists_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHexists_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHlen_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHlen_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonHlen_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHlen_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonHlen_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHlen_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonHlen_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonHlen_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonHlen_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZadd_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->hashMap.clear();
            uint32_t _size634;
            ::apache::thrift::protocol::TType _ktype635;
            ::apache::thrift::protocol::TType _vtype636;
            xfer += iprot->readMapBegin(_ktype635, _vtype636, _size634);
            uint32_t _i638;
            for (_i638 = 0; _i638 < _size634; ++_i638)
            {
              std::string _key639;
              xfer += iprot->readString(_key639);
              double& _val640 = this->hashMap[_key639];
              xfer += iprot->readDouble(_val640);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.hashMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->options);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZadd_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZadd_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hashMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->hashMap.size()));
    std::map<std::string, double> ::const_iterator _iter641;
    for (_iter641 = this->hashMap.begin(); _iter641 != this->hashMap.end(); ++_iter641)
    {
      xfer += oprot->writeString(_iter641->first);
      xfer += oprot->writeDouble(_iter641->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->options);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZadd_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZadd_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hashMap", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>((*(this->hashMap)).size()));
    std::map<std::string, double> ::const_iterator _iter642;
    for (_iter642 = (*(this->hashMap)).begin(); _iter642 != (*(this->hashMap)).end(); ++_iter642)
    {
      xfer += oprot->writeString(_iter642->first);
      xfer += oprot->writeDouble(_iter642->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->options)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZadd_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZadd_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonZadd_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZadd_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZrem_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->members.clear();
            uint32_t _size643;
            ::apache::thrift::protocol::TType _etype646;
            xfer += iprot->readListBegin(_etype646, _size643);
            this->members.resize(_size643);
            uint32_t _i647;
            for (_i647 = 0; _i647 < _size643; ++_i647)
            {
              xfer += iprot->readString(this->members[_i647]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.members = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZrem_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZrem_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("members", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->members.size()));
    std::vector<std::string> ::const_iterator _iter648;
    for (_iter648 = this->members.begin(); _iter648 != this->members.end(); ++_iter648)
    {
      xfer += oprot->writeString((*_iter648));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZrem_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZrem_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("members", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->members)).size()));
    std::vector<std::string> ::const_iterator _iter649;
    for (_iter649 = (*(this->members)).begin(); _iter649 != (*(this->members)).end(); ++_iter649)
    {
      xfer += oprot->writeString((*_iter649));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZrem_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZrem_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonZrem_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZrem_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZremrangeByScore_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->min);
          this->__isset.min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->max);
          this->__isset.max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZremrangeByScore_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZremrangeByScore_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZremrangeByScore_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZremrangeByScore_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble((*(this->min)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble((*(this->max)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZremrangeByScore_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZremrangeByScore_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonZremrangeByScore_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZremrangeByScore_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZremrangeByRank_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->min);
          this->__isset.min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max);
          this->__isset.max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZremrangeByRank_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZremrangeByRank_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZremrangeByRank_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZremrangeByRank_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64((*(this->min)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64((*(this->max)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZremrangeByRank_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZremrangeByRank_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonZremrangeByRank_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZremrangeByRank_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZremrangeByLex_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->min);
          this->__isset.min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->max);
          this->__isset.max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZremrangeByLex_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZremrangeByLex_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZremrangeByLex_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZremrangeByLex_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->min)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->max)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZremrangeByLex_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZremrangeByLex_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonZremrangeByLex_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZremrangeByLex_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZcard_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZcard_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZcard_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZcard_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZcard_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZcard_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZcard_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonZcard_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZcard_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZscore_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->member);
          this->__isset.member = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZscore_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZscore_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("member", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->member);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZscore_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZscore_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("member", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->member)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZscore_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZscore_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonZscore_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZscore_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZrank_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->member);
          this->__isset.member = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sortType);
          this->__isset.sortType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZrank_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZrank_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("member", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->member);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sortType", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sortType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZrank_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZrank_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("member", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->member)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sortType", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->sortType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZrank_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZrank_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonZrank_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZrank_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonPageZrangeByScore_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->min);
          this->__isset.min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->max);
          this->__isset.max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sortType);
          this->__isset.sortType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonPageZrangeByScore_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonPageZrangeByScore_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sortType", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sortType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonPageZrangeByScore_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonPageZrangeByScore_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble((*(this->min)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble((*(this->max)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sortType", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString((*(this->sortType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((*(this->offset)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32((*(this->count)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonPageZrangeByScore_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->success.clear();
            uint32_t _size650;
            ::apache::thrift::protocol::TType _etype653;
            xfer += iprot->readSetBegin(_etype653, _size650);
            uint32_t _i654;
            for (_i654 = 0; _i654 < _size650; ++_i654)
            {
              std::string _elem655;
              xfer += iprot->readString(_elem655);
              this->success.insert(_elem655);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonPageZrangeByScore_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonPageZrangeByScore_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_SET, 0);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::set<std::string> ::const_iterator _iter656;
      for (_iter656 = this->success.begin(); _iter656 != this->success.end(); ++_iter656)
      {
        xfer += oprot->writeString((*_iter656));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonPageZrangeByScore_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            (*(this->success)).clear();
            uint32_t _size657;
            ::apache::thrift::protocol::TType _etype660;
            xfer += iprot->readSetBegin(_etype660, _size657);
            uint32_t _i661;
            for (_i661 = 0; _i661 < _size657; ++_i661)
            {
              std::string _elem662;
              xfer += iprot->readString(_elem662);
              (*(this->success)).insert(_elem662);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonPageZrangeByScoreWithScores_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->min);
          this->__isset.min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->max);
          this->__isset.max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sortType);
          this->__isset.sortType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonPageZrangeByScoreWithScores_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonPageZrangeByScoreWithScores_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sortType", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sortType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonPageZrangeByScoreWithScores_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonPageZrangeByScoreWithScores_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble((*(this->min)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble((*(this->max)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sortType", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString((*(this->sortType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((*(this->offset)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32((*(this->count)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonPageZrangeByScoreWithScores_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size663;
            ::apache::thrift::protocol::TType _ktype664;
            ::apache::thrift::protocol::TType _vtype665;
            xfer += iprot->readMapBegin(_ktype664, _vtype665, _size663);
            uint32_t _i667;
            for (_i667 = 0; _i667 < _size663; ++_i667)
            {
              std::string _key668;
              xfer += iprot->readString(_key668);
              std::string& _val669 = this->success[_key668];
              xfer += iprot->readString(_val669);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonPageZrangeByScoreWithScores_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonPageZrangeByScoreWithScores_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::string> ::const_iterator _iter670;
      for (_iter670 = this->success.begin(); _iter670 != this->success.end(); ++_iter670)
      {
        xfer += oprot->writeString(_iter670->first);
        xfer += oprot->writeString(_iter670->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonPageZrangeByScoreWithScores_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size671;
            ::apache::thrift::protocol::TType _ktype672;
            ::apache::thrift::protocol::TType _vtype673;
            xfer += iprot->readMapBegin(_ktype672, _vtype673, _size671);
            uint32_t _i675;
            for (_i675 = 0; _i675 < _size671; ++_i675)
            {
              std::string _key676;
              xfer += iprot->readString(_key676);
              std::string& _val677 = (*(this->success))[_key676];
              xfer += iprot->readString(_val677);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZrangeByScore_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->min);
          this->__isset.min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->max);
          this->__isset.max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sortType);
          this->__isset.sortType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZrangeByScore_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZrangeByScore_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sortType", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sortType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZrangeByScore_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZrangeByScore_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble((*(this->min)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble((*(this->max)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sortType", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString((*(this->sortType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZrangeByScore_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size678;
            ::apache::thrift::protocol::TType _ktype679;
            ::apache::thrift::protocol::TType _vtype680;
            xfer += iprot->readMapBegin(_ktype679, _vtype680, _size678);
            uint32_t _i682;
            for (_i682 = 0; _i682 < _size678; ++_i682)
            {
              std::string _key683;
              xfer += iprot->readString(_key683);
              std::string& _val684 = this->success[_key683];
              xfer += iprot->readString(_val684);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZrangeByScore_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonZrangeByScore_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::string> ::const_iterator _iter685;
      for (_iter685 = this->success.begin(); _iter685 != this->success.end(); ++_iter685)
      {
        xfer += oprot->writeString(_iter685->first);
        xfer += oprot->writeString(_iter685->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZrangeByScore_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size686;
            ::apache::thrift::protocol::TType _ktype687;
            ::apache::thrift::protocol::TType _vtype688;
            xfer += iprot->readMapBegin(_ktype687, _vtype688, _size686);
            uint32_t _i690;
            for (_i690 = 0; _i690 < _size686; ++_i690)
            {
              std::string _key691;
              xfer += iprot->readString(_key691);
              std::string& _val692 = (*(this->success))[_key691];
              xfer += iprot->readString(_val692);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZrangeByScoreWithScores_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->min);
          this->__isset.min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->max);
          this->__isset.max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sortType);
          this->__isset.sortType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZrangeByScoreWithScores_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZrangeByScoreWithScores_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sortType", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sortType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZrangeByScoreWithScores_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZrangeByScoreWithScores_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble((*(this->min)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble((*(this->max)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sortType", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString((*(this->sortType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZrangeByScoreWithScores_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->success.clear();
            uint32_t _size693;
            ::apache::thrift::protocol::TType _etype696;
            xfer += iprot->readSetBegin(_etype696, _size693);
            uint32_t _i697;
            for (_i697 = 0; _i697 < _size693; ++_i697)
            {
              std::string _elem698;
              xfer += iprot->readString(_elem698);
              this->success.insert(_elem698);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZrangeByScoreWithScores_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonZrangeByScoreWithScores_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_SET, 0);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::set<std::string> ::const_iterator _iter699;
      for (_iter699 = this->success.begin(); _iter699 != this->success.end(); ++_iter699)
      {
        xfer += oprot->writeString((*_iter699));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZrangeByScoreWithScores_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            (*(this->success)).clear();
            uint32_t _size700;
            ::apache::thrift::protocol::TType _etype703;
            xfer += iprot->readSetBegin(_etype703, _size700);
            uint32_t _i704;
            for (_i704 = 0; _i704 < _size700; ++_i704)
            {
              std::string _elem705;
              xfer += iprot->readString(_elem705);
              (*(this->success)).insert(_elem705);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZrange_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->min);
          this->__isset.min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max);
          this->__isset.max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sortType);
          this->__isset.sortType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZrange_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZrange_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sortType", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sortType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZrange_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZrange_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64((*(this->min)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64((*(this->max)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sortType", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString((*(this->sortType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZrange_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->success.clear();
            uint32_t _size706;
            ::apache::thrift::protocol::TType _etype709;
            xfer += iprot->readSetBegin(_etype709, _size706);
            uint32_t _i710;
            for (_i710 = 0; _i710 < _size706; ++_i710)
            {
              std::string _elem711;
              xfer += iprot->readString(_elem711);
              this->success.insert(_elem711);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZrange_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonZrange_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_SET, 0);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::set<std::string> ::const_iterator _iter712;
      for (_iter712 = this->success.begin(); _iter712 != this->success.end(); ++_iter712)
      {
        xfer += oprot->writeString((*_iter712));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZrange_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            (*(this->success)).clear();
            uint32_t _size713;
            ::apache::thrift::protocol::TType _etype716;
            xfer += iprot->readSetBegin(_etype716, _size713);
            uint32_t _i717;
            for (_i717 = 0; _i717 < _size713; ++_i717)
            {
              std::string _elem718;
              xfer += iprot->readString(_elem718);
              (*(this->success)).insert(_elem718);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZincrby_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->sorce);
          this->__isset.sorce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->member);
          this->__isset.member = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZincrby_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZincrby_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sorce", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->sorce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("member", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->member);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZincrby_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZincrby_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sorce", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble((*(this->sorce)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("member", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->member)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZincrby_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZincrby_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonZincrby_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZincrby_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZcount_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->maxCode);
          this->__isset.maxCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->minCode);
          this->__isset.minCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->min);
          this->__isset.min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->max);
          this->__isset.max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZcount_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZcount_args");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->maxCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->minCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZcount_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CacheService_commonZcount_pargs");

  xfer += oprot->writeFieldBegin("maxCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->maxCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->minCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble((*(this->min)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble((*(this->max)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZcount_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheService_commonZcount_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CacheService_commonZcount_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t CacheService_commonZcount_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void CacheServiceClient::getDataTS(std::string& _return, const std::string& maxCode, const std::string& minCode, const std::string& checkCode, const bool isZip, const std::string& data, const bool isEncrypt, const std::string& key, const int32_t flag)
{
  send_getDataTS(maxCode, minCode, checkCode, isZip, data, isEncrypt, key, flag);
  recv_getDataTS(_return);
}

void CacheServiceClient::send_getDataTS(const std::string& maxCode, const std::string& minCode, const std::string& checkCode, const bool isZip, const std::string& data, const bool isEncrypt, const std::string& key, const int32_t flag)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getDataTS", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_getDataTS_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.checkCode = &checkCode;
  args.isZip = &isZip;
  args.data = &data;
  args.isEncrypt = &isEncrypt;
  args.key = &key;
  args.flag = &flag;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_getDataTS(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getDataTS") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_getDataTS_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getDataTS failed: unknown result");
}

void CacheServiceClient::isExist( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& prefix, const std::string& key)
{
  send_isExist(maxCode, minCode, prefix, key);
  recv_isExist(_return);
}

void CacheServiceClient::send_isExist(const std::string& maxCode, const std::string& minCode, const std::string& prefix, const std::string& key)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("isExist", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_isExist_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.prefix = &prefix;
  args.key = &key;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_isExist( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("isExist") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_isExist_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "isExist failed: unknown result");
}

void CacheServiceClient::setExpireTimeByString( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& key, const int32_t expireTime)
{
  send_setExpireTimeByString(maxCode, minCode, key, expireTime);
  recv_setExpireTimeByString(_return);
}

void CacheServiceClient::send_setExpireTimeByString(const std::string& maxCode, const std::string& minCode, const std::string& key, const int32_t expireTime)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("setExpireTimeByString", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_setExpireTimeByString_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.expireTime = &expireTime;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_setExpireTimeByString( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("setExpireTimeByString") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_setExpireTimeByString_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "setExpireTimeByString failed: unknown result");
}

void CacheServiceClient::setExpireTimeByBinary( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& key, const int32_t expireTime)
{
  send_setExpireTimeByBinary(maxCode, minCode, key, expireTime);
  recv_setExpireTimeByBinary(_return);
}

void CacheServiceClient::send_setExpireTimeByBinary(const std::string& maxCode, const std::string& minCode, const std::string& key, const int32_t expireTime)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("setExpireTimeByBinary", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_setExpireTimeByBinary_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.expireTime = &expireTime;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_setExpireTimeByBinary( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("setExpireTimeByBinary") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_setExpireTimeByBinary_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "setExpireTimeByBinary failed: unknown result");
}

void CacheServiceClient::batchDel( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::vector<std::string> & keyList)
{
  send_batchDel(maxCode, minCode, keyList);
  recv_batchDel(_return);
}

void CacheServiceClient::send_batchDel(const std::string& maxCode, const std::string& minCode, const std::vector<std::string> & keyList)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("batchDel", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_batchDel_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.keyList = &keyList;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_batchDel( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("batchDel") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_batchDel_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "batchDel failed: unknown result");
}

void CacheServiceClient::saveDevice( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceCache& deviceCache)
{
  send_saveDevice(maxCode, minCode, deviceCache);
  recv_saveDevice(_return);
}

void CacheServiceClient::send_saveDevice(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceCache& deviceCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveDevice", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveDevice_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.deviceCache = &deviceCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveDevice( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveDevice") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveDevice_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveDevice failed: unknown result");
}

void CacheServiceClient::updateDevice( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceCache& deviceCache)
{
  send_updateDevice(maxCode, minCode, deviceCache);
  recv_updateDevice(_return);
}

void CacheServiceClient::send_updateDevice(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceCache& deviceCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateDevice", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateDevice_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.deviceCache = &deviceCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateDevice( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateDevice") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateDevice_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateDevice failed: unknown result");
}

void CacheServiceClient::updateDeviceByField( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::map<std::string, std::string> & fieldValueMap)
{
  send_updateDeviceByField(maxCode, minCode, devOnlyId, fieldValueMap);
  recv_updateDeviceByField(_return);
}

void CacheServiceClient::send_updateDeviceByField(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::map<std::string, std::string> & fieldValueMap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateDeviceByField", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateDeviceByField_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.fieldValueMap = &fieldValueMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateDeviceByField( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateDeviceByField") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateDeviceByField_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateDeviceByField failed: unknown result");
}

void CacheServiceClient::queryDevice( ::com::vrv::cems::service::base::bean::cache::DeviceCache& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceCache& deviceCache)
{
  send_queryDevice(maxCode, minCode, deviceCache);
  recv_queryDevice(_return);
}

void CacheServiceClient::send_queryDevice(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceCache& deviceCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryDevice", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryDevice_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.deviceCache = &deviceCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryDevice( ::com::vrv::cems::service::base::bean::cache::DeviceCache& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryDevice") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryDevice_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryDevice failed: unknown result");
}

void CacheServiceClient::queryDeviceByDevOnlyId( ::com::vrv::cems::service::base::bean::cache::DeviceCache& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  send_queryDeviceByDevOnlyId(maxCode, minCode, devOnlyId);
  recv_queryDeviceByDevOnlyId(_return);
}

void CacheServiceClient::send_queryDeviceByDevOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryDeviceByDevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryDeviceByDevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryDeviceByDevOnlyId( ::com::vrv::cems::service::base::bean::cache::DeviceCache& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryDeviceByDevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryDeviceByDevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryDeviceByDevOnlyId failed: unknown result");
}

void CacheServiceClient::queryDeviceByIp( ::com::vrv::cems::service::base::bean::cache::DeviceCache& _return, const std::string& maxCode, const std::string& minCode, const std::string& ip)
{
  send_queryDeviceByIp(maxCode, minCode, ip);
  recv_queryDeviceByIp(_return);
}

void CacheServiceClient::send_queryDeviceByIp(const std::string& maxCode, const std::string& minCode, const std::string& ip)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryDeviceByIp", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryDeviceByIp_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.ip = &ip;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryDeviceByIp( ::com::vrv::cems::service::base::bean::cache::DeviceCache& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryDeviceByIp") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryDeviceByIp_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryDeviceByIp failed: unknown result");
}

void CacheServiceClient::deleteDevice( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceCache& deviceCache)
{
  send_deleteDevice(maxCode, minCode, deviceCache);
  recv_deleteDevice(_return);
}

void CacheServiceClient::send_deleteDevice(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceCache& deviceCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteDevice", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteDevice_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.deviceCache = &deviceCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteDevice( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteDevice") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteDevice_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteDevice failed: unknown result");
}

void CacheServiceClient::deleteDeviceByDevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  send_deleteDeviceByDevOnlyId(maxCode, minCode, devOnlyId);
  recv_deleteDeviceByDevOnlyId(_return);
}

void CacheServiceClient::send_deleteDeviceByDevOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteDeviceByDevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteDeviceByDevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteDeviceByDevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteDeviceByDevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteDeviceByDevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteDeviceByDevOnlyId failed: unknown result");
}

void CacheServiceClient::deleteDeviceByIp( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& ip)
{
  send_deleteDeviceByIp(maxCode, minCode, ip);
  recv_deleteDeviceByIp(_return);
}

void CacheServiceClient::send_deleteDeviceByIp(const std::string& maxCode, const std::string& minCode, const std::string& ip)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteDeviceByIp", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteDeviceByIp_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.ip = &ip;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteDeviceByIp( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteDeviceByIp") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteDeviceByIp_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteDeviceByIp failed: unknown result");
}

void CacheServiceClient::batchSaveDevice(std::vector< ::com::vrv::cems::service::base::bean::cache::Result> & _return, const std::string& maxCode, const std::string& minCode, const std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceCache> & deviceCacheList)
{
  send_batchSaveDevice(maxCode, minCode, deviceCacheList);
  recv_batchSaveDevice(_return);
}

void CacheServiceClient::send_batchSaveDevice(const std::string& maxCode, const std::string& minCode, const std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceCache> & deviceCacheList)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("batchSaveDevice", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_batchSaveDevice_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.deviceCacheList = &deviceCacheList;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_batchSaveDevice(std::vector< ::com::vrv::cems::service::base::bean::cache::Result> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("batchSaveDevice") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_batchSaveDevice_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "batchSaveDevice failed: unknown result");
}

void CacheServiceClient::batchUpdateDevice(std::vector< ::com::vrv::cems::service::base::bean::cache::Result> & _return, const std::string& maxCode, const std::string& minCode, const std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceCache> & deviceCacheList)
{
  send_batchUpdateDevice(maxCode, minCode, deviceCacheList);
  recv_batchUpdateDevice(_return);
}

void CacheServiceClient::send_batchUpdateDevice(const std::string& maxCode, const std::string& minCode, const std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceCache> & deviceCacheList)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("batchUpdateDevice", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_batchUpdateDevice_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.deviceCacheList = &deviceCacheList;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_batchUpdateDevice(std::vector< ::com::vrv::cems::service::base::bean::cache::Result> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("batchUpdateDevice") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_batchUpdateDevice_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "batchUpdateDevice failed: unknown result");
}

void CacheServiceClient::batchQueryDevice(std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceCache> & _return, const std::string& maxCode, const std::string& minCode, const std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceCache> & deviceCacheList)
{
  send_batchQueryDevice(maxCode, minCode, deviceCacheList);
  recv_batchQueryDevice(_return);
}

void CacheServiceClient::send_batchQueryDevice(const std::string& maxCode, const std::string& minCode, const std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceCache> & deviceCacheList)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("batchQueryDevice", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_batchQueryDevice_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.deviceCacheList = &deviceCacheList;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_batchQueryDevice(std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceCache> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("batchQueryDevice") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_batchQueryDevice_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "batchQueryDevice failed: unknown result");
}

void CacheServiceClient::batchQueryDeviceByDevOnlyId(std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceCache> & _return, const std::string& maxCode, const std::string& minCode, const std::vector<std::string> & devOnlyIdList)
{
  send_batchQueryDeviceByDevOnlyId(maxCode, minCode, devOnlyIdList);
  recv_batchQueryDeviceByDevOnlyId(_return);
}

void CacheServiceClient::send_batchQueryDeviceByDevOnlyId(const std::string& maxCode, const std::string& minCode, const std::vector<std::string> & devOnlyIdList)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("batchQueryDeviceByDevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_batchQueryDeviceByDevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyIdList = &devOnlyIdList;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_batchQueryDeviceByDevOnlyId(std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceCache> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("batchQueryDeviceByDevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_batchQueryDeviceByDevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "batchQueryDeviceByDevOnlyId failed: unknown result");
}

void CacheServiceClient::batchDeleteDevice(std::vector< ::com::vrv::cems::service::base::bean::cache::Result> & _return, const std::string& maxCode, const std::string& minCode, const std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceCache> & deviceCacheList)
{
  send_batchDeleteDevice(maxCode, minCode, deviceCacheList);
  recv_batchDeleteDevice(_return);
}

void CacheServiceClient::send_batchDeleteDevice(const std::string& maxCode, const std::string& minCode, const std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceCache> & deviceCacheList)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("batchDeleteDevice", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_batchDeleteDevice_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.deviceCacheList = &deviceCacheList;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_batchDeleteDevice(std::vector< ::com::vrv::cems::service::base::bean::cache::Result> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("batchDeleteDevice") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_batchDeleteDevice_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "batchDeleteDevice failed: unknown result");
}

void CacheServiceClient::batchDeleteDeviceByDevOnlyId(std::vector< ::com::vrv::cems::service::base::bean::cache::Result> & _return, const std::string& maxCode, const std::string& minCode, const std::vector<std::string> & devOnlyIdList)
{
  send_batchDeleteDeviceByDevOnlyId(maxCode, minCode, devOnlyIdList);
  recv_batchDeleteDeviceByDevOnlyId(_return);
}

void CacheServiceClient::send_batchDeleteDeviceByDevOnlyId(const std::string& maxCode, const std::string& minCode, const std::vector<std::string> & devOnlyIdList)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("batchDeleteDeviceByDevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_batchDeleteDeviceByDevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyIdList = &devOnlyIdList;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_batchDeleteDeviceByDevOnlyId(std::vector< ::com::vrv::cems::service::base::bean::cache::Result> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("batchDeleteDeviceByDevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_batchDeleteDeviceByDevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "batchDeleteDeviceByDevOnlyId failed: unknown result");
}

void CacheServiceClient::saveDeviceOnline( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceOnlineCache& deviceOnlineCache)
{
  send_saveDeviceOnline(maxCode, minCode, deviceOnlineCache);
  recv_saveDeviceOnline(_return);
}

void CacheServiceClient::send_saveDeviceOnline(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceOnlineCache& deviceOnlineCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveDeviceOnline", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveDeviceOnline_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.deviceOnlineCache = &deviceOnlineCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveDeviceOnline( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveDeviceOnline") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveDeviceOnline_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveDeviceOnline failed: unknown result");
}

void CacheServiceClient::updateDeviceOnline( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceOnlineCache& deviceOnlineCache)
{
  send_updateDeviceOnline(maxCode, minCode, deviceOnlineCache);
  recv_updateDeviceOnline(_return);
}

void CacheServiceClient::send_updateDeviceOnline(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceOnlineCache& deviceOnlineCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateDeviceOnline", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateDeviceOnline_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.deviceOnlineCache = &deviceOnlineCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateDeviceOnline( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateDeviceOnline") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateDeviceOnline_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateDeviceOnline failed: unknown result");
}

void CacheServiceClient::updateDeviceOnlineByField( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::map<std::string, std::string> & fieldValueMap)
{
  send_updateDeviceOnlineByField(maxCode, minCode, devOnlyId, fieldValueMap);
  recv_updateDeviceOnlineByField(_return);
}

void CacheServiceClient::send_updateDeviceOnlineByField(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::map<std::string, std::string> & fieldValueMap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateDeviceOnlineByField", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateDeviceOnlineByField_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.fieldValueMap = &fieldValueMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateDeviceOnlineByField( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateDeviceOnlineByField") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateDeviceOnlineByField_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateDeviceOnlineByField failed: unknown result");
}

void CacheServiceClient::queryDeviceOnline( ::com::vrv::cems::service::base::bean::cache::DeviceOnlineCache& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceOnlineCache& deviceOnlineCache)
{
  send_queryDeviceOnline(maxCode, minCode, deviceOnlineCache);
  recv_queryDeviceOnline(_return);
}

void CacheServiceClient::send_queryDeviceOnline(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceOnlineCache& deviceOnlineCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryDeviceOnline", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryDeviceOnline_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.deviceOnlineCache = &deviceOnlineCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryDeviceOnline( ::com::vrv::cems::service::base::bean::cache::DeviceOnlineCache& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryDeviceOnline") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryDeviceOnline_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryDeviceOnline failed: unknown result");
}

void CacheServiceClient::queryDeviceOnlineByDevOnlyId( ::com::vrv::cems::service::base::bean::cache::DeviceOnlineCache& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  send_queryDeviceOnlineByDevOnlyId(maxCode, minCode, devOnlyId);
  recv_queryDeviceOnlineByDevOnlyId(_return);
}

void CacheServiceClient::send_queryDeviceOnlineByDevOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryDeviceOnlineByDevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryDeviceOnlineByDevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryDeviceOnlineByDevOnlyId( ::com::vrv::cems::service::base::bean::cache::DeviceOnlineCache& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryDeviceOnlineByDevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryDeviceOnlineByDevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryDeviceOnlineByDevOnlyId failed: unknown result");
}

void CacheServiceClient::queryDeviceOnlineByIp( ::com::vrv::cems::service::base::bean::cache::DeviceOnlineCache& _return, const std::string& maxCode, const std::string& minCode, const std::string& ip)
{
  send_queryDeviceOnlineByIp(maxCode, minCode, ip);
  recv_queryDeviceOnlineByIp(_return);
}

void CacheServiceClient::send_queryDeviceOnlineByIp(const std::string& maxCode, const std::string& minCode, const std::string& ip)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryDeviceOnlineByIp", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryDeviceOnlineByIp_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.ip = &ip;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryDeviceOnlineByIp( ::com::vrv::cems::service::base::bean::cache::DeviceOnlineCache& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryDeviceOnlineByIp") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryDeviceOnlineByIp_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryDeviceOnlineByIp failed: unknown result");
}

void CacheServiceClient::deleteDeviceOnline( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceOnlineCache& deviceOnlineCache)
{
  send_deleteDeviceOnline(maxCode, minCode, deviceOnlineCache);
  recv_deleteDeviceOnline(_return);
}

void CacheServiceClient::send_deleteDeviceOnline(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceOnlineCache& deviceOnlineCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteDeviceOnline", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteDeviceOnline_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.deviceOnlineCache = &deviceOnlineCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteDeviceOnline( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteDeviceOnline") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteDeviceOnline_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteDeviceOnline failed: unknown result");
}

void CacheServiceClient::deleteDeviceOnlineByDevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  send_deleteDeviceOnlineByDevOnlyId(maxCode, minCode, devOnlyId);
  recv_deleteDeviceOnlineByDevOnlyId(_return);
}

void CacheServiceClient::send_deleteDeviceOnlineByDevOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteDeviceOnlineByDevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteDeviceOnlineByDevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteDeviceOnlineByDevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteDeviceOnlineByDevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteDeviceOnlineByDevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteDeviceOnlineByDevOnlyId failed: unknown result");
}

void CacheServiceClient::deleteDeviceOnlineByIp( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& ip)
{
  send_deleteDeviceOnlineByIp(maxCode, minCode, ip);
  recv_deleteDeviceOnlineByIp(_return);
}

void CacheServiceClient::send_deleteDeviceOnlineByIp(const std::string& maxCode, const std::string& minCode, const std::string& ip)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteDeviceOnlineByIp", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteDeviceOnlineByIp_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.ip = &ip;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteDeviceOnlineByIp( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteDeviceOnlineByIp") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteDeviceOnlineByIp_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteDeviceOnlineByIp failed: unknown result");
}

void CacheServiceClient::queryAllDeviceOnlineCache(std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceOnlineCache> & _return, const std::string& maxCode, const std::string& minCode)
{
  send_queryAllDeviceOnlineCache(maxCode, minCode);
  recv_queryAllDeviceOnlineCache(_return);
}

void CacheServiceClient::send_queryAllDeviceOnlineCache(const std::string& maxCode, const std::string& minCode)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryAllDeviceOnlineCache", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryAllDeviceOnlineCache_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryAllDeviceOnlineCache(std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceOnlineCache> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryAllDeviceOnlineCache") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryAllDeviceOnlineCache_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryAllDeviceOnlineCache failed: unknown result");
}

void CacheServiceClient::queryOnlineDevOnlyIdsByUserOnlyId(std::vector<std::string> & _return, const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId)
{
  send_queryOnlineDevOnlyIdsByUserOnlyId(maxCode, minCode, userOnlyId);
  recv_queryOnlineDevOnlyIdsByUserOnlyId(_return);
}

void CacheServiceClient::send_queryOnlineDevOnlyIdsByUserOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryOnlineDevOnlyIdsByUserOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryOnlineDevOnlyIdsByUserOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userOnlyId = &userOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryOnlineDevOnlyIdsByUserOnlyId(std::vector<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryOnlineDevOnlyIdsByUserOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryOnlineDevOnlyIdsByUserOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryOnlineDevOnlyIdsByUserOnlyId failed: unknown result");
}

void CacheServiceClient::batchQueryDeviceOnlinesByDevOnlyIdList(std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceOnlineCache> & _return, const std::string& maxCode, const std::string& minCode, const std::vector<std::string> & devOnlyIdList)
{
  send_batchQueryDeviceOnlinesByDevOnlyIdList(maxCode, minCode, devOnlyIdList);
  recv_batchQueryDeviceOnlinesByDevOnlyIdList(_return);
}

void CacheServiceClient::send_batchQueryDeviceOnlinesByDevOnlyIdList(const std::string& maxCode, const std::string& minCode, const std::vector<std::string> & devOnlyIdList)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("batchQueryDeviceOnlinesByDevOnlyIdList", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_batchQueryDeviceOnlinesByDevOnlyIdList_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyIdList = &devOnlyIdList;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_batchQueryDeviceOnlinesByDevOnlyIdList(std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceOnlineCache> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("batchQueryDeviceOnlinesByDevOnlyIdList") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_batchQueryDeviceOnlinesByDevOnlyIdList_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "batchQueryDeviceOnlinesByDevOnlyIdList failed: unknown result");
}

void CacheServiceClient::saveDeviceKey( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceKeyCache& deviceKeyCache)
{
  send_saveDeviceKey(maxCode, minCode, deviceKeyCache);
  recv_saveDeviceKey(_return);
}

void CacheServiceClient::send_saveDeviceKey(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceKeyCache& deviceKeyCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveDeviceKey", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveDeviceKey_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.deviceKeyCache = &deviceKeyCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveDeviceKey( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveDeviceKey") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveDeviceKey_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveDeviceKey failed: unknown result");
}

void CacheServiceClient::updateDeviceKey( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceKeyCache& deviceKeyCache)
{
  send_updateDeviceKey(maxCode, minCode, deviceKeyCache);
  recv_updateDeviceKey(_return);
}

void CacheServiceClient::send_updateDeviceKey(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceKeyCache& deviceKeyCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateDeviceKey", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateDeviceKey_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.deviceKeyCache = &deviceKeyCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateDeviceKey( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateDeviceKey") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateDeviceKey_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateDeviceKey failed: unknown result");
}

void CacheServiceClient::updateDeviceKeyByField( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& sessionId, const std::map<std::string, std::string> & fieldValueMap)
{
  send_updateDeviceKeyByField(maxCode, minCode, sessionId, fieldValueMap);
  recv_updateDeviceKeyByField(_return);
}

void CacheServiceClient::send_updateDeviceKeyByField(const std::string& maxCode, const std::string& minCode, const std::string& sessionId, const std::map<std::string, std::string> & fieldValueMap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateDeviceKeyByField", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateDeviceKeyByField_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.sessionId = &sessionId;
  args.fieldValueMap = &fieldValueMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateDeviceKeyByField( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateDeviceKeyByField") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateDeviceKeyByField_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateDeviceKeyByField failed: unknown result");
}

void CacheServiceClient::queryDeviceKey( ::com::vrv::cems::service::base::bean::cache::DeviceKeyCache& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceKeyCache& deviceKeyCache)
{
  send_queryDeviceKey(maxCode, minCode, deviceKeyCache);
  recv_queryDeviceKey(_return);
}

void CacheServiceClient::send_queryDeviceKey(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceKeyCache& deviceKeyCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryDeviceKey", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryDeviceKey_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.deviceKeyCache = &deviceKeyCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryDeviceKey( ::com::vrv::cems::service::base::bean::cache::DeviceKeyCache& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryDeviceKey") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryDeviceKey_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryDeviceKey failed: unknown result");
}

void CacheServiceClient::queryDeviceKeyBySessionId( ::com::vrv::cems::service::base::bean::cache::DeviceKeyCache& _return, const std::string& maxCode, const std::string& minCode, const std::string& sessionId)
{
  send_queryDeviceKeyBySessionId(maxCode, minCode, sessionId);
  recv_queryDeviceKeyBySessionId(_return);
}

void CacheServiceClient::send_queryDeviceKeyBySessionId(const std::string& maxCode, const std::string& minCode, const std::string& sessionId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryDeviceKeyBySessionId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryDeviceKeyBySessionId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.sessionId = &sessionId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryDeviceKeyBySessionId( ::com::vrv::cems::service::base::bean::cache::DeviceKeyCache& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryDeviceKeyBySessionId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryDeviceKeyBySessionId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryDeviceKeyBySessionId failed: unknown result");
}

void CacheServiceClient::queryDeviceKeyByDevOnlyId( ::com::vrv::cems::service::base::bean::cache::DeviceKeyCache& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  send_queryDeviceKeyByDevOnlyId(maxCode, minCode, devOnlyId);
  recv_queryDeviceKeyByDevOnlyId(_return);
}

void CacheServiceClient::send_queryDeviceKeyByDevOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryDeviceKeyByDevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryDeviceKeyByDevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryDeviceKeyByDevOnlyId( ::com::vrv::cems::service::base::bean::cache::DeviceKeyCache& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryDeviceKeyByDevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryDeviceKeyByDevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryDeviceKeyByDevOnlyId failed: unknown result");
}

void CacheServiceClient::deleteDeviceKey( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceKeyCache& deviceKeyCache)
{
  send_deleteDeviceKey(maxCode, minCode, deviceKeyCache);
  recv_deleteDeviceKey(_return);
}

void CacheServiceClient::send_deleteDeviceKey(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DeviceKeyCache& deviceKeyCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteDeviceKey", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteDeviceKey_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.deviceKeyCache = &deviceKeyCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteDeviceKey( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteDeviceKey") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteDeviceKey_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteDeviceKey failed: unknown result");
}

void CacheServiceClient::deleteDeviceKeyBySessionId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& sessionId)
{
  send_deleteDeviceKeyBySessionId(maxCode, minCode, sessionId);
  recv_deleteDeviceKeyBySessionId(_return);
}

void CacheServiceClient::send_deleteDeviceKeyBySessionId(const std::string& maxCode, const std::string& minCode, const std::string& sessionId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteDeviceKeyBySessionId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteDeviceKeyBySessionId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.sessionId = &sessionId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteDeviceKeyBySessionId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteDeviceKeyBySessionId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteDeviceKeyBySessionId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteDeviceKeyBySessionId failed: unknown result");
}

void CacheServiceClient::deleteDeviceKeyByDevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  send_deleteDeviceKeyByDevOnlyId(maxCode, minCode, devOnlyId);
  recv_deleteDeviceKeyByDevOnlyId(_return);
}

void CacheServiceClient::send_deleteDeviceKeyByDevOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteDeviceKeyByDevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteDeviceKeyByDevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteDeviceKeyByDevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteDeviceKeyByDevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteDeviceKeyByDevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteDeviceKeyByDevOnlyId failed: unknown result");
}

void CacheServiceClient::isExistSessionIdInDeviceKeyCache( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& sessionId)
{
  send_isExistSessionIdInDeviceKeyCache(maxCode, minCode, sessionId);
  recv_isExistSessionIdInDeviceKeyCache(_return);
}

void CacheServiceClient::send_isExistSessionIdInDeviceKeyCache(const std::string& maxCode, const std::string& minCode, const std::string& sessionId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("isExistSessionIdInDeviceKeyCache", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_isExistSessionIdInDeviceKeyCache_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.sessionId = &sessionId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_isExistSessionIdInDeviceKeyCache( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("isExistSessionIdInDeviceKeyCache") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_isExistSessionIdInDeviceKeyCache_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "isExistSessionIdInDeviceKeyCache failed: unknown result");
}

void CacheServiceClient::batchQueryDeviceKeysBySessionIdList(std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceKeyCache> & _return, const std::string& maxCode, const std::string& minCode, const std::vector<std::string> & sessionIdList)
{
  send_batchQueryDeviceKeysBySessionIdList(maxCode, minCode, sessionIdList);
  recv_batchQueryDeviceKeysBySessionIdList(_return);
}

void CacheServiceClient::send_batchQueryDeviceKeysBySessionIdList(const std::string& maxCode, const std::string& minCode, const std::vector<std::string> & sessionIdList)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("batchQueryDeviceKeysBySessionIdList", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_batchQueryDeviceKeysBySessionIdList_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.sessionIdList = &sessionIdList;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_batchQueryDeviceKeysBySessionIdList(std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceKeyCache> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("batchQueryDeviceKeysBySessionIdList") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_batchQueryDeviceKeysBySessionIdList_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "batchQueryDeviceKeysBySessionIdList failed: unknown result");
}

void CacheServiceClient::saveDeviceInsProOld( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceProduct> & deviceProductList)
{
  send_saveDeviceInsProOld(maxCode, minCode, devOnlyId, deviceProductList);
  recv_saveDeviceInsProOld(_return);
}

void CacheServiceClient::send_saveDeviceInsProOld(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceProduct> & deviceProductList)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveDeviceInsProOld", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveDeviceInsProOld_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.deviceProductList = &deviceProductList;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveDeviceInsProOld( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveDeviceInsProOld") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveDeviceInsProOld_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveDeviceInsProOld failed: unknown result");
}

void CacheServiceClient::updateDeviceInsProOld( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceProduct> & deviceProductList)
{
  send_updateDeviceInsProOld(maxCode, minCode, devOnlyId, deviceProductList);
  recv_updateDeviceInsProOld(_return);
}

void CacheServiceClient::send_updateDeviceInsProOld(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceProduct> & deviceProductList)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateDeviceInsProOld", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateDeviceInsProOld_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.deviceProductList = &deviceProductList;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateDeviceInsProOld( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateDeviceInsProOld") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateDeviceInsProOld_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateDeviceInsProOld failed: unknown result");
}

void CacheServiceClient::queryDeviceInsProOldByDevOnlyId(std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceProduct> & _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  send_queryDeviceInsProOldByDevOnlyId(maxCode, minCode, devOnlyId);
  recv_queryDeviceInsProOldByDevOnlyId(_return);
}

void CacheServiceClient::send_queryDeviceInsProOldByDevOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryDeviceInsProOldByDevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryDeviceInsProOldByDevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryDeviceInsProOldByDevOnlyId(std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceProduct> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryDeviceInsProOldByDevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryDeviceInsProOldByDevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryDeviceInsProOldByDevOnlyId failed: unknown result");
}

void CacheServiceClient::deleteDeviceInsProOldByDevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  send_deleteDeviceInsProOldByDevOnlyId(maxCode, minCode, devOnlyId);
  recv_deleteDeviceInsProOldByDevOnlyId(_return);
}

void CacheServiceClient::send_deleteDeviceInsProOldByDevOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteDeviceInsProOldByDevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteDeviceInsProOldByDevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteDeviceInsProOldByDevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteDeviceInsProOldByDevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteDeviceInsProOldByDevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteDeviceInsProOldByDevOnlyId failed: unknown result");
}

void CacheServiceClient::saveDeviceInsProNew( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceProduct> & deviceProductList)
{
  send_saveDeviceInsProNew(maxCode, minCode, devOnlyId, deviceProductList);
  recv_saveDeviceInsProNew(_return);
}

void CacheServiceClient::send_saveDeviceInsProNew(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceProduct> & deviceProductList)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveDeviceInsProNew", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveDeviceInsProNew_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.deviceProductList = &deviceProductList;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveDeviceInsProNew( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveDeviceInsProNew") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveDeviceInsProNew_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveDeviceInsProNew failed: unknown result");
}

void CacheServiceClient::updateDeviceInsProNew( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceProduct> & deviceProductList)
{
  send_updateDeviceInsProNew(maxCode, minCode, devOnlyId, deviceProductList);
  recv_updateDeviceInsProNew(_return);
}

void CacheServiceClient::send_updateDeviceInsProNew(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceProduct> & deviceProductList)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateDeviceInsProNew", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateDeviceInsProNew_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.deviceProductList = &deviceProductList;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateDeviceInsProNew( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateDeviceInsProNew") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateDeviceInsProNew_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateDeviceInsProNew failed: unknown result");
}

void CacheServiceClient::queryDeviceInsProNewByDevOnlyId(std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceProduct> & _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  send_queryDeviceInsProNewByDevOnlyId(maxCode, minCode, devOnlyId);
  recv_queryDeviceInsProNewByDevOnlyId(_return);
}

void CacheServiceClient::send_queryDeviceInsProNewByDevOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryDeviceInsProNewByDevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryDeviceInsProNewByDevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryDeviceInsProNewByDevOnlyId(std::vector< ::com::vrv::cems::service::base::bean::cache::DeviceProduct> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryDeviceInsProNewByDevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryDeviceInsProNewByDevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryDeviceInsProNewByDevOnlyId failed: unknown result");
}

void CacheServiceClient::deleteDeviceInsProNewByDevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  send_deleteDeviceInsProNewByDevOnlyId(maxCode, minCode, devOnlyId);
  recv_deleteDeviceInsProNewByDevOnlyId(_return);
}

void CacheServiceClient::send_deleteDeviceInsProNewByDevOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteDeviceInsProNewByDevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteDeviceInsProNewByDevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteDeviceInsProNewByDevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteDeviceInsProNewByDevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteDeviceInsProNewByDevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteDeviceInsProNewByDevOnlyId failed: unknown result");
}

void CacheServiceClient::saveDevicePolicy( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DevicePolicyCache& devicePolicyCache)
{
  send_saveDevicePolicy(maxCode, minCode, devicePolicyCache);
  recv_saveDevicePolicy(_return);
}

void CacheServiceClient::send_saveDevicePolicy(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DevicePolicyCache& devicePolicyCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveDevicePolicy", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveDevicePolicy_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devicePolicyCache = &devicePolicyCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveDevicePolicy( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveDevicePolicy") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveDevicePolicy_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveDevicePolicy failed: unknown result");
}

void CacheServiceClient::updateDevicePolicy( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DevicePolicyCache& devicePolicyCache)
{
  send_updateDevicePolicy(maxCode, minCode, devicePolicyCache);
  recv_updateDevicePolicy(_return);
}

void CacheServiceClient::send_updateDevicePolicy(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::DevicePolicyCache& devicePolicyCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateDevicePolicy", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateDevicePolicy_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devicePolicyCache = &devicePolicyCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateDevicePolicy( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateDevicePolicy") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateDevicePolicy_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateDevicePolicy failed: unknown result");
}

void CacheServiceClient::queryDevicePolicyByDevOnlyId( ::com::vrv::cems::service::base::bean::cache::DevicePolicyCache& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  send_queryDevicePolicyByDevOnlyId(maxCode, minCode, devOnlyId);
  recv_queryDevicePolicyByDevOnlyId(_return);
}

void CacheServiceClient::send_queryDevicePolicyByDevOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryDevicePolicyByDevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryDevicePolicyByDevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryDevicePolicyByDevOnlyId( ::com::vrv::cems::service::base::bean::cache::DevicePolicyCache& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryDevicePolicyByDevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryDevicePolicyByDevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryDevicePolicyByDevOnlyId failed: unknown result");
}

void CacheServiceClient::queryDevicePolicyByIp( ::com::vrv::cems::service::base::bean::cache::DevicePolicyCache& _return, const std::string& maxCode, const std::string& minCode, const std::string& ip)
{
  send_queryDevicePolicyByIp(maxCode, minCode, ip);
  recv_queryDevicePolicyByIp(_return);
}

void CacheServiceClient::send_queryDevicePolicyByIp(const std::string& maxCode, const std::string& minCode, const std::string& ip)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryDevicePolicyByIp", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryDevicePolicyByIp_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.ip = &ip;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryDevicePolicyByIp( ::com::vrv::cems::service::base::bean::cache::DevicePolicyCache& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryDevicePolicyByIp") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryDevicePolicyByIp_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryDevicePolicyByIp failed: unknown result");
}

void CacheServiceClient::deleteDevicePolicyByDevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  send_deleteDevicePolicyByDevOnlyId(maxCode, minCode, devOnlyId);
  recv_deleteDevicePolicyByDevOnlyId(_return);
}

void CacheServiceClient::send_deleteDevicePolicyByDevOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteDevicePolicyByDevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteDevicePolicyByDevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteDevicePolicyByDevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteDevicePolicyByDevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteDevicePolicyByDevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteDevicePolicyByDevOnlyId failed: unknown result");
}

void CacheServiceClient::deleteDevicePolicyByIp( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& ip)
{
  send_deleteDevicePolicyByIp(maxCode, minCode, ip);
  recv_deleteDevicePolicyByIp(_return);
}

void CacheServiceClient::send_deleteDevicePolicyByIp(const std::string& maxCode, const std::string& minCode, const std::string& ip)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteDevicePolicyByIp", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteDevicePolicyByIp_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.ip = &ip;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteDevicePolicyByIp( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteDevicePolicyByIp") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteDevicePolicyByIp_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteDevicePolicyByIp failed: unknown result");
}

void CacheServiceClient::batchSaveDevicePolicy( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::vector<std::map<std::string, std::string> > & devicePolicyList)
{
  send_batchSaveDevicePolicy(maxCode, minCode, devicePolicyList);
  recv_batchSaveDevicePolicy(_return);
}

void CacheServiceClient::send_batchSaveDevicePolicy(const std::string& maxCode, const std::string& minCode, const std::vector<std::map<std::string, std::string> > & devicePolicyList)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("batchSaveDevicePolicy", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_batchSaveDevicePolicy_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devicePolicyList = &devicePolicyList;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_batchSaveDevicePolicy( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("batchSaveDevicePolicy") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_batchSaveDevicePolicy_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "batchSaveDevicePolicy failed: unknown result");
}

void CacheServiceClient::saveUser( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::UserCache& userCache)
{
  send_saveUser(maxCode, minCode, userCache);
  recv_saveUser(_return);
}

void CacheServiceClient::send_saveUser(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::UserCache& userCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveUser", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveUser_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userCache = &userCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveUser( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveUser") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveUser_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveUser failed: unknown result");
}

void CacheServiceClient::updateUser( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::UserCache& userCache)
{
  send_updateUser(maxCode, minCode, userCache);
  recv_updateUser(_return);
}

void CacheServiceClient::send_updateUser(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::UserCache& userCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateUser", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateUser_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userCache = &userCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateUser( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateUser") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateUser_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateUser failed: unknown result");
}

void CacheServiceClient::updateUserByField( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId, const std::map<std::string, std::string> & fieldValueMap)
{
  send_updateUserByField(maxCode, minCode, userOnlyId, fieldValueMap);
  recv_updateUserByField(_return);
}

void CacheServiceClient::send_updateUserByField(const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId, const std::map<std::string, std::string> & fieldValueMap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateUserByField", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateUserByField_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userOnlyId = &userOnlyId;
  args.fieldValueMap = &fieldValueMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateUserByField( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateUserByField") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateUserByField_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateUserByField failed: unknown result");
}

void CacheServiceClient::queryUserByUserOnlyId( ::com::vrv::cems::service::base::bean::cache::UserCache& _return, const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId)
{
  send_queryUserByUserOnlyId(maxCode, minCode, userOnlyId);
  recv_queryUserByUserOnlyId(_return);
}

void CacheServiceClient::send_queryUserByUserOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryUserByUserOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryUserByUserOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userOnlyId = &userOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryUserByUserOnlyId( ::com::vrv::cems::service::base::bean::cache::UserCache& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryUserByUserOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryUserByUserOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryUserByUserOnlyId failed: unknown result");
}

void CacheServiceClient::deleteUserByUserOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId)
{
  send_deleteUserByUserOnlyId(maxCode, minCode, userOnlyId);
  recv_deleteUserByUserOnlyId(_return);
}

void CacheServiceClient::send_deleteUserByUserOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteUserByUserOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteUserByUserOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userOnlyId = &userOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteUserByUserOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteUserByUserOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteUserByUserOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteUserByUserOnlyId failed: unknown result");
}

void CacheServiceClient::batchSaveUser( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::vector< ::com::vrv::cems::service::base::bean::cache::UserCache> & userCacheList)
{
  send_batchSaveUser(maxCode, minCode, userCacheList);
  recv_batchSaveUser(_return);
}

void CacheServiceClient::send_batchSaveUser(const std::string& maxCode, const std::string& minCode, const std::vector< ::com::vrv::cems::service::base::bean::cache::UserCache> & userCacheList)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("batchSaveUser", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_batchSaveUser_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userCacheList = &userCacheList;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_batchSaveUser( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("batchSaveUser") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_batchSaveUser_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "batchSaveUser failed: unknown result");
}

void CacheServiceClient::saveUserOnline( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::UserOnlineCache& userOnlineCache)
{
  send_saveUserOnline(maxCode, minCode, userOnlineCache);
  recv_saveUserOnline(_return);
}

void CacheServiceClient::send_saveUserOnline(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::UserOnlineCache& userOnlineCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveUserOnline", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveUserOnline_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userOnlineCache = &userOnlineCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveUserOnline( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveUserOnline") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveUserOnline_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveUserOnline failed: unknown result");
}

void CacheServiceClient::updateUserOnline( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::UserOnlineCache& userOnlineCache)
{
  send_updateUserOnline(maxCode, minCode, userOnlineCache);
  recv_updateUserOnline(_return);
}

void CacheServiceClient::send_updateUserOnline(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::UserOnlineCache& userOnlineCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateUserOnline", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateUserOnline_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userOnlineCache = &userOnlineCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateUserOnline( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateUserOnline") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateUserOnline_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateUserOnline failed: unknown result");
}

void CacheServiceClient::updateUserOnlineByField( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& userDevId, const std::map<std::string, std::string> & fieldValueMap)
{
  send_updateUserOnlineByField(maxCode, minCode, userDevId, fieldValueMap);
  recv_updateUserOnlineByField(_return);
}

void CacheServiceClient::send_updateUserOnlineByField(const std::string& maxCode, const std::string& minCode, const std::string& userDevId, const std::map<std::string, std::string> & fieldValueMap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateUserOnlineByField", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateUserOnlineByField_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userDevId = &userDevId;
  args.fieldValueMap = &fieldValueMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateUserOnlineByField( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateUserOnlineByField") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateUserOnlineByField_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateUserOnlineByField failed: unknown result");
}

void CacheServiceClient::queryUserOnlineByUserDevId( ::com::vrv::cems::service::base::bean::cache::UserOnlineCache& _return, const std::string& maxCode, const std::string& minCode, const std::string& userDevId)
{
  send_queryUserOnlineByUserDevId(maxCode, minCode, userDevId);
  recv_queryUserOnlineByUserDevId(_return);
}

void CacheServiceClient::send_queryUserOnlineByUserDevId(const std::string& maxCode, const std::string& minCode, const std::string& userDevId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryUserOnlineByUserDevId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryUserOnlineByUserDevId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userDevId = &userDevId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryUserOnlineByUserDevId( ::com::vrv::cems::service::base::bean::cache::UserOnlineCache& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryUserOnlineByUserDevId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryUserOnlineByUserDevId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryUserOnlineByUserDevId failed: unknown result");
}

void CacheServiceClient::deleteUserOnlineByUserDevId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& userDevId)
{
  send_deleteUserOnlineByUserDevId(maxCode, minCode, userDevId);
  recv_deleteUserOnlineByUserDevId(_return);
}

void CacheServiceClient::send_deleteUserOnlineByUserDevId(const std::string& maxCode, const std::string& minCode, const std::string& userDevId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteUserOnlineByUserDevId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteUserOnlineByUserDevId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userDevId = &userDevId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteUserOnlineByUserDevId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteUserOnlineByUserDevId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteUserOnlineByUserDevId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteUserOnlineByUserDevId failed: unknown result");
}

void CacheServiceClient::queryAllUserOnlineDevice(std::map<std::string, std::set<std::string> > & _return, const std::string& maxCode, const std::string& minCode)
{
  send_queryAllUserOnlineDevice(maxCode, minCode);
  recv_queryAllUserOnlineDevice(_return);
}

void CacheServiceClient::send_queryAllUserOnlineDevice(const std::string& maxCode, const std::string& minCode)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryAllUserOnlineDevice", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryAllUserOnlineDevice_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryAllUserOnlineDevice(std::map<std::string, std::set<std::string> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryAllUserOnlineDevice") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryAllUserOnlineDevice_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryAllUserOnlineDevice failed: unknown result");
}

void CacheServiceClient::saveUserPolicy( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::UserPolicyCache& userPolicyCache)
{
  send_saveUserPolicy(maxCode, minCode, userPolicyCache);
  recv_saveUserPolicy(_return);
}

void CacheServiceClient::send_saveUserPolicy(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::UserPolicyCache& userPolicyCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveUserPolicy", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveUserPolicy_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userPolicyCache = &userPolicyCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveUserPolicy( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveUserPolicy") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveUserPolicy_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveUserPolicy failed: unknown result");
}

void CacheServiceClient::updateUserPolicy( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::UserPolicyCache& userPolicyCache)
{
  send_updateUserPolicy(maxCode, minCode, userPolicyCache);
  recv_updateUserPolicy(_return);
}

void CacheServiceClient::send_updateUserPolicy(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::UserPolicyCache& userPolicyCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateUserPolicy", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateUserPolicy_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userPolicyCache = &userPolicyCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateUserPolicy( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateUserPolicy") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateUserPolicy_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateUserPolicy failed: unknown result");
}

void CacheServiceClient::queryUserPolicyByUserOnlyId( ::com::vrv::cems::service::base::bean::cache::UserPolicyCache& _return, const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId)
{
  send_queryUserPolicyByUserOnlyId(maxCode, minCode, userOnlyId);
  recv_queryUserPolicyByUserOnlyId(_return);
}

void CacheServiceClient::send_queryUserPolicyByUserOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryUserPolicyByUserOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryUserPolicyByUserOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userOnlyId = &userOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryUserPolicyByUserOnlyId( ::com::vrv::cems::service::base::bean::cache::UserPolicyCache& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryUserPolicyByUserOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryUserPolicyByUserOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryUserPolicyByUserOnlyId failed: unknown result");
}

void CacheServiceClient::deleteUserPolicyByUserOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId)
{
  send_deleteUserPolicyByUserOnlyId(maxCode, minCode, userOnlyId);
  recv_deleteUserPolicyByUserOnlyId(_return);
}

void CacheServiceClient::send_deleteUserPolicyByUserOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteUserPolicyByUserOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteUserPolicyByUserOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userOnlyId = &userOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteUserPolicyByUserOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteUserPolicyByUserOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteUserPolicyByUserOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteUserPolicyByUserOnlyId failed: unknown result");
}

void CacheServiceClient::batchSaveUserPolicy( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::vector<std::map<std::string, std::string> > & userPolicyist)
{
  send_batchSaveUserPolicy(maxCode, minCode, userPolicyist);
  recv_batchSaveUserPolicy(_return);
}

void CacheServiceClient::send_batchSaveUserPolicy(const std::string& maxCode, const std::string& minCode, const std::vector<std::map<std::string, std::string> > & userPolicyist)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("batchSaveUserPolicy", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_batchSaveUserPolicy_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userPolicyist = &userPolicyist;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_batchSaveUserPolicy( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("batchSaveUserPolicy") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_batchSaveUserPolicy_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "batchSaveUserPolicy failed: unknown result");
}

void CacheServiceClient::saveProductCInstallPack( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::CInstallPackCache& cInstallPackCache)
{
  send_saveProductCInstallPack(maxCode, minCode, cInstallPackCache);
  recv_saveProductCInstallPack(_return);
}

void CacheServiceClient::send_saveProductCInstallPack(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::CInstallPackCache& cInstallPackCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveProductCInstallPack", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveProductCInstallPack_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.cInstallPackCache = &cInstallPackCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveProductCInstallPack( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveProductCInstallPack") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveProductCInstallPack_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveProductCInstallPack failed: unknown result");
}

void CacheServiceClient::updateProductCInstallPack( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::CInstallPackCache& cInstallPackCache)
{
  send_updateProductCInstallPack(maxCode, minCode, cInstallPackCache);
  recv_updateProductCInstallPack(_return);
}

void CacheServiceClient::send_updateProductCInstallPack(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::CInstallPackCache& cInstallPackCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateProductCInstallPack", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateProductCInstallPack_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.cInstallPackCache = &cInstallPackCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateProductCInstallPack( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateProductCInstallPack") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateProductCInstallPack_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateProductCInstallPack failed: unknown result");
}

void CacheServiceClient::updateProductCInstallPackByField( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& cInstallPackId, const std::map<std::string, std::string> & fieldValueMap)
{
  send_updateProductCInstallPackByField(maxCode, minCode, cInstallPackId, fieldValueMap);
  recv_updateProductCInstallPackByField(_return);
}

void CacheServiceClient::send_updateProductCInstallPackByField(const std::string& maxCode, const std::string& minCode, const std::string& cInstallPackId, const std::map<std::string, std::string> & fieldValueMap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateProductCInstallPackByField", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateProductCInstallPackByField_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.cInstallPackId = &cInstallPackId;
  args.fieldValueMap = &fieldValueMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateProductCInstallPackByField( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateProductCInstallPackByField") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateProductCInstallPackByField_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateProductCInstallPackByField failed: unknown result");
}

void CacheServiceClient::queryProductCInstallPackById( ::com::vrv::cems::service::base::bean::cache::CInstallPackCache& _return, const std::string& maxCode, const std::string& minCode, const std::string& cInstallPackId)
{
  send_queryProductCInstallPackById(maxCode, minCode, cInstallPackId);
  recv_queryProductCInstallPackById(_return);
}

void CacheServiceClient::send_queryProductCInstallPackById(const std::string& maxCode, const std::string& minCode, const std::string& cInstallPackId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryProductCInstallPackById", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryProductCInstallPackById_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.cInstallPackId = &cInstallPackId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryProductCInstallPackById( ::com::vrv::cems::service::base::bean::cache::CInstallPackCache& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryProductCInstallPackById") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryProductCInstallPackById_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryProductCInstallPackById failed: unknown result");
}

void CacheServiceClient::deleteProductCInstallPackById( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& cInstallPackId)
{
  send_deleteProductCInstallPackById(maxCode, minCode, cInstallPackId);
  recv_deleteProductCInstallPackById(_return);
}

void CacheServiceClient::send_deleteProductCInstallPackById(const std::string& maxCode, const std::string& minCode, const std::string& cInstallPackId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteProductCInstallPackById", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteProductCInstallPackById_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.cInstallPackId = &cInstallPackId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteProductCInstallPackById( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteProductCInstallPackById") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteProductCInstallPackById_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteProductCInstallPackById failed: unknown result");
}

void CacheServiceClient::savePolicy( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::PolicyCache& policyCache)
{
  send_savePolicy(maxCode, minCode, policyCache);
  recv_savePolicy(_return);
}

void CacheServiceClient::send_savePolicy(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::PolicyCache& policyCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("savePolicy", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_savePolicy_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.policyCache = &policyCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_savePolicy( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("savePolicy") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_savePolicy_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "savePolicy failed: unknown result");
}

void CacheServiceClient::updatePolicy( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::PolicyCache& policyCache)
{
  send_updatePolicy(maxCode, minCode, policyCache);
  recv_updatePolicy(_return);
}

void CacheServiceClient::send_updatePolicy(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::PolicyCache& policyCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updatePolicy", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updatePolicy_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.policyCache = &policyCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updatePolicy( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updatePolicy") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updatePolicy_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updatePolicy failed: unknown result");
}

void CacheServiceClient::updatePolicyByField( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& policyId, const std::map<std::string, std::string> & fieldValueMap)
{
  send_updatePolicyByField(maxCode, minCode, policyId, fieldValueMap);
  recv_updatePolicyByField(_return);
}

void CacheServiceClient::send_updatePolicyByField(const std::string& maxCode, const std::string& minCode, const std::string& policyId, const std::map<std::string, std::string> & fieldValueMap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updatePolicyByField", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updatePolicyByField_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.policyId = &policyId;
  args.fieldValueMap = &fieldValueMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updatePolicyByField( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updatePolicyByField") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updatePolicyByField_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updatePolicyByField failed: unknown result");
}

void CacheServiceClient::queryPolicyByPolicyId( ::com::vrv::cems::service::base::bean::cache::PolicyCache& _return, const std::string& maxCode, const std::string& minCode, const std::string& policyId)
{
  send_queryPolicyByPolicyId(maxCode, minCode, policyId);
  recv_queryPolicyByPolicyId(_return);
}

void CacheServiceClient::send_queryPolicyByPolicyId(const std::string& maxCode, const std::string& minCode, const std::string& policyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryPolicyByPolicyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryPolicyByPolicyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.policyId = &policyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryPolicyByPolicyId( ::com::vrv::cems::service::base::bean::cache::PolicyCache& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryPolicyByPolicyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryPolicyByPolicyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryPolicyByPolicyId failed: unknown result");
}

void CacheServiceClient::deletePolicyByPolicyId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& policyId)
{
  send_deletePolicyByPolicyId(maxCode, minCode, policyId);
  recv_deletePolicyByPolicyId(_return);
}

void CacheServiceClient::send_deletePolicyByPolicyId(const std::string& maxCode, const std::string& minCode, const std::string& policyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deletePolicyByPolicyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deletePolicyByPolicyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.policyId = &policyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deletePolicyByPolicyId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deletePolicyByPolicyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deletePolicyByPolicyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deletePolicyByPolicyId failed: unknown result");
}

void CacheServiceClient::saveIPMAC2DevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& ip, const std::string& mac, const std::string& devOnlyId)
{
  send_saveIPMAC2DevOnlyId(maxCode, minCode, ip, mac, devOnlyId);
  recv_saveIPMAC2DevOnlyId(_return);
}

void CacheServiceClient::send_saveIPMAC2DevOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& ip, const std::string& mac, const std::string& devOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveIPMAC2DevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveIPMAC2DevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.ip = &ip;
  args.mac = &mac;
  args.devOnlyId = &devOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveIPMAC2DevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveIPMAC2DevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveIPMAC2DevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveIPMAC2DevOnlyId failed: unknown result");
}

void CacheServiceClient::updateIPMAC2DevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& ip, const std::string& mac, const std::string& devOnlyId)
{
  send_updateIPMAC2DevOnlyId(maxCode, minCode, ip, mac, devOnlyId);
  recv_updateIPMAC2DevOnlyId(_return);
}

void CacheServiceClient::send_updateIPMAC2DevOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& ip, const std::string& mac, const std::string& devOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateIPMAC2DevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateIPMAC2DevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.ip = &ip;
  args.mac = &mac;
  args.devOnlyId = &devOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateIPMAC2DevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateIPMAC2DevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateIPMAC2DevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateIPMAC2DevOnlyId failed: unknown result");
}

void CacheServiceClient::queryIPMAC2DevOnlyId(std::string& _return, const std::string& maxCode, const std::string& minCode, const std::string& ip, const std::string& mac)
{
  send_queryIPMAC2DevOnlyId(maxCode, minCode, ip, mac);
  recv_queryIPMAC2DevOnlyId(_return);
}

void CacheServiceClient::send_queryIPMAC2DevOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& ip, const std::string& mac)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryIPMAC2DevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryIPMAC2DevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.ip = &ip;
  args.mac = &mac;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryIPMAC2DevOnlyId(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryIPMAC2DevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryIPMAC2DevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryIPMAC2DevOnlyId failed: unknown result");
}

void CacheServiceClient::deleteIPMAC2DevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& ip, const std::string& mac)
{
  send_deleteIPMAC2DevOnlyId(maxCode, minCode, ip, mac);
  recv_deleteIPMAC2DevOnlyId(_return);
}

void CacheServiceClient::send_deleteIPMAC2DevOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& ip, const std::string& mac)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteIPMAC2DevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteIPMAC2DevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.ip = &ip;
  args.mac = &mac;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteIPMAC2DevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteIPMAC2DevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteIPMAC2DevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteIPMAC2DevOnlyId failed: unknown result");
}

void CacheServiceClient::saveIP2DevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& ip, const std::string& devOnlyId)
{
  send_saveIP2DevOnlyId(maxCode, minCode, ip, devOnlyId);
  recv_saveIP2DevOnlyId(_return);
}

void CacheServiceClient::send_saveIP2DevOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& ip, const std::string& devOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveIP2DevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveIP2DevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.ip = &ip;
  args.devOnlyId = &devOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveIP2DevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveIP2DevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveIP2DevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveIP2DevOnlyId failed: unknown result");
}

void CacheServiceClient::updateIP2DevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& ip, const std::string& devOnlyId)
{
  send_updateIP2DevOnlyId(maxCode, minCode, ip, devOnlyId);
  recv_updateIP2DevOnlyId(_return);
}

void CacheServiceClient::send_updateIP2DevOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& ip, const std::string& devOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateIP2DevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateIP2DevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.ip = &ip;
  args.devOnlyId = &devOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateIP2DevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateIP2DevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateIP2DevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateIP2DevOnlyId failed: unknown result");
}

void CacheServiceClient::queryIP2DevOnlyId(std::string& _return, const std::string& maxCode, const std::string& minCode, const std::string& ip)
{
  send_queryIP2DevOnlyId(maxCode, minCode, ip);
  recv_queryIP2DevOnlyId(_return);
}

void CacheServiceClient::send_queryIP2DevOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& ip)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryIP2DevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryIP2DevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.ip = &ip;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryIP2DevOnlyId(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryIP2DevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryIP2DevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryIP2DevOnlyId failed: unknown result");
}

void CacheServiceClient::deleteIP2DevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& ip)
{
  send_deleteIP2DevOnlyId(maxCode, minCode, ip);
  recv_deleteIP2DevOnlyId(_return);
}

void CacheServiceClient::send_deleteIP2DevOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& ip)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteIP2DevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteIP2DevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.ip = &ip;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteIP2DevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteIP2DevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteIP2DevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteIP2DevOnlyId failed: unknown result");
}

void CacheServiceClient::saveProductCUpgradePack( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::CUpgradePackCache& cUpgradePackCache)
{
  send_saveProductCUpgradePack(maxCode, minCode, cUpgradePackCache);
  recv_saveProductCUpgradePack(_return);
}

void CacheServiceClient::send_saveProductCUpgradePack(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::CUpgradePackCache& cUpgradePackCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveProductCUpgradePack", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveProductCUpgradePack_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.cUpgradePackCache = &cUpgradePackCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveProductCUpgradePack( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveProductCUpgradePack") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveProductCUpgradePack_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveProductCUpgradePack failed: unknown result");
}

void CacheServiceClient::updateProductCUpgradePack( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::CUpgradePackCache& cUpgradePackCache)
{
  send_updateProductCUpgradePack(maxCode, minCode, cUpgradePackCache);
  recv_updateProductCUpgradePack(_return);
}

void CacheServiceClient::send_updateProductCUpgradePack(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::CUpgradePackCache& cUpgradePackCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateProductCUpgradePack", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateProductCUpgradePack_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.cUpgradePackCache = &cUpgradePackCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateProductCUpgradePack( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateProductCUpgradePack") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateProductCUpgradePack_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateProductCUpgradePack failed: unknown result");
}

void CacheServiceClient::updateProductCUpgradePackByField( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& cUpgradePackId, const std::map<std::string, std::string> & fieldValueMap)
{
  send_updateProductCUpgradePackByField(maxCode, minCode, cUpgradePackId, fieldValueMap);
  recv_updateProductCUpgradePackByField(_return);
}

void CacheServiceClient::send_updateProductCUpgradePackByField(const std::string& maxCode, const std::string& minCode, const std::string& cUpgradePackId, const std::map<std::string, std::string> & fieldValueMap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateProductCUpgradePackByField", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateProductCUpgradePackByField_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.cUpgradePackId = &cUpgradePackId;
  args.fieldValueMap = &fieldValueMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateProductCUpgradePackByField( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateProductCUpgradePackByField") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateProductCUpgradePackByField_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateProductCUpgradePackByField failed: unknown result");
}

void CacheServiceClient::queryProductCUpgradePackById( ::com::vrv::cems::service::base::bean::cache::CUpgradePackCache& _return, const std::string& maxCode, const std::string& minCode, const std::string& cUpgradePackId)
{
  send_queryProductCUpgradePackById(maxCode, minCode, cUpgradePackId);
  recv_queryProductCUpgradePackById(_return);
}

void CacheServiceClient::send_queryProductCUpgradePackById(const std::string& maxCode, const std::string& minCode, const std::string& cUpgradePackId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryProductCUpgradePackById", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryProductCUpgradePackById_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.cUpgradePackId = &cUpgradePackId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryProductCUpgradePackById( ::com::vrv::cems::service::base::bean::cache::CUpgradePackCache& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryProductCUpgradePackById") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryProductCUpgradePackById_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryProductCUpgradePackById failed: unknown result");
}

void CacheServiceClient::deleteProductCUpgradePackById( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& cUpgradePackId)
{
  send_deleteProductCUpgradePackById(maxCode, minCode, cUpgradePackId);
  recv_deleteProductCUpgradePackById(_return);
}

void CacheServiceClient::send_deleteProductCUpgradePackById(const std::string& maxCode, const std::string& minCode, const std::string& cUpgradePackId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteProductCUpgradePackById", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteProductCUpgradePackById_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.cUpgradePackId = &cUpgradePackId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteProductCUpgradePackById( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteProductCUpgradePackById") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteProductCUpgradePackById_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteProductCUpgradePackById failed: unknown result");
}

void CacheServiceClient::saveAccount2UserOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& account, const std::string& userOnlyId)
{
  send_saveAccount2UserOnlyId(maxCode, minCode, account, userOnlyId);
  recv_saveAccount2UserOnlyId(_return);
}

void CacheServiceClient::send_saveAccount2UserOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& account, const std::string& userOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveAccount2UserOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveAccount2UserOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.account = &account;
  args.userOnlyId = &userOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveAccount2UserOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveAccount2UserOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveAccount2UserOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveAccount2UserOnlyId failed: unknown result");
}

void CacheServiceClient::updateAccount2UserOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& account, const std::string& userOnlyId)
{
  send_updateAccount2UserOnlyId(maxCode, minCode, account, userOnlyId);
  recv_updateAccount2UserOnlyId(_return);
}

void CacheServiceClient::send_updateAccount2UserOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& account, const std::string& userOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateAccount2UserOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateAccount2UserOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.account = &account;
  args.userOnlyId = &userOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateAccount2UserOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateAccount2UserOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateAccount2UserOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateAccount2UserOnlyId failed: unknown result");
}

void CacheServiceClient::queryAccount2UserOnlyId(std::string& _return, const std::string& maxCode, const std::string& minCode, const std::string& account)
{
  send_queryAccount2UserOnlyId(maxCode, minCode, account);
  recv_queryAccount2UserOnlyId(_return);
}

void CacheServiceClient::send_queryAccount2UserOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& account)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryAccount2UserOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryAccount2UserOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.account = &account;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryAccount2UserOnlyId(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryAccount2UserOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryAccount2UserOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryAccount2UserOnlyId failed: unknown result");
}

void CacheServiceClient::deleteAccount2UserOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& account)
{
  send_deleteAccount2UserOnlyId(maxCode, minCode, account);
  recv_deleteAccount2UserOnlyId(_return);
}

void CacheServiceClient::send_deleteAccount2UserOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& account)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteAccount2UserOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteAccount2UserOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.account = &account;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteAccount2UserOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteAccount2UserOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteAccount2UserOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteAccount2UserOnlyId failed: unknown result");
}

void CacheServiceClient::batchSaveAccount2UserOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::vector< ::com::vrv::cems::service::base::bean::cache::UserCache> & userCacheList)
{
  send_batchSaveAccount2UserOnlyId(maxCode, minCode, userCacheList);
  recv_batchSaveAccount2UserOnlyId(_return);
}

void CacheServiceClient::send_batchSaveAccount2UserOnlyId(const std::string& maxCode, const std::string& minCode, const std::vector< ::com::vrv::cems::service::base::bean::cache::UserCache> & userCacheList)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("batchSaveAccount2UserOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_batchSaveAccount2UserOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userCacheList = &userCacheList;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_batchSaveAccount2UserOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("batchSaveAccount2UserOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_batchSaveAccount2UserOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "batchSaveAccount2UserOnlyId failed: unknown result");
}

void CacheServiceClient::savePtp( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& uuid, const std::string& ptpResult)
{
  send_savePtp(maxCode, minCode, uuid, ptpResult);
  recv_savePtp(_return);
}

void CacheServiceClient::send_savePtp(const std::string& maxCode, const std::string& minCode, const std::string& uuid, const std::string& ptpResult)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("savePtp", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_savePtp_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.uuid = &uuid;
  args.ptpResult = &ptpResult;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_savePtp( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("savePtp") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_savePtp_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "savePtp failed: unknown result");
}

void CacheServiceClient::updatePtp( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& uuid, const std::string& ptpResult)
{
  send_updatePtp(maxCode, minCode, uuid, ptpResult);
  recv_updatePtp(_return);
}

void CacheServiceClient::send_updatePtp(const std::string& maxCode, const std::string& minCode, const std::string& uuid, const std::string& ptpResult)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updatePtp", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updatePtp_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.uuid = &uuid;
  args.ptpResult = &ptpResult;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updatePtp( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updatePtp") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updatePtp_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updatePtp failed: unknown result");
}

void CacheServiceClient::queryPtp(std::string& _return, const std::string& maxCode, const std::string& minCode, const std::string& uuid)
{
  send_queryPtp(maxCode, minCode, uuid);
  recv_queryPtp(_return);
}

void CacheServiceClient::send_queryPtp(const std::string& maxCode, const std::string& minCode, const std::string& uuid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryPtp", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryPtp_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.uuid = &uuid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryPtp(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryPtp") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryPtp_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryPtp failed: unknown result");
}

void CacheServiceClient::deletePtp( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& uuid)
{
  send_deletePtp(maxCode, minCode, uuid);
  recv_deletePtp(_return);
}

void CacheServiceClient::send_deletePtp(const std::string& maxCode, const std::string& minCode, const std::string& uuid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deletePtp", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deletePtp_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.uuid = &uuid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deletePtp( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deletePtp") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deletePtp_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deletePtp failed: unknown result");
}

void CacheServiceClient::saveSensitive( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::SensitiveCache& sensitiveCache)
{
  send_saveSensitive(maxCode, minCode, sensitiveCache);
  recv_saveSensitive(_return);
}

void CacheServiceClient::send_saveSensitive(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::SensitiveCache& sensitiveCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveSensitive", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveSensitive_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.sensitiveCache = &sensitiveCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveSensitive( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveSensitive") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveSensitive_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveSensitive failed: unknown result");
}

void CacheServiceClient::updateSensitive( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::SensitiveCache& sensitiveCache)
{
  send_updateSensitive(maxCode, minCode, sensitiveCache);
  recv_updateSensitive(_return);
}

void CacheServiceClient::send_updateSensitive(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::SensitiveCache& sensitiveCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateSensitive", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateSensitive_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.sensitiveCache = &sensitiveCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateSensitive( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateSensitive") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateSensitive_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateSensitive failed: unknown result");
}

void CacheServiceClient::querySensitive( ::com::vrv::cems::service::base::bean::cache::SensitiveCache& _return, const std::string& maxCode, const std::string& minCode, const std::string& name)
{
  send_querySensitive(maxCode, minCode, name);
  recv_querySensitive(_return);
}

void CacheServiceClient::send_querySensitive(const std::string& maxCode, const std::string& minCode, const std::string& name)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("querySensitive", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_querySensitive_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.name = &name;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_querySensitive( ::com::vrv::cems::service::base::bean::cache::SensitiveCache& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("querySensitive") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_querySensitive_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "querySensitive failed: unknown result");
}

void CacheServiceClient::querySensitiveByField(std::string& _return, const std::string& maxCode, const std::string& minCode, const std::string& name, const std::string& fieldKey)
{
  send_querySensitiveByField(maxCode, minCode, name, fieldKey);
  recv_querySensitiveByField(_return);
}

void CacheServiceClient::send_querySensitiveByField(const std::string& maxCode, const std::string& minCode, const std::string& name, const std::string& fieldKey)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("querySensitiveByField", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_querySensitiveByField_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.name = &name;
  args.fieldKey = &fieldKey;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_querySensitiveByField(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("querySensitiveByField") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_querySensitiveByField_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "querySensitiveByField failed: unknown result");
}

void CacheServiceClient::deleteSensitive( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& name)
{
  send_deleteSensitive(maxCode, minCode, name);
  recv_deleteSensitive(_return);
}

void CacheServiceClient::send_deleteSensitive(const std::string& maxCode, const std::string& minCode, const std::string& name)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteSensitive", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteSensitive_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.name = &name;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteSensitive( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteSensitive") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteSensitive_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteSensitive failed: unknown result");
}

void CacheServiceClient::saveDeviceMsgDigest( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::map<std::string, std::vector<std::string> > & fieldValueMap)
{
  send_saveDeviceMsgDigest(maxCode, minCode, devOnlyId, fieldValueMap);
  recv_saveDeviceMsgDigest(_return);
}

void CacheServiceClient::send_saveDeviceMsgDigest(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::map<std::string, std::vector<std::string> > & fieldValueMap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveDeviceMsgDigest", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveDeviceMsgDigest_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.fieldValueMap = &fieldValueMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveDeviceMsgDigest( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveDeviceMsgDigest") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveDeviceMsgDigest_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveDeviceMsgDigest failed: unknown result");
}

void CacheServiceClient::saveDeviceMsgDigestWithDevOnlyIdAndMsgType( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::string& msgType, const std::vector<std::string> & msgIdList)
{
  send_saveDeviceMsgDigestWithDevOnlyIdAndMsgType(maxCode, minCode, devOnlyId, msgType, msgIdList);
  recv_saveDeviceMsgDigestWithDevOnlyIdAndMsgType(_return);
}

void CacheServiceClient::send_saveDeviceMsgDigestWithDevOnlyIdAndMsgType(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::string& msgType, const std::vector<std::string> & msgIdList)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveDeviceMsgDigestWithDevOnlyIdAndMsgType", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgType_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.msgType = &msgType;
  args.msgIdList = &msgIdList;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveDeviceMsgDigestWithDevOnlyIdAndMsgType( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveDeviceMsgDigestWithDevOnlyIdAndMsgType") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgType_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveDeviceMsgDigestWithDevOnlyIdAndMsgType failed: unknown result");
}

void CacheServiceClient::saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::string& msgType, const std::string& msgId)
{
  send_saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId(maxCode, minCode, devOnlyId, msgType, msgId);
  recv_saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId(_return);
}

void CacheServiceClient::send_saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::string& msgType, const std::string& msgId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.msgType = &msgType;
  args.msgId = &msgId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId failed: unknown result");
}

void CacheServiceClient::deleteDeviceMsgDigestByDevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  send_deleteDeviceMsgDigestByDevOnlyId(maxCode, minCode, devOnlyId);
  recv_deleteDeviceMsgDigestByDevOnlyId(_return);
}

void CacheServiceClient::send_deleteDeviceMsgDigestByDevOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteDeviceMsgDigestByDevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteDeviceMsgDigestByDevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteDeviceMsgDigestByDevOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteDeviceMsgDigestByDevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteDeviceMsgDigestByDevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteDeviceMsgDigestByDevOnlyId failed: unknown result");
}

void CacheServiceClient::deleteDeviceMsgDigestByDevOnlyIdAndMsgType( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::string& msgType)
{
  send_deleteDeviceMsgDigestByDevOnlyIdAndMsgType(maxCode, minCode, devOnlyId, msgType);
  recv_deleteDeviceMsgDigestByDevOnlyIdAndMsgType(_return);
}

void CacheServiceClient::send_deleteDeviceMsgDigestByDevOnlyIdAndMsgType(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::string& msgType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteDeviceMsgDigestByDevOnlyIdAndMsgType", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgType_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.msgType = &msgType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteDeviceMsgDigestByDevOnlyIdAndMsgType( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteDeviceMsgDigestByDevOnlyIdAndMsgType") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgType_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteDeviceMsgDigestByDevOnlyIdAndMsgType failed: unknown result");
}

void CacheServiceClient::deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::string& msgType, const std::string& msgId)
{
  send_deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId(maxCode, minCode, devOnlyId, msgType, msgId);
  recv_deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId(_return);
}

void CacheServiceClient::send_deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::string& msgType, const std::string& msgId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.msgType = &msgType;
  args.msgId = &msgId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId failed: unknown result");
}

void CacheServiceClient::updateDeviceMsgDigest( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::string& msgType, const std::string& msgId)
{
  send_updateDeviceMsgDigest(maxCode, minCode, devOnlyId, msgType, msgId);
  recv_updateDeviceMsgDigest(_return);
}

void CacheServiceClient::send_updateDeviceMsgDigest(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::string& msgType, const std::string& msgId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateDeviceMsgDigest", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateDeviceMsgDigest_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.msgType = &msgType;
  args.msgId = &msgId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateDeviceMsgDigest( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateDeviceMsgDigest") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateDeviceMsgDigest_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateDeviceMsgDigest failed: unknown result");
}

void CacheServiceClient::queryDeviceMsgDigestByDevOnlyId(std::map<std::string, std::vector<std::string> > & _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  send_queryDeviceMsgDigestByDevOnlyId(maxCode, minCode, devOnlyId);
  recv_queryDeviceMsgDigestByDevOnlyId(_return);
}

void CacheServiceClient::send_queryDeviceMsgDigestByDevOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryDeviceMsgDigestByDevOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryDeviceMsgDigestByDevOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryDeviceMsgDigestByDevOnlyId(std::map<std::string, std::vector<std::string> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryDeviceMsgDigestByDevOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryDeviceMsgDigestByDevOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryDeviceMsgDigestByDevOnlyId failed: unknown result");
}

void CacheServiceClient::queryDeviceMsgDigestByDevIdAndMsgType(std::vector<std::string> & _return, const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::string& msgType)
{
  send_queryDeviceMsgDigestByDevIdAndMsgType(maxCode, minCode, devOnlyId, msgType);
  recv_queryDeviceMsgDigestByDevIdAndMsgType(_return);
}

void CacheServiceClient::send_queryDeviceMsgDigestByDevIdAndMsgType(const std::string& maxCode, const std::string& minCode, const std::string& devOnlyId, const std::string& msgType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryDeviceMsgDigestByDevIdAndMsgType", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryDeviceMsgDigestByDevIdAndMsgType_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.devOnlyId = &devOnlyId;
  args.msgType = &msgType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryDeviceMsgDigestByDevIdAndMsgType(std::vector<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryDeviceMsgDigestByDevIdAndMsgType") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryDeviceMsgDigestByDevIdAndMsgType_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryDeviceMsgDigestByDevIdAndMsgType failed: unknown result");
}

void CacheServiceClient::saveUserMsgDigest( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId, const std::map<std::string, std::vector<std::string> > & fieldValueMap)
{
  send_saveUserMsgDigest(maxCode, minCode, userOnlyId, fieldValueMap);
  recv_saveUserMsgDigest(_return);
}

void CacheServiceClient::send_saveUserMsgDigest(const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId, const std::map<std::string, std::vector<std::string> > & fieldValueMap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveUserMsgDigest", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveUserMsgDigest_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userOnlyId = &userOnlyId;
  args.fieldValueMap = &fieldValueMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveUserMsgDigest( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveUserMsgDigest") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveUserMsgDigest_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveUserMsgDigest failed: unknown result");
}

void CacheServiceClient::saveUserMsgDigestWithUserOnlyIdAndMsgType( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId, const std::string& msgType, const std::vector<std::string> & msgIdList)
{
  send_saveUserMsgDigestWithUserOnlyIdAndMsgType(maxCode, minCode, userOnlyId, msgType, msgIdList);
  recv_saveUserMsgDigestWithUserOnlyIdAndMsgType(_return);
}

void CacheServiceClient::send_saveUserMsgDigestWithUserOnlyIdAndMsgType(const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId, const std::string& msgType, const std::vector<std::string> & msgIdList)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveUserMsgDigestWithUserOnlyIdAndMsgType", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgType_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userOnlyId = &userOnlyId;
  args.msgType = &msgType;
  args.msgIdList = &msgIdList;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveUserMsgDigestWithUserOnlyIdAndMsgType( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveUserMsgDigestWithUserOnlyIdAndMsgType") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgType_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveUserMsgDigestWithUserOnlyIdAndMsgType failed: unknown result");
}

void CacheServiceClient::saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId, const std::string& msgType, const std::string& msgId)
{
  send_saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId(maxCode, minCode, userOnlyId, msgType, msgId);
  recv_saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId(_return);
}

void CacheServiceClient::send_saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId(const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId, const std::string& msgType, const std::string& msgId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userOnlyId = &userOnlyId;
  args.msgType = &msgType;
  args.msgId = &msgId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId failed: unknown result");
}

void CacheServiceClient::deleteUserMsgDigestByUserOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId)
{
  send_deleteUserMsgDigestByUserOnlyId(maxCode, minCode, userOnlyId);
  recv_deleteUserMsgDigestByUserOnlyId(_return);
}

void CacheServiceClient::send_deleteUserMsgDigestByUserOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteUserMsgDigestByUserOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteUserMsgDigestByUserOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userOnlyId = &userOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteUserMsgDigestByUserOnlyId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteUserMsgDigestByUserOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteUserMsgDigestByUserOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteUserMsgDigestByUserOnlyId failed: unknown result");
}

void CacheServiceClient::deleteUserMsgDigestByUserOnlyIdAndMsgType( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId, const std::string& msgType)
{
  send_deleteUserMsgDigestByUserOnlyIdAndMsgType(maxCode, minCode, userOnlyId, msgType);
  recv_deleteUserMsgDigestByUserOnlyIdAndMsgType(_return);
}

void CacheServiceClient::send_deleteUserMsgDigestByUserOnlyIdAndMsgType(const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId, const std::string& msgType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteUserMsgDigestByUserOnlyIdAndMsgType", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgType_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userOnlyId = &userOnlyId;
  args.msgType = &msgType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteUserMsgDigestByUserOnlyIdAndMsgType( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteUserMsgDigestByUserOnlyIdAndMsgType") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgType_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteUserMsgDigestByUserOnlyIdAndMsgType failed: unknown result");
}

void CacheServiceClient::deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId, const std::string& msgType, const std::string& msgId)
{
  send_deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId(maxCode, minCode, userOnlyId, msgType, msgId);
  recv_deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId(_return);
}

void CacheServiceClient::send_deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId(const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId, const std::string& msgType, const std::string& msgId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userOnlyId = &userOnlyId;
  args.msgType = &msgType;
  args.msgId = &msgId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId failed: unknown result");
}

void CacheServiceClient::updateUserMsgDigest( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId, const std::string& msgType, const std::string& msgId)
{
  send_updateUserMsgDigest(maxCode, minCode, userOnlyId, msgType, msgId);
  recv_updateUserMsgDigest(_return);
}

void CacheServiceClient::send_updateUserMsgDigest(const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId, const std::string& msgType, const std::string& msgId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateUserMsgDigest", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateUserMsgDigest_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userOnlyId = &userOnlyId;
  args.msgType = &msgType;
  args.msgId = &msgId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateUserMsgDigest( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateUserMsgDigest") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateUserMsgDigest_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateUserMsgDigest failed: unknown result");
}

void CacheServiceClient::queryUserMsgDigestByUserOnlyId(std::map<std::string, std::vector<std::string> > & _return, const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId)
{
  send_queryUserMsgDigestByUserOnlyId(maxCode, minCode, userOnlyId);
  recv_queryUserMsgDigestByUserOnlyId(_return);
}

void CacheServiceClient::send_queryUserMsgDigestByUserOnlyId(const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryUserMsgDigestByUserOnlyId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryUserMsgDigestByUserOnlyId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userOnlyId = &userOnlyId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryUserMsgDigestByUserOnlyId(std::map<std::string, std::vector<std::string> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryUserMsgDigestByUserOnlyId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryUserMsgDigestByUserOnlyId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryUserMsgDigestByUserOnlyId failed: unknown result");
}

void CacheServiceClient::queryDeviceMsgDigestByUserOnlyIdAndMsgType(std::vector<std::string> & _return, const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId, const std::string& msgType)
{
  send_queryDeviceMsgDigestByUserOnlyIdAndMsgType(maxCode, minCode, userOnlyId, msgType);
  recv_queryDeviceMsgDigestByUserOnlyIdAndMsgType(_return);
}

void CacheServiceClient::send_queryDeviceMsgDigestByUserOnlyIdAndMsgType(const std::string& maxCode, const std::string& minCode, const std::string& userOnlyId, const std::string& msgType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryDeviceMsgDigestByUserOnlyIdAndMsgType", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryDeviceMsgDigestByUserOnlyIdAndMsgType_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.userOnlyId = &userOnlyId;
  args.msgType = &msgType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryDeviceMsgDigestByUserOnlyIdAndMsgType(std::vector<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryDeviceMsgDigestByUserOnlyIdAndMsgType") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryDeviceMsgDigestByUserOnlyIdAndMsgType_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryDeviceMsgDigestByUserOnlyIdAndMsgType failed: unknown result");
}

void CacheServiceClient::saveMsg( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::MsgCache& msgCache)
{
  send_saveMsg(maxCode, minCode, msgCache);
  recv_saveMsg(_return);
}

void CacheServiceClient::send_saveMsg(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::MsgCache& msgCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveMsg", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveMsg_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.msgCache = &msgCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveMsg( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveMsg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveMsg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveMsg failed: unknown result");
}

void CacheServiceClient::deleteMsg( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& msgId)
{
  send_deleteMsg(maxCode, minCode, msgId);
  recv_deleteMsg(_return);
}

void CacheServiceClient::send_deleteMsg(const std::string& maxCode, const std::string& minCode, const std::string& msgId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteMsg", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteMsg_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.msgId = &msgId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteMsg( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteMsg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteMsg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteMsg failed: unknown result");
}

void CacheServiceClient::queryMsg( ::com::vrv::cems::service::base::bean::cache::MsgCache& _return, const std::string& maxCode, const std::string& minCode, const std::string& msgId)
{
  send_queryMsg(maxCode, minCode, msgId);
  recv_queryMsg(_return);
}

void CacheServiceClient::send_queryMsg(const std::string& maxCode, const std::string& minCode, const std::string& msgId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryMsg", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryMsg_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.msgId = &msgId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryMsg( ::com::vrv::cems::service::base::bean::cache::MsgCache& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryMsg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryMsg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryMsg failed: unknown result");
}

void CacheServiceClient::saveToken( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::TokenCache& tokenCache)
{
  send_saveToken(maxCode, minCode, tokenCache);
  recv_saveToken(_return);
}

void CacheServiceClient::send_saveToken(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::TokenCache& tokenCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveToken", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveToken_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.tokenCache = &tokenCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveToken( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveToken") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveToken_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveToken failed: unknown result");
}

void CacheServiceClient::deleteTokenByAppId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& appId)
{
  send_deleteTokenByAppId(maxCode, minCode, appId);
  recv_deleteTokenByAppId(_return);
}

void CacheServiceClient::send_deleteTokenByAppId(const std::string& maxCode, const std::string& minCode, const std::string& appId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteTokenByAppId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteTokenByAppId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.appId = &appId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteTokenByAppId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteTokenByAppId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteTokenByAppId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteTokenByAppId failed: unknown result");
}

void CacheServiceClient::updateTokenByAppId( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::TokenCache& tokenCache)
{
  send_updateTokenByAppId(maxCode, minCode, tokenCache);
  recv_updateTokenByAppId(_return);
}

void CacheServiceClient::send_updateTokenByAppId(const std::string& maxCode, const std::string& minCode, const  ::com::vrv::cems::service::base::bean::cache::TokenCache& tokenCache)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateTokenByAppId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateTokenByAppId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.tokenCache = &tokenCache;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateTokenByAppId( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateTokenByAppId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateTokenByAppId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateTokenByAppId failed: unknown result");
}

void CacheServiceClient::queryTokenByAppId( ::com::vrv::cems::service::base::bean::cache::TokenCache& _return, const std::string& maxCode, const std::string& minCode, const std::string& appId)
{
  send_queryTokenByAppId(maxCode, minCode, appId);
  recv_queryTokenByAppId(_return);
}

void CacheServiceClient::send_queryTokenByAppId(const std::string& maxCode, const std::string& minCode, const std::string& appId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("queryTokenByAppId", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_queryTokenByAppId_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.appId = &appId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_queryTokenByAppId( ::com::vrv::cems::service::base::bean::cache::TokenCache& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("queryTokenByAppId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_queryTokenByAppId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "queryTokenByAppId failed: unknown result");
}

void CacheServiceClient::saveSession( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& sId, const std::map<std::string, std::string> & hashMap)
{
  send_saveSession(maxCode, minCode, sId, hashMap);
  recv_saveSession(_return);
}

void CacheServiceClient::send_saveSession(const std::string& maxCode, const std::string& minCode, const std::string& sId, const std::map<std::string, std::string> & hashMap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveSession", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveSession_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.sId = &sId;
  args.hashMap = &hashMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveSession( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveSession") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveSession_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveSession failed: unknown result");
}

void CacheServiceClient::saveSessionByDetail( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& sId, const std::string& key, const std::string& value)
{
  send_saveSessionByDetail(maxCode, minCode, sId, key, value);
  recv_saveSessionByDetail(_return);
}

void CacheServiceClient::send_saveSessionByDetail(const std::string& maxCode, const std::string& minCode, const std::string& sId, const std::string& key, const std::string& value)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("saveSessionByDetail", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_saveSessionByDetail_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.sId = &sId;
  args.key = &key;
  args.value = &value;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_saveSessionByDetail( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("saveSessionByDetail") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_saveSessionByDetail_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "saveSessionByDetail failed: unknown result");
}

void CacheServiceClient::deleteSession( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& sId)
{
  send_deleteSession(maxCode, minCode, sId);
  recv_deleteSession(_return);
}

void CacheServiceClient::send_deleteSession(const std::string& maxCode, const std::string& minCode, const std::string& sId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteSession", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteSession_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.sId = &sId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteSession( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteSession") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteSession_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteSession failed: unknown result");
}

void CacheServiceClient::deleteSessionByDetail( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& sId, const std::string& key)
{
  send_deleteSessionByDetail(maxCode, minCode, sId, key);
  recv_deleteSessionByDetail(_return);
}

void CacheServiceClient::send_deleteSessionByDetail(const std::string& maxCode, const std::string& minCode, const std::string& sId, const std::string& key)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteSessionByDetail", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_deleteSessionByDetail_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.sId = &sId;
  args.key = &key;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_deleteSessionByDetail( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteSessionByDetail") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_deleteSessionByDetail_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteSessionByDetail failed: unknown result");
}

void CacheServiceClient::updataSessionByDetail( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& sId, const std::string& key, const std::string& value)
{
  send_updataSessionByDetail(maxCode, minCode, sId, key, value);
  recv_updataSessionByDetail(_return);
}

void CacheServiceClient::send_updataSessionByDetail(const std::string& maxCode, const std::string& minCode, const std::string& sId, const std::string& key, const std::string& value)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updataSessionByDetail", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updataSessionByDetail_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.sId = &sId;
  args.key = &key;
  args.value = &value;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updataSessionByDetail( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updataSessionByDetail") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updataSessionByDetail_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updataSessionByDetail failed: unknown result");
}

void CacheServiceClient::updateSession( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& sId, const std::map<std::string, std::string> & hashMap)
{
  send_updateSession(maxCode, minCode, sId, hashMap);
  recv_updateSession(_return);
}

void CacheServiceClient::send_updateSession(const std::string& maxCode, const std::string& minCode, const std::string& sId, const std::map<std::string, std::string> & hashMap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("updateSession", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_updateSession_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.sId = &sId;
  args.hashMap = &hashMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_updateSession( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("updateSession") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_updateSession_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "updateSession failed: unknown result");
}

void CacheServiceClient::querySessionByDetail(std::string& _return, const std::string& maxCode, const std::string& minCode, const std::string& sId, const std::string& key)
{
  send_querySessionByDetail(maxCode, minCode, sId, key);
  recv_querySessionByDetail(_return);
}

void CacheServiceClient::send_querySessionByDetail(const std::string& maxCode, const std::string& minCode, const std::string& sId, const std::string& key)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("querySessionByDetail", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_querySessionByDetail_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.sId = &sId;
  args.key = &key;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_querySessionByDetail(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("querySessionByDetail") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_querySessionByDetail_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "querySessionByDetail failed: unknown result");
}

void CacheServiceClient::querySession(std::map<std::string, std::string> & _return, const std::string& maxCode, const std::string& minCode, const std::string& sId)
{
  send_querySession(maxCode, minCode, sId);
  recv_querySession(_return);
}

void CacheServiceClient::send_querySession(const std::string& maxCode, const std::string& minCode, const std::string& sId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("querySession", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_querySession_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.sId = &sId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_querySession(std::map<std::string, std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("querySession") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_querySession_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "querySession failed: unknown result");
}

void CacheServiceClient::commonHset( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& key, const std::string& field, const std::string& value)
{
  send_commonHset(maxCode, minCode, key, field, value);
  recv_commonHset(_return);
}

void CacheServiceClient::send_commonHset(const std::string& maxCode, const std::string& minCode, const std::string& key, const std::string& field, const std::string& value)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonHset", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonHset_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.field = &field;
  args.value = &value;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_commonHset( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonHset") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_commonHset_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonHset failed: unknown result");
}

void CacheServiceClient::commonHmset( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& key, const std::map<std::string, std::string> & hashMap)
{
  send_commonHmset(maxCode, minCode, key, hashMap);
  recv_commonHmset(_return);
}

void CacheServiceClient::send_commonHmset(const std::string& maxCode, const std::string& minCode, const std::string& key, const std::map<std::string, std::string> & hashMap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonHmset", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonHmset_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.hashMap = &hashMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_commonHmset( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonHmset") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_commonHmset_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonHmset failed: unknown result");
}

void CacheServiceClient::commonHsetnx( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& key, const std::string& field, const std::string& value)
{
  send_commonHsetnx(maxCode, minCode, key, field, value);
  recv_commonHsetnx(_return);
}

void CacheServiceClient::send_commonHsetnx(const std::string& maxCode, const std::string& minCode, const std::string& key, const std::string& field, const std::string& value)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonHsetnx", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonHsetnx_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.field = &field;
  args.value = &value;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_commonHsetnx( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonHsetnx") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_commonHsetnx_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonHsetnx failed: unknown result");
}

void CacheServiceClient::commonHdel( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& key, const std::vector<std::string> & fields)
{
  send_commonHdel(maxCode, minCode, key, fields);
  recv_commonHdel(_return);
}

void CacheServiceClient::send_commonHdel(const std::string& maxCode, const std::string& minCode, const std::string& key, const std::vector<std::string> & fields)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonHdel", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonHdel_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.fields = &fields;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_commonHdel( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonHdel") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_commonHdel_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonHdel failed: unknown result");
}

void CacheServiceClient::commonBatchHget(std::map<std::string, std::map<std::string, std::string> > & _return, const std::string& maxCode, const std::string& minCode, const std::vector<std::string> & keys)
{
  send_commonBatchHget(maxCode, minCode, keys);
  recv_commonBatchHget(_return);
}

void CacheServiceClient::send_commonBatchHget(const std::string& maxCode, const std::string& minCode, const std::vector<std::string> & keys)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonBatchHget", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonBatchHget_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.keys = &keys;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_commonBatchHget(std::map<std::string, std::map<std::string, std::string> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonBatchHget") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_commonBatchHget_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonBatchHget failed: unknown result");
}

void CacheServiceClient::commonHgetAll(std::map<std::string, std::string> & _return, const std::string& maxCode, const std::string& minCode, const std::string& key)
{
  send_commonHgetAll(maxCode, minCode, key);
  recv_commonHgetAll(_return);
}

void CacheServiceClient::send_commonHgetAll(const std::string& maxCode, const std::string& minCode, const std::string& key)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonHgetAll", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonHgetAll_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_commonHgetAll(std::map<std::string, std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonHgetAll") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_commonHgetAll_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonHgetAll failed: unknown result");
}

void CacheServiceClient::commonHget(std::string& _return, const std::string& maxCode, const std::string& minCode, const std::string& key, const std::string& field)
{
  send_commonHget(maxCode, minCode, key, field);
  recv_commonHget(_return);
}

void CacheServiceClient::send_commonHget(const std::string& maxCode, const std::string& minCode, const std::string& key, const std::string& field)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonHget", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonHget_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.field = &field;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_commonHget(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonHget") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_commonHget_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonHget failed: unknown result");
}

void CacheServiceClient::commonHmget(std::vector<std::string> & _return, const std::string& maxCode, const std::string& minCode, const std::string& key, const std::vector<std::string> & fields)
{
  send_commonHmget(maxCode, minCode, key, fields);
  recv_commonHmget(_return);
}

void CacheServiceClient::send_commonHmget(const std::string& maxCode, const std::string& minCode, const std::string& key, const std::vector<std::string> & fields)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonHmget", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonHmget_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.fields = &fields;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_commonHmget(std::vector<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonHmget") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_commonHmget_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonHmget failed: unknown result");
}

void CacheServiceClient::commonHscan(std::map<std::string, std::string> & _return, const std::string& maxCode, const std::string& minCode, const std::string& key, const std::string& cursor, const std::string& match, const std::string& count)
{
  send_commonHscan(maxCode, minCode, key, cursor, match, count);
  recv_commonHscan(_return);
}

void CacheServiceClient::send_commonHscan(const std::string& maxCode, const std::string& minCode, const std::string& key, const std::string& cursor, const std::string& match, const std::string& count)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonHscan", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonHscan_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.cursor = &cursor;
  args.match = &match;
  args.count = &count;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_commonHscan(std::map<std::string, std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonHscan") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_commonHscan_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonHscan failed: unknown result");
}

void CacheServiceClient::commonHvals(std::vector<std::string> & _return, const std::string& maxCode, const std::string& minCode, const std::string& key)
{
  send_commonHvals(maxCode, minCode, key);
  recv_commonHvals(_return);
}

void CacheServiceClient::send_commonHvals(const std::string& maxCode, const std::string& minCode, const std::string& key)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonHvals", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonHvals_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_commonHvals(std::vector<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonHvals") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_commonHvals_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonHvals failed: unknown result");
}

bool CacheServiceClient::commonHexists(const std::string& maxCode, const std::string& minCode, const std::string& key, const std::string& field)
{
  send_commonHexists(maxCode, minCode, key, field);
  return recv_commonHexists();
}

void CacheServiceClient::send_commonHexists(const std::string& maxCode, const std::string& minCode, const std::string& key, const std::string& field)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonHexists", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonHexists_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.field = &field;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool CacheServiceClient::recv_commonHexists()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonHexists") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  CacheService_commonHexists_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonHexists failed: unknown result");
}

int64_t CacheServiceClient::commonHlen(const std::string& maxCode, const std::string& minCode, const std::string& key)
{
  send_commonHlen(maxCode, minCode, key);
  return recv_commonHlen();
}

void CacheServiceClient::send_commonHlen(const std::string& maxCode, const std::string& minCode, const std::string& key)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonHlen", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonHlen_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int64_t CacheServiceClient::recv_commonHlen()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonHlen") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int64_t _return;
  CacheService_commonHlen_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonHlen failed: unknown result");
}

void CacheServiceClient::commonZadd( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& key, const std::map<std::string, double> & hashMap, const std::string& options)
{
  send_commonZadd(maxCode, minCode, key, hashMap, options);
  recv_commonZadd(_return);
}

void CacheServiceClient::send_commonZadd(const std::string& maxCode, const std::string& minCode, const std::string& key, const std::map<std::string, double> & hashMap, const std::string& options)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonZadd", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonZadd_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.hashMap = &hashMap;
  args.options = &options;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_commonZadd( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonZadd") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_commonZadd_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonZadd failed: unknown result");
}

void CacheServiceClient::commonZrem( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& key, const std::vector<std::string> & members)
{
  send_commonZrem(maxCode, minCode, key, members);
  recv_commonZrem(_return);
}

void CacheServiceClient::send_commonZrem(const std::string& maxCode, const std::string& minCode, const std::string& key, const std::vector<std::string> & members)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonZrem", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonZrem_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.members = &members;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_commonZrem( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonZrem") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_commonZrem_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonZrem failed: unknown result");
}

void CacheServiceClient::commonZremrangeByScore( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& key, const double min, const double max)
{
  send_commonZremrangeByScore(maxCode, minCode, key, min, max);
  recv_commonZremrangeByScore(_return);
}

void CacheServiceClient::send_commonZremrangeByScore(const std::string& maxCode, const std::string& minCode, const std::string& key, const double min, const double max)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonZremrangeByScore", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonZremrangeByScore_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.min = &min;
  args.max = &max;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_commonZremrangeByScore( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonZremrangeByScore") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_commonZremrangeByScore_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonZremrangeByScore failed: unknown result");
}

void CacheServiceClient::commonZremrangeByRank( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& key, const int64_t min, const int64_t max)
{
  send_commonZremrangeByRank(maxCode, minCode, key, min, max);
  recv_commonZremrangeByRank(_return);
}

void CacheServiceClient::send_commonZremrangeByRank(const std::string& maxCode, const std::string& minCode, const std::string& key, const int64_t min, const int64_t max)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonZremrangeByRank", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonZremrangeByRank_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.min = &min;
  args.max = &max;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_commonZremrangeByRank( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonZremrangeByRank") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_commonZremrangeByRank_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonZremrangeByRank failed: unknown result");
}

void CacheServiceClient::commonZremrangeByLex( ::com::vrv::cems::service::base::bean::cache::Result& _return, const std::string& maxCode, const std::string& minCode, const std::string& key, const std::string& min, const std::string& max)
{
  send_commonZremrangeByLex(maxCode, minCode, key, min, max);
  recv_commonZremrangeByLex(_return);
}

void CacheServiceClient::send_commonZremrangeByLex(const std::string& maxCode, const std::string& minCode, const std::string& key, const std::string& min, const std::string& max)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonZremrangeByLex", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonZremrangeByLex_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.min = &min;
  args.max = &max;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_commonZremrangeByLex( ::com::vrv::cems::service::base::bean::cache::Result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonZremrangeByLex") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_commonZremrangeByLex_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonZremrangeByLex failed: unknown result");
}

int64_t CacheServiceClient::commonZcard(const std::string& maxCode, const std::string& minCode, const std::string& key)
{
  send_commonZcard(maxCode, minCode, key);
  return recv_commonZcard();
}

void CacheServiceClient::send_commonZcard(const std::string& maxCode, const std::string& minCode, const std::string& key)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonZcard", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonZcard_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int64_t CacheServiceClient::recv_commonZcard()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonZcard") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int64_t _return;
  CacheService_commonZcard_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonZcard failed: unknown result");
}

double CacheServiceClient::commonZscore(const std::string& maxCode, const std::string& minCode, const std::string& key, const std::string& member)
{
  send_commonZscore(maxCode, minCode, key, member);
  return recv_commonZscore();
}

void CacheServiceClient::send_commonZscore(const std::string& maxCode, const std::string& minCode, const std::string& key, const std::string& member)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonZscore", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonZscore_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.member = &member;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double CacheServiceClient::recv_commonZscore()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonZscore") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  CacheService_commonZscore_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonZscore failed: unknown result");
}

int64_t CacheServiceClient::commonZrank(const std::string& maxCode, const std::string& minCode, const std::string& key, const std::string& member, const std::string& sortType)
{
  send_commonZrank(maxCode, minCode, key, member, sortType);
  return recv_commonZrank();
}

void CacheServiceClient::send_commonZrank(const std::string& maxCode, const std::string& minCode, const std::string& key, const std::string& member, const std::string& sortType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonZrank", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonZrank_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.member = &member;
  args.sortType = &sortType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int64_t CacheServiceClient::recv_commonZrank()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonZrank") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int64_t _return;
  CacheService_commonZrank_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonZrank failed: unknown result");
}

void CacheServiceClient::commonPageZrangeByScore(std::set<std::string> & _return, const std::string& maxCode, const std::string& minCode, const std::string& key, const double min, const double max, const std::string& sortType, const int32_t offset, const int32_t count)
{
  send_commonPageZrangeByScore(maxCode, minCode, key, min, max, sortType, offset, count);
  recv_commonPageZrangeByScore(_return);
}

void CacheServiceClient::send_commonPageZrangeByScore(const std::string& maxCode, const std::string& minCode, const std::string& key, const double min, const double max, const std::string& sortType, const int32_t offset, const int32_t count)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonPageZrangeByScore", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonPageZrangeByScore_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.min = &min;
  args.max = &max;
  args.sortType = &sortType;
  args.offset = &offset;
  args.count = &count;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_commonPageZrangeByScore(std::set<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonPageZrangeByScore") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_commonPageZrangeByScore_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonPageZrangeByScore failed: unknown result");
}

void CacheServiceClient::commonPageZrangeByScoreWithScores(std::map<std::string, std::string> & _return, const std::string& maxCode, const std::string& minCode, const std::string& key, const double min, const double max, const std::string& sortType, const int32_t offset, const int32_t count)
{
  send_commonPageZrangeByScoreWithScores(maxCode, minCode, key, min, max, sortType, offset, count);
  recv_commonPageZrangeByScoreWithScores(_return);
}

void CacheServiceClient::send_commonPageZrangeByScoreWithScores(const std::string& maxCode, const std::string& minCode, const std::string& key, const double min, const double max, const std::string& sortType, const int32_t offset, const int32_t count)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonPageZrangeByScoreWithScores", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonPageZrangeByScoreWithScores_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.min = &min;
  args.max = &max;
  args.sortType = &sortType;
  args.offset = &offset;
  args.count = &count;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_commonPageZrangeByScoreWithScores(std::map<std::string, std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonPageZrangeByScoreWithScores") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_commonPageZrangeByScoreWithScores_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonPageZrangeByScoreWithScores failed: unknown result");
}

void CacheServiceClient::commonZrangeByScore(std::map<std::string, std::string> & _return, const std::string& maxCode, const std::string& minCode, const std::string& key, const double min, const double max, const std::string& sortType)
{
  send_commonZrangeByScore(maxCode, minCode, key, min, max, sortType);
  recv_commonZrangeByScore(_return);
}

void CacheServiceClient::send_commonZrangeByScore(const std::string& maxCode, const std::string& minCode, const std::string& key, const double min, const double max, const std::string& sortType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonZrangeByScore", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonZrangeByScore_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.min = &min;
  args.max = &max;
  args.sortType = &sortType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_commonZrangeByScore(std::map<std::string, std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonZrangeByScore") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_commonZrangeByScore_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonZrangeByScore failed: unknown result");
}

void CacheServiceClient::commonZrangeByScoreWithScores(std::set<std::string> & _return, const std::string& maxCode, const std::string& minCode, const std::string& key, const double min, const double max, const std::string& sortType)
{
  send_commonZrangeByScoreWithScores(maxCode, minCode, key, min, max, sortType);
  recv_commonZrangeByScoreWithScores(_return);
}

void CacheServiceClient::send_commonZrangeByScoreWithScores(const std::string& maxCode, const std::string& minCode, const std::string& key, const double min, const double max, const std::string& sortType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonZrangeByScoreWithScores", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonZrangeByScoreWithScores_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.min = &min;
  args.max = &max;
  args.sortType = &sortType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_commonZrangeByScoreWithScores(std::set<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonZrangeByScoreWithScores") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_commonZrangeByScoreWithScores_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonZrangeByScoreWithScores failed: unknown result");
}

void CacheServiceClient::commonZrange(std::set<std::string> & _return, const std::string& maxCode, const std::string& minCode, const std::string& key, const int64_t min, const int64_t max, const std::string& sortType)
{
  send_commonZrange(maxCode, minCode, key, min, max, sortType);
  recv_commonZrange(_return);
}

void CacheServiceClient::send_commonZrange(const std::string& maxCode, const std::string& minCode, const std::string& key, const int64_t min, const int64_t max, const std::string& sortType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonZrange", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonZrange_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.min = &min;
  args.max = &max;
  args.sortType = &sortType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CacheServiceClient::recv_commonZrange(std::set<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonZrange") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CacheService_commonZrange_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonZrange failed: unknown result");
}

double CacheServiceClient::commonZincrby(const std::string& maxCode, const std::string& minCode, const std::string& key, const double sorce, const std::string& member)
{
  send_commonZincrby(maxCode, minCode, key, sorce, member);
  return recv_commonZincrby();
}

void CacheServiceClient::send_commonZincrby(const std::string& maxCode, const std::string& minCode, const std::string& key, const double sorce, const std::string& member)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonZincrby", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonZincrby_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.sorce = &sorce;
  args.member = &member;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double CacheServiceClient::recv_commonZincrby()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonZincrby") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  CacheService_commonZincrby_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonZincrby failed: unknown result");
}

int64_t CacheServiceClient::commonZcount(const std::string& maxCode, const std::string& minCode, const std::string& key, const double min, const double max)
{
  send_commonZcount(maxCode, minCode, key, min, max);
  return recv_commonZcount();
}

void CacheServiceClient::send_commonZcount(const std::string& maxCode, const std::string& minCode, const std::string& key, const double min, const double max)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commonZcount", ::apache::thrift::protocol::T_CALL, cseqid);

  CacheService_commonZcount_pargs args;
  args.maxCode = &maxCode;
  args.minCode = &minCode;
  args.key = &key;
  args.min = &min;
  args.max = &max;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int64_t CacheServiceClient::recv_commonZcount()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commonZcount") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int64_t _return;
  CacheService_commonZcount_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "commonZcount failed: unknown result");
}

bool CacheServiceProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void CacheServiceProcessor::process_getDataTS(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.getDataTS", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.getDataTS");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.getDataTS");
  }

  CacheService_getDataTS_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.getDataTS", bytes);
  }

  CacheService_getDataTS_result result;
  try {
    iface_->getDataTS(result.success, args.maxCode, args.minCode, args.checkCode, args.isZip, args.data, args.isEncrypt, args.key, args.flag);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.getDataTS");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getDataTS", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.getDataTS");
  }

  oprot->writeMessageBegin("getDataTS", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.getDataTS", bytes);
  }
}

void CacheServiceProcessor::process_isExist(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.isExist", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.isExist");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.isExist");
  }

  CacheService_isExist_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.isExist", bytes);
  }

  CacheService_isExist_result result;
  try {
    iface_->isExist(result.success, args.maxCode, args.minCode, args.prefix, args.key);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.isExist");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("isExist", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.isExist");
  }

  oprot->writeMessageBegin("isExist", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.isExist", bytes);
  }
}

void CacheServiceProcessor::process_setExpireTimeByString(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.setExpireTimeByString", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.setExpireTimeByString");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.setExpireTimeByString");
  }

  CacheService_setExpireTimeByString_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.setExpireTimeByString", bytes);
  }

  CacheService_setExpireTimeByString_result result;
  try {
    iface_->setExpireTimeByString(result.success, args.maxCode, args.minCode, args.key, args.expireTime);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.setExpireTimeByString");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("setExpireTimeByString", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.setExpireTimeByString");
  }

  oprot->writeMessageBegin("setExpireTimeByString", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.setExpireTimeByString", bytes);
  }
}

void CacheServiceProcessor::process_setExpireTimeByBinary(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.setExpireTimeByBinary", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.setExpireTimeByBinary");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.setExpireTimeByBinary");
  }

  CacheService_setExpireTimeByBinary_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.setExpireTimeByBinary", bytes);
  }

  CacheService_setExpireTimeByBinary_result result;
  try {
    iface_->setExpireTimeByBinary(result.success, args.maxCode, args.minCode, args.key, args.expireTime);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.setExpireTimeByBinary");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("setExpireTimeByBinary", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.setExpireTimeByBinary");
  }

  oprot->writeMessageBegin("setExpireTimeByBinary", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.setExpireTimeByBinary", bytes);
  }
}

void CacheServiceProcessor::process_batchDel(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.batchDel", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.batchDel");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.batchDel");
  }

  CacheService_batchDel_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.batchDel", bytes);
  }

  CacheService_batchDel_result result;
  try {
    iface_->batchDel(result.success, args.maxCode, args.minCode, args.keyList);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.batchDel");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("batchDel", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.batchDel");
  }

  oprot->writeMessageBegin("batchDel", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.batchDel", bytes);
  }
}

void CacheServiceProcessor::process_saveDevice(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveDevice", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveDevice");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveDevice");
  }

  CacheService_saveDevice_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveDevice", bytes);
  }

  CacheService_saveDevice_result result;
  try {
    iface_->saveDevice(result.success, args.maxCode, args.minCode, args.deviceCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveDevice");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveDevice", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveDevice");
  }

  oprot->writeMessageBegin("saveDevice", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveDevice", bytes);
  }
}

void CacheServiceProcessor::process_updateDevice(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateDevice", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateDevice");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateDevice");
  }

  CacheService_updateDevice_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateDevice", bytes);
  }

  CacheService_updateDevice_result result;
  try {
    iface_->updateDevice(result.success, args.maxCode, args.minCode, args.deviceCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateDevice");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateDevice", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateDevice");
  }

  oprot->writeMessageBegin("updateDevice", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateDevice", bytes);
  }
}

void CacheServiceProcessor::process_updateDeviceByField(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateDeviceByField", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateDeviceByField");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateDeviceByField");
  }

  CacheService_updateDeviceByField_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateDeviceByField", bytes);
  }

  CacheService_updateDeviceByField_result result;
  try {
    iface_->updateDeviceByField(result.success, args.maxCode, args.minCode, args.devOnlyId, args.fieldValueMap);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateDeviceByField");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateDeviceByField", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateDeviceByField");
  }

  oprot->writeMessageBegin("updateDeviceByField", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateDeviceByField", bytes);
  }
}

void CacheServiceProcessor::process_queryDevice(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryDevice", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryDevice");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryDevice");
  }

  CacheService_queryDevice_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryDevice", bytes);
  }

  CacheService_queryDevice_result result;
  try {
    iface_->queryDevice(result.success, args.maxCode, args.minCode, args.deviceCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryDevice");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryDevice", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryDevice");
  }

  oprot->writeMessageBegin("queryDevice", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryDevice", bytes);
  }
}

void CacheServiceProcessor::process_queryDeviceByDevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryDeviceByDevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryDeviceByDevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryDeviceByDevOnlyId");
  }

  CacheService_queryDeviceByDevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryDeviceByDevOnlyId", bytes);
  }

  CacheService_queryDeviceByDevOnlyId_result result;
  try {
    iface_->queryDeviceByDevOnlyId(result.success, args.maxCode, args.minCode, args.devOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryDeviceByDevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryDeviceByDevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryDeviceByDevOnlyId");
  }

  oprot->writeMessageBegin("queryDeviceByDevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryDeviceByDevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_queryDeviceByIp(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryDeviceByIp", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryDeviceByIp");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryDeviceByIp");
  }

  CacheService_queryDeviceByIp_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryDeviceByIp", bytes);
  }

  CacheService_queryDeviceByIp_result result;
  try {
    iface_->queryDeviceByIp(result.success, args.maxCode, args.minCode, args.ip);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryDeviceByIp");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryDeviceByIp", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryDeviceByIp");
  }

  oprot->writeMessageBegin("queryDeviceByIp", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryDeviceByIp", bytes);
  }
}

void CacheServiceProcessor::process_deleteDevice(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteDevice", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteDevice");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteDevice");
  }

  CacheService_deleteDevice_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteDevice", bytes);
  }

  CacheService_deleteDevice_result result;
  try {
    iface_->deleteDevice(result.success, args.maxCode, args.minCode, args.deviceCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteDevice");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteDevice", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteDevice");
  }

  oprot->writeMessageBegin("deleteDevice", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteDevice", bytes);
  }
}

void CacheServiceProcessor::process_deleteDeviceByDevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteDeviceByDevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteDeviceByDevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteDeviceByDevOnlyId");
  }

  CacheService_deleteDeviceByDevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteDeviceByDevOnlyId", bytes);
  }

  CacheService_deleteDeviceByDevOnlyId_result result;
  try {
    iface_->deleteDeviceByDevOnlyId(result.success, args.maxCode, args.minCode, args.devOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteDeviceByDevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteDeviceByDevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteDeviceByDevOnlyId");
  }

  oprot->writeMessageBegin("deleteDeviceByDevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteDeviceByDevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_deleteDeviceByIp(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteDeviceByIp", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteDeviceByIp");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteDeviceByIp");
  }

  CacheService_deleteDeviceByIp_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteDeviceByIp", bytes);
  }

  CacheService_deleteDeviceByIp_result result;
  try {
    iface_->deleteDeviceByIp(result.success, args.maxCode, args.minCode, args.ip);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteDeviceByIp");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteDeviceByIp", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteDeviceByIp");
  }

  oprot->writeMessageBegin("deleteDeviceByIp", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteDeviceByIp", bytes);
  }
}

void CacheServiceProcessor::process_batchSaveDevice(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.batchSaveDevice", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.batchSaveDevice");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.batchSaveDevice");
  }

  CacheService_batchSaveDevice_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.batchSaveDevice", bytes);
  }

  CacheService_batchSaveDevice_result result;
  try {
    iface_->batchSaveDevice(result.success, args.maxCode, args.minCode, args.deviceCacheList);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.batchSaveDevice");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("batchSaveDevice", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.batchSaveDevice");
  }

  oprot->writeMessageBegin("batchSaveDevice", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.batchSaveDevice", bytes);
  }
}

void CacheServiceProcessor::process_batchUpdateDevice(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.batchUpdateDevice", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.batchUpdateDevice");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.batchUpdateDevice");
  }

  CacheService_batchUpdateDevice_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.batchUpdateDevice", bytes);
  }

  CacheService_batchUpdateDevice_result result;
  try {
    iface_->batchUpdateDevice(result.success, args.maxCode, args.minCode, args.deviceCacheList);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.batchUpdateDevice");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("batchUpdateDevice", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.batchUpdateDevice");
  }

  oprot->writeMessageBegin("batchUpdateDevice", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.batchUpdateDevice", bytes);
  }
}

void CacheServiceProcessor::process_batchQueryDevice(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.batchQueryDevice", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.batchQueryDevice");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.batchQueryDevice");
  }

  CacheService_batchQueryDevice_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.batchQueryDevice", bytes);
  }

  CacheService_batchQueryDevice_result result;
  try {
    iface_->batchQueryDevice(result.success, args.maxCode, args.minCode, args.deviceCacheList);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.batchQueryDevice");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("batchQueryDevice", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.batchQueryDevice");
  }

  oprot->writeMessageBegin("batchQueryDevice", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.batchQueryDevice", bytes);
  }
}

void CacheServiceProcessor::process_batchQueryDeviceByDevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.batchQueryDeviceByDevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.batchQueryDeviceByDevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.batchQueryDeviceByDevOnlyId");
  }

  CacheService_batchQueryDeviceByDevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.batchQueryDeviceByDevOnlyId", bytes);
  }

  CacheService_batchQueryDeviceByDevOnlyId_result result;
  try {
    iface_->batchQueryDeviceByDevOnlyId(result.success, args.maxCode, args.minCode, args.devOnlyIdList);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.batchQueryDeviceByDevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("batchQueryDeviceByDevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.batchQueryDeviceByDevOnlyId");
  }

  oprot->writeMessageBegin("batchQueryDeviceByDevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.batchQueryDeviceByDevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_batchDeleteDevice(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.batchDeleteDevice", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.batchDeleteDevice");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.batchDeleteDevice");
  }

  CacheService_batchDeleteDevice_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.batchDeleteDevice", bytes);
  }

  CacheService_batchDeleteDevice_result result;
  try {
    iface_->batchDeleteDevice(result.success, args.maxCode, args.minCode, args.deviceCacheList);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.batchDeleteDevice");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("batchDeleteDevice", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.batchDeleteDevice");
  }

  oprot->writeMessageBegin("batchDeleteDevice", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.batchDeleteDevice", bytes);
  }
}

void CacheServiceProcessor::process_batchDeleteDeviceByDevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.batchDeleteDeviceByDevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.batchDeleteDeviceByDevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.batchDeleteDeviceByDevOnlyId");
  }

  CacheService_batchDeleteDeviceByDevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.batchDeleteDeviceByDevOnlyId", bytes);
  }

  CacheService_batchDeleteDeviceByDevOnlyId_result result;
  try {
    iface_->batchDeleteDeviceByDevOnlyId(result.success, args.maxCode, args.minCode, args.devOnlyIdList);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.batchDeleteDeviceByDevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("batchDeleteDeviceByDevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.batchDeleteDeviceByDevOnlyId");
  }

  oprot->writeMessageBegin("batchDeleteDeviceByDevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.batchDeleteDeviceByDevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_saveDeviceOnline(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveDeviceOnline", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveDeviceOnline");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveDeviceOnline");
  }

  CacheService_saveDeviceOnline_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveDeviceOnline", bytes);
  }

  CacheService_saveDeviceOnline_result result;
  try {
    iface_->saveDeviceOnline(result.success, args.maxCode, args.minCode, args.deviceOnlineCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveDeviceOnline");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveDeviceOnline", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveDeviceOnline");
  }

  oprot->writeMessageBegin("saveDeviceOnline", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveDeviceOnline", bytes);
  }
}

void CacheServiceProcessor::process_updateDeviceOnline(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateDeviceOnline", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateDeviceOnline");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateDeviceOnline");
  }

  CacheService_updateDeviceOnline_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateDeviceOnline", bytes);
  }

  CacheService_updateDeviceOnline_result result;
  try {
    iface_->updateDeviceOnline(result.success, args.maxCode, args.minCode, args.deviceOnlineCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateDeviceOnline");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateDeviceOnline", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateDeviceOnline");
  }

  oprot->writeMessageBegin("updateDeviceOnline", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateDeviceOnline", bytes);
  }
}

void CacheServiceProcessor::process_updateDeviceOnlineByField(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateDeviceOnlineByField", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateDeviceOnlineByField");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateDeviceOnlineByField");
  }

  CacheService_updateDeviceOnlineByField_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateDeviceOnlineByField", bytes);
  }

  CacheService_updateDeviceOnlineByField_result result;
  try {
    iface_->updateDeviceOnlineByField(result.success, args.maxCode, args.minCode, args.devOnlyId, args.fieldValueMap);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateDeviceOnlineByField");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateDeviceOnlineByField", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateDeviceOnlineByField");
  }

  oprot->writeMessageBegin("updateDeviceOnlineByField", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateDeviceOnlineByField", bytes);
  }
}

void CacheServiceProcessor::process_queryDeviceOnline(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryDeviceOnline", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryDeviceOnline");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryDeviceOnline");
  }

  CacheService_queryDeviceOnline_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryDeviceOnline", bytes);
  }

  CacheService_queryDeviceOnline_result result;
  try {
    iface_->queryDeviceOnline(result.success, args.maxCode, args.minCode, args.deviceOnlineCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryDeviceOnline");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryDeviceOnline", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryDeviceOnline");
  }

  oprot->writeMessageBegin("queryDeviceOnline", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryDeviceOnline", bytes);
  }
}

void CacheServiceProcessor::process_queryDeviceOnlineByDevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryDeviceOnlineByDevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryDeviceOnlineByDevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryDeviceOnlineByDevOnlyId");
  }

  CacheService_queryDeviceOnlineByDevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryDeviceOnlineByDevOnlyId", bytes);
  }

  CacheService_queryDeviceOnlineByDevOnlyId_result result;
  try {
    iface_->queryDeviceOnlineByDevOnlyId(result.success, args.maxCode, args.minCode, args.devOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryDeviceOnlineByDevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryDeviceOnlineByDevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryDeviceOnlineByDevOnlyId");
  }

  oprot->writeMessageBegin("queryDeviceOnlineByDevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryDeviceOnlineByDevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_queryDeviceOnlineByIp(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryDeviceOnlineByIp", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryDeviceOnlineByIp");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryDeviceOnlineByIp");
  }

  CacheService_queryDeviceOnlineByIp_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryDeviceOnlineByIp", bytes);
  }

  CacheService_queryDeviceOnlineByIp_result result;
  try {
    iface_->queryDeviceOnlineByIp(result.success, args.maxCode, args.minCode, args.ip);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryDeviceOnlineByIp");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryDeviceOnlineByIp", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryDeviceOnlineByIp");
  }

  oprot->writeMessageBegin("queryDeviceOnlineByIp", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryDeviceOnlineByIp", bytes);
  }
}

void CacheServiceProcessor::process_deleteDeviceOnline(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteDeviceOnline", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteDeviceOnline");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteDeviceOnline");
  }

  CacheService_deleteDeviceOnline_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteDeviceOnline", bytes);
  }

  CacheService_deleteDeviceOnline_result result;
  try {
    iface_->deleteDeviceOnline(result.success, args.maxCode, args.minCode, args.deviceOnlineCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteDeviceOnline");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteDeviceOnline", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteDeviceOnline");
  }

  oprot->writeMessageBegin("deleteDeviceOnline", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteDeviceOnline", bytes);
  }
}

void CacheServiceProcessor::process_deleteDeviceOnlineByDevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteDeviceOnlineByDevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteDeviceOnlineByDevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteDeviceOnlineByDevOnlyId");
  }

  CacheService_deleteDeviceOnlineByDevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteDeviceOnlineByDevOnlyId", bytes);
  }

  CacheService_deleteDeviceOnlineByDevOnlyId_result result;
  try {
    iface_->deleteDeviceOnlineByDevOnlyId(result.success, args.maxCode, args.minCode, args.devOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteDeviceOnlineByDevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteDeviceOnlineByDevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteDeviceOnlineByDevOnlyId");
  }

  oprot->writeMessageBegin("deleteDeviceOnlineByDevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteDeviceOnlineByDevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_deleteDeviceOnlineByIp(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteDeviceOnlineByIp", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteDeviceOnlineByIp");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteDeviceOnlineByIp");
  }

  CacheService_deleteDeviceOnlineByIp_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteDeviceOnlineByIp", bytes);
  }

  CacheService_deleteDeviceOnlineByIp_result result;
  try {
    iface_->deleteDeviceOnlineByIp(result.success, args.maxCode, args.minCode, args.ip);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteDeviceOnlineByIp");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteDeviceOnlineByIp", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteDeviceOnlineByIp");
  }

  oprot->writeMessageBegin("deleteDeviceOnlineByIp", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteDeviceOnlineByIp", bytes);
  }
}

void CacheServiceProcessor::process_queryAllDeviceOnlineCache(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryAllDeviceOnlineCache", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryAllDeviceOnlineCache");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryAllDeviceOnlineCache");
  }

  CacheService_queryAllDeviceOnlineCache_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryAllDeviceOnlineCache", bytes);
  }

  CacheService_queryAllDeviceOnlineCache_result result;
  try {
    iface_->queryAllDeviceOnlineCache(result.success, args.maxCode, args.minCode);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryAllDeviceOnlineCache");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryAllDeviceOnlineCache", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryAllDeviceOnlineCache");
  }

  oprot->writeMessageBegin("queryAllDeviceOnlineCache", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryAllDeviceOnlineCache", bytes);
  }
}

void CacheServiceProcessor::process_queryOnlineDevOnlyIdsByUserOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryOnlineDevOnlyIdsByUserOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryOnlineDevOnlyIdsByUserOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryOnlineDevOnlyIdsByUserOnlyId");
  }

  CacheService_queryOnlineDevOnlyIdsByUserOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryOnlineDevOnlyIdsByUserOnlyId", bytes);
  }

  CacheService_queryOnlineDevOnlyIdsByUserOnlyId_result result;
  try {
    iface_->queryOnlineDevOnlyIdsByUserOnlyId(result.success, args.maxCode, args.minCode, args.userOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryOnlineDevOnlyIdsByUserOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryOnlineDevOnlyIdsByUserOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryOnlineDevOnlyIdsByUserOnlyId");
  }

  oprot->writeMessageBegin("queryOnlineDevOnlyIdsByUserOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryOnlineDevOnlyIdsByUserOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_batchQueryDeviceOnlinesByDevOnlyIdList(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.batchQueryDeviceOnlinesByDevOnlyIdList", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.batchQueryDeviceOnlinesByDevOnlyIdList");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.batchQueryDeviceOnlinesByDevOnlyIdList");
  }

  CacheService_batchQueryDeviceOnlinesByDevOnlyIdList_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.batchQueryDeviceOnlinesByDevOnlyIdList", bytes);
  }

  CacheService_batchQueryDeviceOnlinesByDevOnlyIdList_result result;
  try {
    iface_->batchQueryDeviceOnlinesByDevOnlyIdList(result.success, args.maxCode, args.minCode, args.devOnlyIdList);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.batchQueryDeviceOnlinesByDevOnlyIdList");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("batchQueryDeviceOnlinesByDevOnlyIdList", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.batchQueryDeviceOnlinesByDevOnlyIdList");
  }

  oprot->writeMessageBegin("batchQueryDeviceOnlinesByDevOnlyIdList", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.batchQueryDeviceOnlinesByDevOnlyIdList", bytes);
  }
}

void CacheServiceProcessor::process_saveDeviceKey(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveDeviceKey", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveDeviceKey");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveDeviceKey");
  }

  CacheService_saveDeviceKey_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveDeviceKey", bytes);
  }

  CacheService_saveDeviceKey_result result;
  try {
    iface_->saveDeviceKey(result.success, args.maxCode, args.minCode, args.deviceKeyCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveDeviceKey");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveDeviceKey", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveDeviceKey");
  }

  oprot->writeMessageBegin("saveDeviceKey", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveDeviceKey", bytes);
  }
}

void CacheServiceProcessor::process_updateDeviceKey(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateDeviceKey", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateDeviceKey");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateDeviceKey");
  }

  CacheService_updateDeviceKey_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateDeviceKey", bytes);
  }

  CacheService_updateDeviceKey_result result;
  try {
    iface_->updateDeviceKey(result.success, args.maxCode, args.minCode, args.deviceKeyCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateDeviceKey");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateDeviceKey", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateDeviceKey");
  }

  oprot->writeMessageBegin("updateDeviceKey", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateDeviceKey", bytes);
  }
}

void CacheServiceProcessor::process_updateDeviceKeyByField(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateDeviceKeyByField", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateDeviceKeyByField");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateDeviceKeyByField");
  }

  CacheService_updateDeviceKeyByField_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateDeviceKeyByField", bytes);
  }

  CacheService_updateDeviceKeyByField_result result;
  try {
    iface_->updateDeviceKeyByField(result.success, args.maxCode, args.minCode, args.sessionId, args.fieldValueMap);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateDeviceKeyByField");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateDeviceKeyByField", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateDeviceKeyByField");
  }

  oprot->writeMessageBegin("updateDeviceKeyByField", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateDeviceKeyByField", bytes);
  }
}

void CacheServiceProcessor::process_queryDeviceKey(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryDeviceKey", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryDeviceKey");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryDeviceKey");
  }

  CacheService_queryDeviceKey_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryDeviceKey", bytes);
  }

  CacheService_queryDeviceKey_result result;
  try {
    iface_->queryDeviceKey(result.success, args.maxCode, args.minCode, args.deviceKeyCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryDeviceKey");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryDeviceKey", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryDeviceKey");
  }

  oprot->writeMessageBegin("queryDeviceKey", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryDeviceKey", bytes);
  }
}

void CacheServiceProcessor::process_queryDeviceKeyBySessionId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryDeviceKeyBySessionId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryDeviceKeyBySessionId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryDeviceKeyBySessionId");
  }

  CacheService_queryDeviceKeyBySessionId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryDeviceKeyBySessionId", bytes);
  }

  CacheService_queryDeviceKeyBySessionId_result result;
  try {
    iface_->queryDeviceKeyBySessionId(result.success, args.maxCode, args.minCode, args.sessionId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryDeviceKeyBySessionId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryDeviceKeyBySessionId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryDeviceKeyBySessionId");
  }

  oprot->writeMessageBegin("queryDeviceKeyBySessionId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryDeviceKeyBySessionId", bytes);
  }
}

void CacheServiceProcessor::process_queryDeviceKeyByDevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryDeviceKeyByDevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryDeviceKeyByDevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryDeviceKeyByDevOnlyId");
  }

  CacheService_queryDeviceKeyByDevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryDeviceKeyByDevOnlyId", bytes);
  }

  CacheService_queryDeviceKeyByDevOnlyId_result result;
  try {
    iface_->queryDeviceKeyByDevOnlyId(result.success, args.maxCode, args.minCode, args.devOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryDeviceKeyByDevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryDeviceKeyByDevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryDeviceKeyByDevOnlyId");
  }

  oprot->writeMessageBegin("queryDeviceKeyByDevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryDeviceKeyByDevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_deleteDeviceKey(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteDeviceKey", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteDeviceKey");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteDeviceKey");
  }

  CacheService_deleteDeviceKey_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteDeviceKey", bytes);
  }

  CacheService_deleteDeviceKey_result result;
  try {
    iface_->deleteDeviceKey(result.success, args.maxCode, args.minCode, args.deviceKeyCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteDeviceKey");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteDeviceKey", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteDeviceKey");
  }

  oprot->writeMessageBegin("deleteDeviceKey", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteDeviceKey", bytes);
  }
}

void CacheServiceProcessor::process_deleteDeviceKeyBySessionId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteDeviceKeyBySessionId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteDeviceKeyBySessionId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteDeviceKeyBySessionId");
  }

  CacheService_deleteDeviceKeyBySessionId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteDeviceKeyBySessionId", bytes);
  }

  CacheService_deleteDeviceKeyBySessionId_result result;
  try {
    iface_->deleteDeviceKeyBySessionId(result.success, args.maxCode, args.minCode, args.sessionId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteDeviceKeyBySessionId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteDeviceKeyBySessionId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteDeviceKeyBySessionId");
  }

  oprot->writeMessageBegin("deleteDeviceKeyBySessionId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteDeviceKeyBySessionId", bytes);
  }
}

void CacheServiceProcessor::process_deleteDeviceKeyByDevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteDeviceKeyByDevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteDeviceKeyByDevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteDeviceKeyByDevOnlyId");
  }

  CacheService_deleteDeviceKeyByDevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteDeviceKeyByDevOnlyId", bytes);
  }

  CacheService_deleteDeviceKeyByDevOnlyId_result result;
  try {
    iface_->deleteDeviceKeyByDevOnlyId(result.success, args.maxCode, args.minCode, args.devOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteDeviceKeyByDevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteDeviceKeyByDevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteDeviceKeyByDevOnlyId");
  }

  oprot->writeMessageBegin("deleteDeviceKeyByDevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteDeviceKeyByDevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_isExistSessionIdInDeviceKeyCache(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.isExistSessionIdInDeviceKeyCache", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.isExistSessionIdInDeviceKeyCache");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.isExistSessionIdInDeviceKeyCache");
  }

  CacheService_isExistSessionIdInDeviceKeyCache_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.isExistSessionIdInDeviceKeyCache", bytes);
  }

  CacheService_isExistSessionIdInDeviceKeyCache_result result;
  try {
    iface_->isExistSessionIdInDeviceKeyCache(result.success, args.maxCode, args.minCode, args.sessionId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.isExistSessionIdInDeviceKeyCache");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("isExistSessionIdInDeviceKeyCache", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.isExistSessionIdInDeviceKeyCache");
  }

  oprot->writeMessageBegin("isExistSessionIdInDeviceKeyCache", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.isExistSessionIdInDeviceKeyCache", bytes);
  }
}

void CacheServiceProcessor::process_batchQueryDeviceKeysBySessionIdList(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.batchQueryDeviceKeysBySessionIdList", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.batchQueryDeviceKeysBySessionIdList");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.batchQueryDeviceKeysBySessionIdList");
  }

  CacheService_batchQueryDeviceKeysBySessionIdList_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.batchQueryDeviceKeysBySessionIdList", bytes);
  }

  CacheService_batchQueryDeviceKeysBySessionIdList_result result;
  try {
    iface_->batchQueryDeviceKeysBySessionIdList(result.success, args.maxCode, args.minCode, args.sessionIdList);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.batchQueryDeviceKeysBySessionIdList");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("batchQueryDeviceKeysBySessionIdList", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.batchQueryDeviceKeysBySessionIdList");
  }

  oprot->writeMessageBegin("batchQueryDeviceKeysBySessionIdList", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.batchQueryDeviceKeysBySessionIdList", bytes);
  }
}

void CacheServiceProcessor::process_saveDeviceInsProOld(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveDeviceInsProOld", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveDeviceInsProOld");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveDeviceInsProOld");
  }

  CacheService_saveDeviceInsProOld_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveDeviceInsProOld", bytes);
  }

  CacheService_saveDeviceInsProOld_result result;
  try {
    iface_->saveDeviceInsProOld(result.success, args.maxCode, args.minCode, args.devOnlyId, args.deviceProductList);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveDeviceInsProOld");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveDeviceInsProOld", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveDeviceInsProOld");
  }

  oprot->writeMessageBegin("saveDeviceInsProOld", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveDeviceInsProOld", bytes);
  }
}

void CacheServiceProcessor::process_updateDeviceInsProOld(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateDeviceInsProOld", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateDeviceInsProOld");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateDeviceInsProOld");
  }

  CacheService_updateDeviceInsProOld_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateDeviceInsProOld", bytes);
  }

  CacheService_updateDeviceInsProOld_result result;
  try {
    iface_->updateDeviceInsProOld(result.success, args.maxCode, args.minCode, args.devOnlyId, args.deviceProductList);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateDeviceInsProOld");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateDeviceInsProOld", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateDeviceInsProOld");
  }

  oprot->writeMessageBegin("updateDeviceInsProOld", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateDeviceInsProOld", bytes);
  }
}

void CacheServiceProcessor::process_queryDeviceInsProOldByDevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryDeviceInsProOldByDevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryDeviceInsProOldByDevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryDeviceInsProOldByDevOnlyId");
  }

  CacheService_queryDeviceInsProOldByDevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryDeviceInsProOldByDevOnlyId", bytes);
  }

  CacheService_queryDeviceInsProOldByDevOnlyId_result result;
  try {
    iface_->queryDeviceInsProOldByDevOnlyId(result.success, args.maxCode, args.minCode, args.devOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryDeviceInsProOldByDevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryDeviceInsProOldByDevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryDeviceInsProOldByDevOnlyId");
  }

  oprot->writeMessageBegin("queryDeviceInsProOldByDevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryDeviceInsProOldByDevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_deleteDeviceInsProOldByDevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteDeviceInsProOldByDevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteDeviceInsProOldByDevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteDeviceInsProOldByDevOnlyId");
  }

  CacheService_deleteDeviceInsProOldByDevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteDeviceInsProOldByDevOnlyId", bytes);
  }

  CacheService_deleteDeviceInsProOldByDevOnlyId_result result;
  try {
    iface_->deleteDeviceInsProOldByDevOnlyId(result.success, args.maxCode, args.minCode, args.devOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteDeviceInsProOldByDevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteDeviceInsProOldByDevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteDeviceInsProOldByDevOnlyId");
  }

  oprot->writeMessageBegin("deleteDeviceInsProOldByDevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteDeviceInsProOldByDevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_saveDeviceInsProNew(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveDeviceInsProNew", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveDeviceInsProNew");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveDeviceInsProNew");
  }

  CacheService_saveDeviceInsProNew_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveDeviceInsProNew", bytes);
  }

  CacheService_saveDeviceInsProNew_result result;
  try {
    iface_->saveDeviceInsProNew(result.success, args.maxCode, args.minCode, args.devOnlyId, args.deviceProductList);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveDeviceInsProNew");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveDeviceInsProNew", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveDeviceInsProNew");
  }

  oprot->writeMessageBegin("saveDeviceInsProNew", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveDeviceInsProNew", bytes);
  }
}

void CacheServiceProcessor::process_updateDeviceInsProNew(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateDeviceInsProNew", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateDeviceInsProNew");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateDeviceInsProNew");
  }

  CacheService_updateDeviceInsProNew_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateDeviceInsProNew", bytes);
  }

  CacheService_updateDeviceInsProNew_result result;
  try {
    iface_->updateDeviceInsProNew(result.success, args.maxCode, args.minCode, args.devOnlyId, args.deviceProductList);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateDeviceInsProNew");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateDeviceInsProNew", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateDeviceInsProNew");
  }

  oprot->writeMessageBegin("updateDeviceInsProNew", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateDeviceInsProNew", bytes);
  }
}

void CacheServiceProcessor::process_queryDeviceInsProNewByDevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryDeviceInsProNewByDevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryDeviceInsProNewByDevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryDeviceInsProNewByDevOnlyId");
  }

  CacheService_queryDeviceInsProNewByDevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryDeviceInsProNewByDevOnlyId", bytes);
  }

  CacheService_queryDeviceInsProNewByDevOnlyId_result result;
  try {
    iface_->queryDeviceInsProNewByDevOnlyId(result.success, args.maxCode, args.minCode, args.devOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryDeviceInsProNewByDevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryDeviceInsProNewByDevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryDeviceInsProNewByDevOnlyId");
  }

  oprot->writeMessageBegin("queryDeviceInsProNewByDevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryDeviceInsProNewByDevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_deleteDeviceInsProNewByDevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteDeviceInsProNewByDevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteDeviceInsProNewByDevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteDeviceInsProNewByDevOnlyId");
  }

  CacheService_deleteDeviceInsProNewByDevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteDeviceInsProNewByDevOnlyId", bytes);
  }

  CacheService_deleteDeviceInsProNewByDevOnlyId_result result;
  try {
    iface_->deleteDeviceInsProNewByDevOnlyId(result.success, args.maxCode, args.minCode, args.devOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteDeviceInsProNewByDevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteDeviceInsProNewByDevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteDeviceInsProNewByDevOnlyId");
  }

  oprot->writeMessageBegin("deleteDeviceInsProNewByDevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteDeviceInsProNewByDevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_saveDevicePolicy(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveDevicePolicy", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveDevicePolicy");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveDevicePolicy");
  }

  CacheService_saveDevicePolicy_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveDevicePolicy", bytes);
  }

  CacheService_saveDevicePolicy_result result;
  try {
    iface_->saveDevicePolicy(result.success, args.maxCode, args.minCode, args.devicePolicyCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveDevicePolicy");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveDevicePolicy", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveDevicePolicy");
  }

  oprot->writeMessageBegin("saveDevicePolicy", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveDevicePolicy", bytes);
  }
}

void CacheServiceProcessor::process_updateDevicePolicy(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateDevicePolicy", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateDevicePolicy");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateDevicePolicy");
  }

  CacheService_updateDevicePolicy_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateDevicePolicy", bytes);
  }

  CacheService_updateDevicePolicy_result result;
  try {
    iface_->updateDevicePolicy(result.success, args.maxCode, args.minCode, args.devicePolicyCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateDevicePolicy");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateDevicePolicy", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateDevicePolicy");
  }

  oprot->writeMessageBegin("updateDevicePolicy", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateDevicePolicy", bytes);
  }
}

void CacheServiceProcessor::process_queryDevicePolicyByDevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryDevicePolicyByDevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryDevicePolicyByDevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryDevicePolicyByDevOnlyId");
  }

  CacheService_queryDevicePolicyByDevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryDevicePolicyByDevOnlyId", bytes);
  }

  CacheService_queryDevicePolicyByDevOnlyId_result result;
  try {
    iface_->queryDevicePolicyByDevOnlyId(result.success, args.maxCode, args.minCode, args.devOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryDevicePolicyByDevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryDevicePolicyByDevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryDevicePolicyByDevOnlyId");
  }

  oprot->writeMessageBegin("queryDevicePolicyByDevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryDevicePolicyByDevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_queryDevicePolicyByIp(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryDevicePolicyByIp", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryDevicePolicyByIp");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryDevicePolicyByIp");
  }

  CacheService_queryDevicePolicyByIp_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryDevicePolicyByIp", bytes);
  }

  CacheService_queryDevicePolicyByIp_result result;
  try {
    iface_->queryDevicePolicyByIp(result.success, args.maxCode, args.minCode, args.ip);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryDevicePolicyByIp");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryDevicePolicyByIp", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryDevicePolicyByIp");
  }

  oprot->writeMessageBegin("queryDevicePolicyByIp", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryDevicePolicyByIp", bytes);
  }
}

void CacheServiceProcessor::process_deleteDevicePolicyByDevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteDevicePolicyByDevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteDevicePolicyByDevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteDevicePolicyByDevOnlyId");
  }

  CacheService_deleteDevicePolicyByDevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteDevicePolicyByDevOnlyId", bytes);
  }

  CacheService_deleteDevicePolicyByDevOnlyId_result result;
  try {
    iface_->deleteDevicePolicyByDevOnlyId(result.success, args.maxCode, args.minCode, args.devOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteDevicePolicyByDevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteDevicePolicyByDevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteDevicePolicyByDevOnlyId");
  }

  oprot->writeMessageBegin("deleteDevicePolicyByDevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteDevicePolicyByDevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_deleteDevicePolicyByIp(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteDevicePolicyByIp", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteDevicePolicyByIp");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteDevicePolicyByIp");
  }

  CacheService_deleteDevicePolicyByIp_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteDevicePolicyByIp", bytes);
  }

  CacheService_deleteDevicePolicyByIp_result result;
  try {
    iface_->deleteDevicePolicyByIp(result.success, args.maxCode, args.minCode, args.ip);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteDevicePolicyByIp");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteDevicePolicyByIp", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteDevicePolicyByIp");
  }

  oprot->writeMessageBegin("deleteDevicePolicyByIp", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteDevicePolicyByIp", bytes);
  }
}

void CacheServiceProcessor::process_batchSaveDevicePolicy(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.batchSaveDevicePolicy", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.batchSaveDevicePolicy");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.batchSaveDevicePolicy");
  }

  CacheService_batchSaveDevicePolicy_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.batchSaveDevicePolicy", bytes);
  }

  CacheService_batchSaveDevicePolicy_result result;
  try {
    iface_->batchSaveDevicePolicy(result.success, args.maxCode, args.minCode, args.devicePolicyList);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.batchSaveDevicePolicy");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("batchSaveDevicePolicy", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.batchSaveDevicePolicy");
  }

  oprot->writeMessageBegin("batchSaveDevicePolicy", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.batchSaveDevicePolicy", bytes);
  }
}

void CacheServiceProcessor::process_saveUser(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveUser", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveUser");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveUser");
  }

  CacheService_saveUser_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveUser", bytes);
  }

  CacheService_saveUser_result result;
  try {
    iface_->saveUser(result.success, args.maxCode, args.minCode, args.userCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveUser");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveUser", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveUser");
  }

  oprot->writeMessageBegin("saveUser", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveUser", bytes);
  }
}

void CacheServiceProcessor::process_updateUser(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateUser", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateUser");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateUser");
  }

  CacheService_updateUser_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateUser", bytes);
  }

  CacheService_updateUser_result result;
  try {
    iface_->updateUser(result.success, args.maxCode, args.minCode, args.userCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateUser");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateUser", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateUser");
  }

  oprot->writeMessageBegin("updateUser", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateUser", bytes);
  }
}

void CacheServiceProcessor::process_updateUserByField(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateUserByField", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateUserByField");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateUserByField");
  }

  CacheService_updateUserByField_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateUserByField", bytes);
  }

  CacheService_updateUserByField_result result;
  try {
    iface_->updateUserByField(result.success, args.maxCode, args.minCode, args.userOnlyId, args.fieldValueMap);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateUserByField");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateUserByField", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateUserByField");
  }

  oprot->writeMessageBegin("updateUserByField", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateUserByField", bytes);
  }
}

void CacheServiceProcessor::process_queryUserByUserOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryUserByUserOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryUserByUserOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryUserByUserOnlyId");
  }

  CacheService_queryUserByUserOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryUserByUserOnlyId", bytes);
  }

  CacheService_queryUserByUserOnlyId_result result;
  try {
    iface_->queryUserByUserOnlyId(result.success, args.maxCode, args.minCode, args.userOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryUserByUserOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryUserByUserOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryUserByUserOnlyId");
  }

  oprot->writeMessageBegin("queryUserByUserOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryUserByUserOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_deleteUserByUserOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteUserByUserOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteUserByUserOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteUserByUserOnlyId");
  }

  CacheService_deleteUserByUserOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteUserByUserOnlyId", bytes);
  }

  CacheService_deleteUserByUserOnlyId_result result;
  try {
    iface_->deleteUserByUserOnlyId(result.success, args.maxCode, args.minCode, args.userOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteUserByUserOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteUserByUserOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteUserByUserOnlyId");
  }

  oprot->writeMessageBegin("deleteUserByUserOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteUserByUserOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_batchSaveUser(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.batchSaveUser", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.batchSaveUser");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.batchSaveUser");
  }

  CacheService_batchSaveUser_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.batchSaveUser", bytes);
  }

  CacheService_batchSaveUser_result result;
  try {
    iface_->batchSaveUser(result.success, args.maxCode, args.minCode, args.userCacheList);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.batchSaveUser");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("batchSaveUser", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.batchSaveUser");
  }

  oprot->writeMessageBegin("batchSaveUser", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.batchSaveUser", bytes);
  }
}

void CacheServiceProcessor::process_saveUserOnline(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveUserOnline", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveUserOnline");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveUserOnline");
  }

  CacheService_saveUserOnline_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveUserOnline", bytes);
  }

  CacheService_saveUserOnline_result result;
  try {
    iface_->saveUserOnline(result.success, args.maxCode, args.minCode, args.userOnlineCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveUserOnline");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveUserOnline", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveUserOnline");
  }

  oprot->writeMessageBegin("saveUserOnline", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveUserOnline", bytes);
  }
}

void CacheServiceProcessor::process_updateUserOnline(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateUserOnline", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateUserOnline");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateUserOnline");
  }

  CacheService_updateUserOnline_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateUserOnline", bytes);
  }

  CacheService_updateUserOnline_result result;
  try {
    iface_->updateUserOnline(result.success, args.maxCode, args.minCode, args.userOnlineCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateUserOnline");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateUserOnline", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateUserOnline");
  }

  oprot->writeMessageBegin("updateUserOnline", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateUserOnline", bytes);
  }
}

void CacheServiceProcessor::process_updateUserOnlineByField(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateUserOnlineByField", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateUserOnlineByField");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateUserOnlineByField");
  }

  CacheService_updateUserOnlineByField_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateUserOnlineByField", bytes);
  }

  CacheService_updateUserOnlineByField_result result;
  try {
    iface_->updateUserOnlineByField(result.success, args.maxCode, args.minCode, args.userDevId, args.fieldValueMap);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateUserOnlineByField");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateUserOnlineByField", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateUserOnlineByField");
  }

  oprot->writeMessageBegin("updateUserOnlineByField", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateUserOnlineByField", bytes);
  }
}

void CacheServiceProcessor::process_queryUserOnlineByUserDevId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryUserOnlineByUserDevId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryUserOnlineByUserDevId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryUserOnlineByUserDevId");
  }

  CacheService_queryUserOnlineByUserDevId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryUserOnlineByUserDevId", bytes);
  }

  CacheService_queryUserOnlineByUserDevId_result result;
  try {
    iface_->queryUserOnlineByUserDevId(result.success, args.maxCode, args.minCode, args.userDevId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryUserOnlineByUserDevId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryUserOnlineByUserDevId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryUserOnlineByUserDevId");
  }

  oprot->writeMessageBegin("queryUserOnlineByUserDevId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryUserOnlineByUserDevId", bytes);
  }
}

void CacheServiceProcessor::process_deleteUserOnlineByUserDevId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteUserOnlineByUserDevId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteUserOnlineByUserDevId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteUserOnlineByUserDevId");
  }

  CacheService_deleteUserOnlineByUserDevId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteUserOnlineByUserDevId", bytes);
  }

  CacheService_deleteUserOnlineByUserDevId_result result;
  try {
    iface_->deleteUserOnlineByUserDevId(result.success, args.maxCode, args.minCode, args.userDevId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteUserOnlineByUserDevId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteUserOnlineByUserDevId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteUserOnlineByUserDevId");
  }

  oprot->writeMessageBegin("deleteUserOnlineByUserDevId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteUserOnlineByUserDevId", bytes);
  }
}

void CacheServiceProcessor::process_queryAllUserOnlineDevice(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryAllUserOnlineDevice", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryAllUserOnlineDevice");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryAllUserOnlineDevice");
  }

  CacheService_queryAllUserOnlineDevice_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryAllUserOnlineDevice", bytes);
  }

  CacheService_queryAllUserOnlineDevice_result result;
  try {
    iface_->queryAllUserOnlineDevice(result.success, args.maxCode, args.minCode);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryAllUserOnlineDevice");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryAllUserOnlineDevice", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryAllUserOnlineDevice");
  }

  oprot->writeMessageBegin("queryAllUserOnlineDevice", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryAllUserOnlineDevice", bytes);
  }
}

void CacheServiceProcessor::process_saveUserPolicy(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveUserPolicy", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveUserPolicy");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveUserPolicy");
  }

  CacheService_saveUserPolicy_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveUserPolicy", bytes);
  }

  CacheService_saveUserPolicy_result result;
  try {
    iface_->saveUserPolicy(result.success, args.maxCode, args.minCode, args.userPolicyCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveUserPolicy");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveUserPolicy", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveUserPolicy");
  }

  oprot->writeMessageBegin("saveUserPolicy", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveUserPolicy", bytes);
  }
}

void CacheServiceProcessor::process_updateUserPolicy(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateUserPolicy", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateUserPolicy");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateUserPolicy");
  }

  CacheService_updateUserPolicy_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateUserPolicy", bytes);
  }

  CacheService_updateUserPolicy_result result;
  try {
    iface_->updateUserPolicy(result.success, args.maxCode, args.minCode, args.userPolicyCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateUserPolicy");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateUserPolicy", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateUserPolicy");
  }

  oprot->writeMessageBegin("updateUserPolicy", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateUserPolicy", bytes);
  }
}

void CacheServiceProcessor::process_queryUserPolicyByUserOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryUserPolicyByUserOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryUserPolicyByUserOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryUserPolicyByUserOnlyId");
  }

  CacheService_queryUserPolicyByUserOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryUserPolicyByUserOnlyId", bytes);
  }

  CacheService_queryUserPolicyByUserOnlyId_result result;
  try {
    iface_->queryUserPolicyByUserOnlyId(result.success, args.maxCode, args.minCode, args.userOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryUserPolicyByUserOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryUserPolicyByUserOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryUserPolicyByUserOnlyId");
  }

  oprot->writeMessageBegin("queryUserPolicyByUserOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryUserPolicyByUserOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_deleteUserPolicyByUserOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteUserPolicyByUserOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteUserPolicyByUserOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteUserPolicyByUserOnlyId");
  }

  CacheService_deleteUserPolicyByUserOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteUserPolicyByUserOnlyId", bytes);
  }

  CacheService_deleteUserPolicyByUserOnlyId_result result;
  try {
    iface_->deleteUserPolicyByUserOnlyId(result.success, args.maxCode, args.minCode, args.userOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteUserPolicyByUserOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteUserPolicyByUserOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteUserPolicyByUserOnlyId");
  }

  oprot->writeMessageBegin("deleteUserPolicyByUserOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteUserPolicyByUserOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_batchSaveUserPolicy(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.batchSaveUserPolicy", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.batchSaveUserPolicy");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.batchSaveUserPolicy");
  }

  CacheService_batchSaveUserPolicy_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.batchSaveUserPolicy", bytes);
  }

  CacheService_batchSaveUserPolicy_result result;
  try {
    iface_->batchSaveUserPolicy(result.success, args.maxCode, args.minCode, args.userPolicyist);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.batchSaveUserPolicy");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("batchSaveUserPolicy", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.batchSaveUserPolicy");
  }

  oprot->writeMessageBegin("batchSaveUserPolicy", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.batchSaveUserPolicy", bytes);
  }
}

void CacheServiceProcessor::process_saveProductCInstallPack(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveProductCInstallPack", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveProductCInstallPack");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveProductCInstallPack");
  }

  CacheService_saveProductCInstallPack_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveProductCInstallPack", bytes);
  }

  CacheService_saveProductCInstallPack_result result;
  try {
    iface_->saveProductCInstallPack(result.success, args.maxCode, args.minCode, args.cInstallPackCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveProductCInstallPack");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveProductCInstallPack", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveProductCInstallPack");
  }

  oprot->writeMessageBegin("saveProductCInstallPack", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveProductCInstallPack", bytes);
  }
}

void CacheServiceProcessor::process_updateProductCInstallPack(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateProductCInstallPack", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateProductCInstallPack");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateProductCInstallPack");
  }

  CacheService_updateProductCInstallPack_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateProductCInstallPack", bytes);
  }

  CacheService_updateProductCInstallPack_result result;
  try {
    iface_->updateProductCInstallPack(result.success, args.maxCode, args.minCode, args.cInstallPackCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateProductCInstallPack");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateProductCInstallPack", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateProductCInstallPack");
  }

  oprot->writeMessageBegin("updateProductCInstallPack", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateProductCInstallPack", bytes);
  }
}

void CacheServiceProcessor::process_updateProductCInstallPackByField(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateProductCInstallPackByField", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateProductCInstallPackByField");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateProductCInstallPackByField");
  }

  CacheService_updateProductCInstallPackByField_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateProductCInstallPackByField", bytes);
  }

  CacheService_updateProductCInstallPackByField_result result;
  try {
    iface_->updateProductCInstallPackByField(result.success, args.maxCode, args.minCode, args.cInstallPackId, args.fieldValueMap);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateProductCInstallPackByField");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateProductCInstallPackByField", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateProductCInstallPackByField");
  }

  oprot->writeMessageBegin("updateProductCInstallPackByField", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateProductCInstallPackByField", bytes);
  }
}

void CacheServiceProcessor::process_queryProductCInstallPackById(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryProductCInstallPackById", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryProductCInstallPackById");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryProductCInstallPackById");
  }

  CacheService_queryProductCInstallPackById_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryProductCInstallPackById", bytes);
  }

  CacheService_queryProductCInstallPackById_result result;
  try {
    iface_->queryProductCInstallPackById(result.success, args.maxCode, args.minCode, args.cInstallPackId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryProductCInstallPackById");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryProductCInstallPackById", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryProductCInstallPackById");
  }

  oprot->writeMessageBegin("queryProductCInstallPackById", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryProductCInstallPackById", bytes);
  }
}

void CacheServiceProcessor::process_deleteProductCInstallPackById(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteProductCInstallPackById", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteProductCInstallPackById");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteProductCInstallPackById");
  }

  CacheService_deleteProductCInstallPackById_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteProductCInstallPackById", bytes);
  }

  CacheService_deleteProductCInstallPackById_result result;
  try {
    iface_->deleteProductCInstallPackById(result.success, args.maxCode, args.minCode, args.cInstallPackId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteProductCInstallPackById");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteProductCInstallPackById", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteProductCInstallPackById");
  }

  oprot->writeMessageBegin("deleteProductCInstallPackById", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteProductCInstallPackById", bytes);
  }
}

void CacheServiceProcessor::process_savePolicy(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.savePolicy", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.savePolicy");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.savePolicy");
  }

  CacheService_savePolicy_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.savePolicy", bytes);
  }

  CacheService_savePolicy_result result;
  try {
    iface_->savePolicy(result.success, args.maxCode, args.minCode, args.policyCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.savePolicy");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("savePolicy", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.savePolicy");
  }

  oprot->writeMessageBegin("savePolicy", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.savePolicy", bytes);
  }
}

void CacheServiceProcessor::process_updatePolicy(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updatePolicy", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updatePolicy");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updatePolicy");
  }

  CacheService_updatePolicy_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updatePolicy", bytes);
  }

  CacheService_updatePolicy_result result;
  try {
    iface_->updatePolicy(result.success, args.maxCode, args.minCode, args.policyCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updatePolicy");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updatePolicy", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updatePolicy");
  }

  oprot->writeMessageBegin("updatePolicy", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updatePolicy", bytes);
  }
}

void CacheServiceProcessor::process_updatePolicyByField(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updatePolicyByField", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updatePolicyByField");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updatePolicyByField");
  }

  CacheService_updatePolicyByField_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updatePolicyByField", bytes);
  }

  CacheService_updatePolicyByField_result result;
  try {
    iface_->updatePolicyByField(result.success, args.maxCode, args.minCode, args.policyId, args.fieldValueMap);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updatePolicyByField");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updatePolicyByField", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updatePolicyByField");
  }

  oprot->writeMessageBegin("updatePolicyByField", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updatePolicyByField", bytes);
  }
}

void CacheServiceProcessor::process_queryPolicyByPolicyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryPolicyByPolicyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryPolicyByPolicyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryPolicyByPolicyId");
  }

  CacheService_queryPolicyByPolicyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryPolicyByPolicyId", bytes);
  }

  CacheService_queryPolicyByPolicyId_result result;
  try {
    iface_->queryPolicyByPolicyId(result.success, args.maxCode, args.minCode, args.policyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryPolicyByPolicyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryPolicyByPolicyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryPolicyByPolicyId");
  }

  oprot->writeMessageBegin("queryPolicyByPolicyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryPolicyByPolicyId", bytes);
  }
}

void CacheServiceProcessor::process_deletePolicyByPolicyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deletePolicyByPolicyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deletePolicyByPolicyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deletePolicyByPolicyId");
  }

  CacheService_deletePolicyByPolicyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deletePolicyByPolicyId", bytes);
  }

  CacheService_deletePolicyByPolicyId_result result;
  try {
    iface_->deletePolicyByPolicyId(result.success, args.maxCode, args.minCode, args.policyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deletePolicyByPolicyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deletePolicyByPolicyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deletePolicyByPolicyId");
  }

  oprot->writeMessageBegin("deletePolicyByPolicyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deletePolicyByPolicyId", bytes);
  }
}

void CacheServiceProcessor::process_saveIPMAC2DevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveIPMAC2DevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveIPMAC2DevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveIPMAC2DevOnlyId");
  }

  CacheService_saveIPMAC2DevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveIPMAC2DevOnlyId", bytes);
  }

  CacheService_saveIPMAC2DevOnlyId_result result;
  try {
    iface_->saveIPMAC2DevOnlyId(result.success, args.maxCode, args.minCode, args.ip, args.mac, args.devOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveIPMAC2DevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveIPMAC2DevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveIPMAC2DevOnlyId");
  }

  oprot->writeMessageBegin("saveIPMAC2DevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveIPMAC2DevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_updateIPMAC2DevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateIPMAC2DevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateIPMAC2DevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateIPMAC2DevOnlyId");
  }

  CacheService_updateIPMAC2DevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateIPMAC2DevOnlyId", bytes);
  }

  CacheService_updateIPMAC2DevOnlyId_result result;
  try {
    iface_->updateIPMAC2DevOnlyId(result.success, args.maxCode, args.minCode, args.ip, args.mac, args.devOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateIPMAC2DevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateIPMAC2DevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateIPMAC2DevOnlyId");
  }

  oprot->writeMessageBegin("updateIPMAC2DevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateIPMAC2DevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_queryIPMAC2DevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryIPMAC2DevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryIPMAC2DevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryIPMAC2DevOnlyId");
  }

  CacheService_queryIPMAC2DevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryIPMAC2DevOnlyId", bytes);
  }

  CacheService_queryIPMAC2DevOnlyId_result result;
  try {
    iface_->queryIPMAC2DevOnlyId(result.success, args.maxCode, args.minCode, args.ip, args.mac);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryIPMAC2DevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryIPMAC2DevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryIPMAC2DevOnlyId");
  }

  oprot->writeMessageBegin("queryIPMAC2DevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryIPMAC2DevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_deleteIPMAC2DevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteIPMAC2DevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteIPMAC2DevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteIPMAC2DevOnlyId");
  }

  CacheService_deleteIPMAC2DevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteIPMAC2DevOnlyId", bytes);
  }

  CacheService_deleteIPMAC2DevOnlyId_result result;
  try {
    iface_->deleteIPMAC2DevOnlyId(result.success, args.maxCode, args.minCode, args.ip, args.mac);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteIPMAC2DevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteIPMAC2DevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteIPMAC2DevOnlyId");
  }

  oprot->writeMessageBegin("deleteIPMAC2DevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteIPMAC2DevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_saveIP2DevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveIP2DevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveIP2DevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveIP2DevOnlyId");
  }

  CacheService_saveIP2DevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveIP2DevOnlyId", bytes);
  }

  CacheService_saveIP2DevOnlyId_result result;
  try {
    iface_->saveIP2DevOnlyId(result.success, args.maxCode, args.minCode, args.ip, args.devOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveIP2DevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveIP2DevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveIP2DevOnlyId");
  }

  oprot->writeMessageBegin("saveIP2DevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveIP2DevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_updateIP2DevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateIP2DevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateIP2DevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateIP2DevOnlyId");
  }

  CacheService_updateIP2DevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateIP2DevOnlyId", bytes);
  }

  CacheService_updateIP2DevOnlyId_result result;
  try {
    iface_->updateIP2DevOnlyId(result.success, args.maxCode, args.minCode, args.ip, args.devOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateIP2DevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateIP2DevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateIP2DevOnlyId");
  }

  oprot->writeMessageBegin("updateIP2DevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateIP2DevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_queryIP2DevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryIP2DevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryIP2DevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryIP2DevOnlyId");
  }

  CacheService_queryIP2DevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryIP2DevOnlyId", bytes);
  }

  CacheService_queryIP2DevOnlyId_result result;
  try {
    iface_->queryIP2DevOnlyId(result.success, args.maxCode, args.minCode, args.ip);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryIP2DevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryIP2DevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryIP2DevOnlyId");
  }

  oprot->writeMessageBegin("queryIP2DevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryIP2DevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_deleteIP2DevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteIP2DevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteIP2DevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteIP2DevOnlyId");
  }

  CacheService_deleteIP2DevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteIP2DevOnlyId", bytes);
  }

  CacheService_deleteIP2DevOnlyId_result result;
  try {
    iface_->deleteIP2DevOnlyId(result.success, args.maxCode, args.minCode, args.ip);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteIP2DevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteIP2DevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteIP2DevOnlyId");
  }

  oprot->writeMessageBegin("deleteIP2DevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteIP2DevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_saveProductCUpgradePack(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveProductCUpgradePack", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveProductCUpgradePack");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveProductCUpgradePack");
  }

  CacheService_saveProductCUpgradePack_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveProductCUpgradePack", bytes);
  }

  CacheService_saveProductCUpgradePack_result result;
  try {
    iface_->saveProductCUpgradePack(result.success, args.maxCode, args.minCode, args.cUpgradePackCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveProductCUpgradePack");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveProductCUpgradePack", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveProductCUpgradePack");
  }

  oprot->writeMessageBegin("saveProductCUpgradePack", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveProductCUpgradePack", bytes);
  }
}

void CacheServiceProcessor::process_updateProductCUpgradePack(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateProductCUpgradePack", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateProductCUpgradePack");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateProductCUpgradePack");
  }

  CacheService_updateProductCUpgradePack_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateProductCUpgradePack", bytes);
  }

  CacheService_updateProductCUpgradePack_result result;
  try {
    iface_->updateProductCUpgradePack(result.success, args.maxCode, args.minCode, args.cUpgradePackCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateProductCUpgradePack");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateProductCUpgradePack", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateProductCUpgradePack");
  }

  oprot->writeMessageBegin("updateProductCUpgradePack", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateProductCUpgradePack", bytes);
  }
}

void CacheServiceProcessor::process_updateProductCUpgradePackByField(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateProductCUpgradePackByField", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateProductCUpgradePackByField");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateProductCUpgradePackByField");
  }

  CacheService_updateProductCUpgradePackByField_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateProductCUpgradePackByField", bytes);
  }

  CacheService_updateProductCUpgradePackByField_result result;
  try {
    iface_->updateProductCUpgradePackByField(result.success, args.maxCode, args.minCode, args.cUpgradePackId, args.fieldValueMap);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateProductCUpgradePackByField");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateProductCUpgradePackByField", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateProductCUpgradePackByField");
  }

  oprot->writeMessageBegin("updateProductCUpgradePackByField", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateProductCUpgradePackByField", bytes);
  }
}

void CacheServiceProcessor::process_queryProductCUpgradePackById(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryProductCUpgradePackById", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryProductCUpgradePackById");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryProductCUpgradePackById");
  }

  CacheService_queryProductCUpgradePackById_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryProductCUpgradePackById", bytes);
  }

  CacheService_queryProductCUpgradePackById_result result;
  try {
    iface_->queryProductCUpgradePackById(result.success, args.maxCode, args.minCode, args.cUpgradePackId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryProductCUpgradePackById");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryProductCUpgradePackById", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryProductCUpgradePackById");
  }

  oprot->writeMessageBegin("queryProductCUpgradePackById", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryProductCUpgradePackById", bytes);
  }
}

void CacheServiceProcessor::process_deleteProductCUpgradePackById(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteProductCUpgradePackById", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteProductCUpgradePackById");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteProductCUpgradePackById");
  }

  CacheService_deleteProductCUpgradePackById_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteProductCUpgradePackById", bytes);
  }

  CacheService_deleteProductCUpgradePackById_result result;
  try {
    iface_->deleteProductCUpgradePackById(result.success, args.maxCode, args.minCode, args.cUpgradePackId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteProductCUpgradePackById");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteProductCUpgradePackById", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteProductCUpgradePackById");
  }

  oprot->writeMessageBegin("deleteProductCUpgradePackById", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteProductCUpgradePackById", bytes);
  }
}

void CacheServiceProcessor::process_saveAccount2UserOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveAccount2UserOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveAccount2UserOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveAccount2UserOnlyId");
  }

  CacheService_saveAccount2UserOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveAccount2UserOnlyId", bytes);
  }

  CacheService_saveAccount2UserOnlyId_result result;
  try {
    iface_->saveAccount2UserOnlyId(result.success, args.maxCode, args.minCode, args.account, args.userOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveAccount2UserOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveAccount2UserOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveAccount2UserOnlyId");
  }

  oprot->writeMessageBegin("saveAccount2UserOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveAccount2UserOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_updateAccount2UserOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateAccount2UserOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateAccount2UserOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateAccount2UserOnlyId");
  }

  CacheService_updateAccount2UserOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateAccount2UserOnlyId", bytes);
  }

  CacheService_updateAccount2UserOnlyId_result result;
  try {
    iface_->updateAccount2UserOnlyId(result.success, args.maxCode, args.minCode, args.account, args.userOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateAccount2UserOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateAccount2UserOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateAccount2UserOnlyId");
  }

  oprot->writeMessageBegin("updateAccount2UserOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateAccount2UserOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_queryAccount2UserOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryAccount2UserOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryAccount2UserOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryAccount2UserOnlyId");
  }

  CacheService_queryAccount2UserOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryAccount2UserOnlyId", bytes);
  }

  CacheService_queryAccount2UserOnlyId_result result;
  try {
    iface_->queryAccount2UserOnlyId(result.success, args.maxCode, args.minCode, args.account);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryAccount2UserOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryAccount2UserOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryAccount2UserOnlyId");
  }

  oprot->writeMessageBegin("queryAccount2UserOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryAccount2UserOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_deleteAccount2UserOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteAccount2UserOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteAccount2UserOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteAccount2UserOnlyId");
  }

  CacheService_deleteAccount2UserOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteAccount2UserOnlyId", bytes);
  }

  CacheService_deleteAccount2UserOnlyId_result result;
  try {
    iface_->deleteAccount2UserOnlyId(result.success, args.maxCode, args.minCode, args.account);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteAccount2UserOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteAccount2UserOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteAccount2UserOnlyId");
  }

  oprot->writeMessageBegin("deleteAccount2UserOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteAccount2UserOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_batchSaveAccount2UserOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.batchSaveAccount2UserOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.batchSaveAccount2UserOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.batchSaveAccount2UserOnlyId");
  }

  CacheService_batchSaveAccount2UserOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.batchSaveAccount2UserOnlyId", bytes);
  }

  CacheService_batchSaveAccount2UserOnlyId_result result;
  try {
    iface_->batchSaveAccount2UserOnlyId(result.success, args.maxCode, args.minCode, args.userCacheList);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.batchSaveAccount2UserOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("batchSaveAccount2UserOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.batchSaveAccount2UserOnlyId");
  }

  oprot->writeMessageBegin("batchSaveAccount2UserOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.batchSaveAccount2UserOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_savePtp(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.savePtp", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.savePtp");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.savePtp");
  }

  CacheService_savePtp_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.savePtp", bytes);
  }

  CacheService_savePtp_result result;
  try {
    iface_->savePtp(result.success, args.maxCode, args.minCode, args.uuid, args.ptpResult);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.savePtp");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("savePtp", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.savePtp");
  }

  oprot->writeMessageBegin("savePtp", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.savePtp", bytes);
  }
}

void CacheServiceProcessor::process_updatePtp(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updatePtp", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updatePtp");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updatePtp");
  }

  CacheService_updatePtp_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updatePtp", bytes);
  }

  CacheService_updatePtp_result result;
  try {
    iface_->updatePtp(result.success, args.maxCode, args.minCode, args.uuid, args.ptpResult);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updatePtp");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updatePtp", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updatePtp");
  }

  oprot->writeMessageBegin("updatePtp", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updatePtp", bytes);
  }
}

void CacheServiceProcessor::process_queryPtp(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryPtp", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryPtp");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryPtp");
  }

  CacheService_queryPtp_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryPtp", bytes);
  }

  CacheService_queryPtp_result result;
  try {
    iface_->queryPtp(result.success, args.maxCode, args.minCode, args.uuid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryPtp");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryPtp", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryPtp");
  }

  oprot->writeMessageBegin("queryPtp", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryPtp", bytes);
  }
}

void CacheServiceProcessor::process_deletePtp(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deletePtp", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deletePtp");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deletePtp");
  }

  CacheService_deletePtp_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deletePtp", bytes);
  }

  CacheService_deletePtp_result result;
  try {
    iface_->deletePtp(result.success, args.maxCode, args.minCode, args.uuid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deletePtp");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deletePtp", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deletePtp");
  }

  oprot->writeMessageBegin("deletePtp", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deletePtp", bytes);
  }
}

void CacheServiceProcessor::process_saveSensitive(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveSensitive", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveSensitive");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveSensitive");
  }

  CacheService_saveSensitive_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveSensitive", bytes);
  }

  CacheService_saveSensitive_result result;
  try {
    iface_->saveSensitive(result.success, args.maxCode, args.minCode, args.sensitiveCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveSensitive");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveSensitive", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveSensitive");
  }

  oprot->writeMessageBegin("saveSensitive", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveSensitive", bytes);
  }
}

void CacheServiceProcessor::process_updateSensitive(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateSensitive", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateSensitive");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateSensitive");
  }

  CacheService_updateSensitive_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateSensitive", bytes);
  }

  CacheService_updateSensitive_result result;
  try {
    iface_->updateSensitive(result.success, args.maxCode, args.minCode, args.sensitiveCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateSensitive");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateSensitive", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateSensitive");
  }

  oprot->writeMessageBegin("updateSensitive", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateSensitive", bytes);
  }
}

void CacheServiceProcessor::process_querySensitive(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.querySensitive", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.querySensitive");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.querySensitive");
  }

  CacheService_querySensitive_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.querySensitive", bytes);
  }

  CacheService_querySensitive_result result;
  try {
    iface_->querySensitive(result.success, args.maxCode, args.minCode, args.name);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.querySensitive");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("querySensitive", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.querySensitive");
  }

  oprot->writeMessageBegin("querySensitive", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.querySensitive", bytes);
  }
}

void CacheServiceProcessor::process_querySensitiveByField(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.querySensitiveByField", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.querySensitiveByField");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.querySensitiveByField");
  }

  CacheService_querySensitiveByField_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.querySensitiveByField", bytes);
  }

  CacheService_querySensitiveByField_result result;
  try {
    iface_->querySensitiveByField(result.success, args.maxCode, args.minCode, args.name, args.fieldKey);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.querySensitiveByField");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("querySensitiveByField", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.querySensitiveByField");
  }

  oprot->writeMessageBegin("querySensitiveByField", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.querySensitiveByField", bytes);
  }
}

void CacheServiceProcessor::process_deleteSensitive(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteSensitive", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteSensitive");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteSensitive");
  }

  CacheService_deleteSensitive_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteSensitive", bytes);
  }

  CacheService_deleteSensitive_result result;
  try {
    iface_->deleteSensitive(result.success, args.maxCode, args.minCode, args.name);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteSensitive");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteSensitive", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteSensitive");
  }

  oprot->writeMessageBegin("deleteSensitive", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteSensitive", bytes);
  }
}

void CacheServiceProcessor::process_saveDeviceMsgDigest(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveDeviceMsgDigest", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveDeviceMsgDigest");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveDeviceMsgDigest");
  }

  CacheService_saveDeviceMsgDigest_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveDeviceMsgDigest", bytes);
  }

  CacheService_saveDeviceMsgDigest_result result;
  try {
    iface_->saveDeviceMsgDigest(result.success, args.maxCode, args.minCode, args.devOnlyId, args.fieldValueMap);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveDeviceMsgDigest");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveDeviceMsgDigest", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveDeviceMsgDigest");
  }

  oprot->writeMessageBegin("saveDeviceMsgDigest", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveDeviceMsgDigest", bytes);
  }
}

void CacheServiceProcessor::process_saveDeviceMsgDigestWithDevOnlyIdAndMsgType(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveDeviceMsgDigestWithDevOnlyIdAndMsgType", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveDeviceMsgDigestWithDevOnlyIdAndMsgType");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveDeviceMsgDigestWithDevOnlyIdAndMsgType");
  }

  CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgType_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveDeviceMsgDigestWithDevOnlyIdAndMsgType", bytes);
  }

  CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgType_result result;
  try {
    iface_->saveDeviceMsgDigestWithDevOnlyIdAndMsgType(result.success, args.maxCode, args.minCode, args.devOnlyId, args.msgType, args.msgIdList);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveDeviceMsgDigestWithDevOnlyIdAndMsgType");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveDeviceMsgDigestWithDevOnlyIdAndMsgType", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveDeviceMsgDigestWithDevOnlyIdAndMsgType");
  }

  oprot->writeMessageBegin("saveDeviceMsgDigestWithDevOnlyIdAndMsgType", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveDeviceMsgDigestWithDevOnlyIdAndMsgType", bytes);
  }
}

void CacheServiceProcessor::process_saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId");
  }

  CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId", bytes);
  }

  CacheService_saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId_result result;
  try {
    iface_->saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId(result.success, args.maxCode, args.minCode, args.devOnlyId, args.msgType, args.msgId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId");
  }

  oprot->writeMessageBegin("saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveDeviceMsgDigestWithDevOnlyIdAndMsgTypeAndMsgId", bytes);
  }
}

void CacheServiceProcessor::process_deleteDeviceMsgDigestByDevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteDeviceMsgDigestByDevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteDeviceMsgDigestByDevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteDeviceMsgDigestByDevOnlyId");
  }

  CacheService_deleteDeviceMsgDigestByDevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteDeviceMsgDigestByDevOnlyId", bytes);
  }

  CacheService_deleteDeviceMsgDigestByDevOnlyId_result result;
  try {
    iface_->deleteDeviceMsgDigestByDevOnlyId(result.success, args.maxCode, args.minCode, args.devOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteDeviceMsgDigestByDevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteDeviceMsgDigestByDevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteDeviceMsgDigestByDevOnlyId");
  }

  oprot->writeMessageBegin("deleteDeviceMsgDigestByDevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteDeviceMsgDigestByDevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_deleteDeviceMsgDigestByDevOnlyIdAndMsgType(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteDeviceMsgDigestByDevOnlyIdAndMsgType", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteDeviceMsgDigestByDevOnlyIdAndMsgType");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteDeviceMsgDigestByDevOnlyIdAndMsgType");
  }

  CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgType_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteDeviceMsgDigestByDevOnlyIdAndMsgType", bytes);
  }

  CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgType_result result;
  try {
    iface_->deleteDeviceMsgDigestByDevOnlyIdAndMsgType(result.success, args.maxCode, args.minCode, args.devOnlyId, args.msgType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteDeviceMsgDigestByDevOnlyIdAndMsgType");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteDeviceMsgDigestByDevOnlyIdAndMsgType", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteDeviceMsgDigestByDevOnlyIdAndMsgType");
  }

  oprot->writeMessageBegin("deleteDeviceMsgDigestByDevOnlyIdAndMsgType", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteDeviceMsgDigestByDevOnlyIdAndMsgType", bytes);
  }
}

void CacheServiceProcessor::process_deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId");
  }

  CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId", bytes);
  }

  CacheService_deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId_result result;
  try {
    iface_->deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId(result.success, args.maxCode, args.minCode, args.devOnlyId, args.msgType, args.msgId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId");
  }

  oprot->writeMessageBegin("deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteDeviceMsgDigestByDevOnlyIdAndMsgTypeAndMsgId", bytes);
  }
}

void CacheServiceProcessor::process_updateDeviceMsgDigest(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateDeviceMsgDigest", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateDeviceMsgDigest");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateDeviceMsgDigest");
  }

  CacheService_updateDeviceMsgDigest_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateDeviceMsgDigest", bytes);
  }

  CacheService_updateDeviceMsgDigest_result result;
  try {
    iface_->updateDeviceMsgDigest(result.success, args.maxCode, args.minCode, args.devOnlyId, args.msgType, args.msgId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateDeviceMsgDigest");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateDeviceMsgDigest", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateDeviceMsgDigest");
  }

  oprot->writeMessageBegin("updateDeviceMsgDigest", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateDeviceMsgDigest", bytes);
  }
}

void CacheServiceProcessor::process_queryDeviceMsgDigestByDevOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryDeviceMsgDigestByDevOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryDeviceMsgDigestByDevOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryDeviceMsgDigestByDevOnlyId");
  }

  CacheService_queryDeviceMsgDigestByDevOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryDeviceMsgDigestByDevOnlyId", bytes);
  }

  CacheService_queryDeviceMsgDigestByDevOnlyId_result result;
  try {
    iface_->queryDeviceMsgDigestByDevOnlyId(result.success, args.maxCode, args.minCode, args.devOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryDeviceMsgDigestByDevOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryDeviceMsgDigestByDevOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryDeviceMsgDigestByDevOnlyId");
  }

  oprot->writeMessageBegin("queryDeviceMsgDigestByDevOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryDeviceMsgDigestByDevOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_queryDeviceMsgDigestByDevIdAndMsgType(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryDeviceMsgDigestByDevIdAndMsgType", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryDeviceMsgDigestByDevIdAndMsgType");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryDeviceMsgDigestByDevIdAndMsgType");
  }

  CacheService_queryDeviceMsgDigestByDevIdAndMsgType_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryDeviceMsgDigestByDevIdAndMsgType", bytes);
  }

  CacheService_queryDeviceMsgDigestByDevIdAndMsgType_result result;
  try {
    iface_->queryDeviceMsgDigestByDevIdAndMsgType(result.success, args.maxCode, args.minCode, args.devOnlyId, args.msgType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryDeviceMsgDigestByDevIdAndMsgType");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryDeviceMsgDigestByDevIdAndMsgType", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryDeviceMsgDigestByDevIdAndMsgType");
  }

  oprot->writeMessageBegin("queryDeviceMsgDigestByDevIdAndMsgType", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryDeviceMsgDigestByDevIdAndMsgType", bytes);
  }
}

void CacheServiceProcessor::process_saveUserMsgDigest(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveUserMsgDigest", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveUserMsgDigest");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveUserMsgDigest");
  }

  CacheService_saveUserMsgDigest_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveUserMsgDigest", bytes);
  }

  CacheService_saveUserMsgDigest_result result;
  try {
    iface_->saveUserMsgDigest(result.success, args.maxCode, args.minCode, args.userOnlyId, args.fieldValueMap);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveUserMsgDigest");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveUserMsgDigest", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveUserMsgDigest");
  }

  oprot->writeMessageBegin("saveUserMsgDigest", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveUserMsgDigest", bytes);
  }
}

void CacheServiceProcessor::process_saveUserMsgDigestWithUserOnlyIdAndMsgType(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveUserMsgDigestWithUserOnlyIdAndMsgType", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveUserMsgDigestWithUserOnlyIdAndMsgType");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveUserMsgDigestWithUserOnlyIdAndMsgType");
  }

  CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgType_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveUserMsgDigestWithUserOnlyIdAndMsgType", bytes);
  }

  CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgType_result result;
  try {
    iface_->saveUserMsgDigestWithUserOnlyIdAndMsgType(result.success, args.maxCode, args.minCode, args.userOnlyId, args.msgType, args.msgIdList);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveUserMsgDigestWithUserOnlyIdAndMsgType");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveUserMsgDigestWithUserOnlyIdAndMsgType", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveUserMsgDigestWithUserOnlyIdAndMsgType");
  }

  oprot->writeMessageBegin("saveUserMsgDigestWithUserOnlyIdAndMsgType", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveUserMsgDigestWithUserOnlyIdAndMsgType", bytes);
  }
}

void CacheServiceProcessor::process_saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId");
  }

  CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId", bytes);
  }

  CacheService_saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId_result result;
  try {
    iface_->saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId(result.success, args.maxCode, args.minCode, args.userOnlyId, args.msgType, args.msgId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId");
  }

  oprot->writeMessageBegin("saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveUserMsgDigestWithUserOnlyIdAndMsgTypeAndMsgId", bytes);
  }
}

void CacheServiceProcessor::process_deleteUserMsgDigestByUserOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteUserMsgDigestByUserOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteUserMsgDigestByUserOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteUserMsgDigestByUserOnlyId");
  }

  CacheService_deleteUserMsgDigestByUserOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteUserMsgDigestByUserOnlyId", bytes);
  }

  CacheService_deleteUserMsgDigestByUserOnlyId_result result;
  try {
    iface_->deleteUserMsgDigestByUserOnlyId(result.success, args.maxCode, args.minCode, args.userOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteUserMsgDigestByUserOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteUserMsgDigestByUserOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteUserMsgDigestByUserOnlyId");
  }

  oprot->writeMessageBegin("deleteUserMsgDigestByUserOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteUserMsgDigestByUserOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_deleteUserMsgDigestByUserOnlyIdAndMsgType(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteUserMsgDigestByUserOnlyIdAndMsgType", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteUserMsgDigestByUserOnlyIdAndMsgType");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteUserMsgDigestByUserOnlyIdAndMsgType");
  }

  CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgType_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteUserMsgDigestByUserOnlyIdAndMsgType", bytes);
  }

  CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgType_result result;
  try {
    iface_->deleteUserMsgDigestByUserOnlyIdAndMsgType(result.success, args.maxCode, args.minCode, args.userOnlyId, args.msgType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteUserMsgDigestByUserOnlyIdAndMsgType");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteUserMsgDigestByUserOnlyIdAndMsgType", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteUserMsgDigestByUserOnlyIdAndMsgType");
  }

  oprot->writeMessageBegin("deleteUserMsgDigestByUserOnlyIdAndMsgType", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteUserMsgDigestByUserOnlyIdAndMsgType", bytes);
  }
}

void CacheServiceProcessor::process_deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId");
  }

  CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId", bytes);
  }

  CacheService_deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId_result result;
  try {
    iface_->deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId(result.success, args.maxCode, args.minCode, args.userOnlyId, args.msgType, args.msgId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId");
  }

  oprot->writeMessageBegin("deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteUserMsgDigestByUserOnlyIdAndMsgTypeAndMsgId", bytes);
  }
}

void CacheServiceProcessor::process_updateUserMsgDigest(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateUserMsgDigest", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateUserMsgDigest");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateUserMsgDigest");
  }

  CacheService_updateUserMsgDigest_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateUserMsgDigest", bytes);
  }

  CacheService_updateUserMsgDigest_result result;
  try {
    iface_->updateUserMsgDigest(result.success, args.maxCode, args.minCode, args.userOnlyId, args.msgType, args.msgId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateUserMsgDigest");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateUserMsgDigest", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateUserMsgDigest");
  }

  oprot->writeMessageBegin("updateUserMsgDigest", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateUserMsgDigest", bytes);
  }
}

void CacheServiceProcessor::process_queryUserMsgDigestByUserOnlyId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryUserMsgDigestByUserOnlyId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryUserMsgDigestByUserOnlyId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryUserMsgDigestByUserOnlyId");
  }

  CacheService_queryUserMsgDigestByUserOnlyId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryUserMsgDigestByUserOnlyId", bytes);
  }

  CacheService_queryUserMsgDigestByUserOnlyId_result result;
  try {
    iface_->queryUserMsgDigestByUserOnlyId(result.success, args.maxCode, args.minCode, args.userOnlyId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryUserMsgDigestByUserOnlyId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryUserMsgDigestByUserOnlyId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryUserMsgDigestByUserOnlyId");
  }

  oprot->writeMessageBegin("queryUserMsgDigestByUserOnlyId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryUserMsgDigestByUserOnlyId", bytes);
  }
}

void CacheServiceProcessor::process_queryDeviceMsgDigestByUserOnlyIdAndMsgType(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryDeviceMsgDigestByUserOnlyIdAndMsgType", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryDeviceMsgDigestByUserOnlyIdAndMsgType");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryDeviceMsgDigestByUserOnlyIdAndMsgType");
  }

  CacheService_queryDeviceMsgDigestByUserOnlyIdAndMsgType_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryDeviceMsgDigestByUserOnlyIdAndMsgType", bytes);
  }

  CacheService_queryDeviceMsgDigestByUserOnlyIdAndMsgType_result result;
  try {
    iface_->queryDeviceMsgDigestByUserOnlyIdAndMsgType(result.success, args.maxCode, args.minCode, args.userOnlyId, args.msgType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryDeviceMsgDigestByUserOnlyIdAndMsgType");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryDeviceMsgDigestByUserOnlyIdAndMsgType", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryDeviceMsgDigestByUserOnlyIdAndMsgType");
  }

  oprot->writeMessageBegin("queryDeviceMsgDigestByUserOnlyIdAndMsgType", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryDeviceMsgDigestByUserOnlyIdAndMsgType", bytes);
  }
}

void CacheServiceProcessor::process_saveMsg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveMsg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveMsg");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveMsg");
  }

  CacheService_saveMsg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveMsg", bytes);
  }

  CacheService_saveMsg_result result;
  try {
    iface_->saveMsg(result.success, args.maxCode, args.minCode, args.msgCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveMsg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveMsg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveMsg");
  }

  oprot->writeMessageBegin("saveMsg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveMsg", bytes);
  }
}

void CacheServiceProcessor::process_deleteMsg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteMsg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteMsg");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteMsg");
  }

  CacheService_deleteMsg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteMsg", bytes);
  }

  CacheService_deleteMsg_result result;
  try {
    iface_->deleteMsg(result.success, args.maxCode, args.minCode, args.msgId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteMsg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteMsg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteMsg");
  }

  oprot->writeMessageBegin("deleteMsg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteMsg", bytes);
  }
}

void CacheServiceProcessor::process_queryMsg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryMsg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryMsg");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryMsg");
  }

  CacheService_queryMsg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryMsg", bytes);
  }

  CacheService_queryMsg_result result;
  try {
    iface_->queryMsg(result.success, args.maxCode, args.minCode, args.msgId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryMsg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryMsg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryMsg");
  }

  oprot->writeMessageBegin("queryMsg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryMsg", bytes);
  }
}

void CacheServiceProcessor::process_saveToken(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveToken", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveToken");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveToken");
  }

  CacheService_saveToken_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveToken", bytes);
  }

  CacheService_saveToken_result result;
  try {
    iface_->saveToken(result.success, args.maxCode, args.minCode, args.tokenCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveToken");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveToken", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveToken");
  }

  oprot->writeMessageBegin("saveToken", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveToken", bytes);
  }
}

void CacheServiceProcessor::process_deleteTokenByAppId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteTokenByAppId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteTokenByAppId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteTokenByAppId");
  }

  CacheService_deleteTokenByAppId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteTokenByAppId", bytes);
  }

  CacheService_deleteTokenByAppId_result result;
  try {
    iface_->deleteTokenByAppId(result.success, args.maxCode, args.minCode, args.appId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteTokenByAppId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteTokenByAppId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteTokenByAppId");
  }

  oprot->writeMessageBegin("deleteTokenByAppId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteTokenByAppId", bytes);
  }
}

void CacheServiceProcessor::process_updateTokenByAppId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateTokenByAppId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateTokenByAppId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateTokenByAppId");
  }

  CacheService_updateTokenByAppId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateTokenByAppId", bytes);
  }

  CacheService_updateTokenByAppId_result result;
  try {
    iface_->updateTokenByAppId(result.success, args.maxCode, args.minCode, args.tokenCache);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateTokenByAppId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateTokenByAppId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateTokenByAppId");
  }

  oprot->writeMessageBegin("updateTokenByAppId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateTokenByAppId", bytes);
  }
}

void CacheServiceProcessor::process_queryTokenByAppId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.queryTokenByAppId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.queryTokenByAppId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.queryTokenByAppId");
  }

  CacheService_queryTokenByAppId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.queryTokenByAppId", bytes);
  }

  CacheService_queryTokenByAppId_result result;
  try {
    iface_->queryTokenByAppId(result.success, args.maxCode, args.minCode, args.appId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.queryTokenByAppId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("queryTokenByAppId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.queryTokenByAppId");
  }

  oprot->writeMessageBegin("queryTokenByAppId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.queryTokenByAppId", bytes);
  }
}

void CacheServiceProcessor::process_saveSession(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveSession", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveSession");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveSession");
  }

  CacheService_saveSession_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveSession", bytes);
  }

  CacheService_saveSession_result result;
  try {
    iface_->saveSession(result.success, args.maxCode, args.minCode, args.sId, args.hashMap);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveSession");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveSession", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveSession");
  }

  oprot->writeMessageBegin("saveSession", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveSession", bytes);
  }
}

void CacheServiceProcessor::process_saveSessionByDetail(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.saveSessionByDetail", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.saveSessionByDetail");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.saveSessionByDetail");
  }

  CacheService_saveSessionByDetail_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.saveSessionByDetail", bytes);
  }

  CacheService_saveSessionByDetail_result result;
  try {
    iface_->saveSessionByDetail(result.success, args.maxCode, args.minCode, args.sId, args.key, args.value);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.saveSessionByDetail");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("saveSessionByDetail", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.saveSessionByDetail");
  }

  oprot->writeMessageBegin("saveSessionByDetail", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.saveSessionByDetail", bytes);
  }
}

void CacheServiceProcessor::process_deleteSession(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteSession", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteSession");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteSession");
  }

  CacheService_deleteSession_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteSession", bytes);
  }

  CacheService_deleteSession_result result;
  try {
    iface_->deleteSession(result.success, args.maxCode, args.minCode, args.sId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteSession");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteSession", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteSession");
  }

  oprot->writeMessageBegin("deleteSession", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteSession", bytes);
  }
}

void CacheServiceProcessor::process_deleteSessionByDetail(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.deleteSessionByDetail", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.deleteSessionByDetail");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.deleteSessionByDetail");
  }

  CacheService_deleteSessionByDetail_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.deleteSessionByDetail", bytes);
  }

  CacheService_deleteSessionByDetail_result result;
  try {
    iface_->deleteSessionByDetail(result.success, args.maxCode, args.minCode, args.sId, args.key);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.deleteSessionByDetail");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteSessionByDetail", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.deleteSessionByDetail");
  }

  oprot->writeMessageBegin("deleteSessionByDetail", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.deleteSessionByDetail", bytes);
  }
}

void CacheServiceProcessor::process_updataSessionByDetail(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updataSessionByDetail", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updataSessionByDetail");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updataSessionByDetail");
  }

  CacheService_updataSessionByDetail_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updataSessionByDetail", bytes);
  }

  CacheService_updataSessionByDetail_result result;
  try {
    iface_->updataSessionByDetail(result.success, args.maxCode, args.minCode, args.sId, args.key, args.value);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updataSessionByDetail");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updataSessionByDetail", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updataSessionByDetail");
  }

  oprot->writeMessageBegin("updataSessionByDetail", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updataSessionByDetail", bytes);
  }
}

void CacheServiceProcessor::process_updateSession(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.updateSession", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.updateSession");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.updateSession");
  }

  CacheService_updateSession_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.updateSession", bytes);
  }

  CacheService_updateSession_result result;
  try {
    iface_->updateSession(result.success, args.maxCode, args.minCode, args.sId, args.hashMap);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.updateSession");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("updateSession", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.updateSession");
  }

  oprot->writeMessageBegin("updateSession", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.updateSession", bytes);
  }
}

void CacheServiceProcessor::process_querySessionByDetail(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.querySessionByDetail", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.querySessionByDetail");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.querySessionByDetail");
  }

  CacheService_querySessionByDetail_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.querySessionByDetail", bytes);
  }

  CacheService_querySessionByDetail_result result;
  try {
    iface_->querySessionByDetail(result.success, args.maxCode, args.minCode, args.sId, args.key);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.querySessionByDetail");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("querySessionByDetail", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.querySessionByDetail");
  }

  oprot->writeMessageBegin("querySessionByDetail", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.querySessionByDetail", bytes);
  }
}

void CacheServiceProcessor::process_querySession(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.querySession", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.querySession");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.querySession");
  }

  CacheService_querySession_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.querySession", bytes);
  }

  CacheService_querySession_result result;
  try {
    iface_->querySession(result.success, args.maxCode, args.minCode, args.sId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.querySession");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("querySession", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.querySession");
  }

  oprot->writeMessageBegin("querySession", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.querySession", bytes);
  }
}

void CacheServiceProcessor::process_commonHset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonHset", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonHset");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonHset");
  }

  CacheService_commonHset_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonHset", bytes);
  }

  CacheService_commonHset_result result;
  try {
    iface_->commonHset(result.success, args.maxCode, args.minCode, args.key, args.field, args.value);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonHset");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonHset", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonHset");
  }

  oprot->writeMessageBegin("commonHset", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonHset", bytes);
  }
}

void CacheServiceProcessor::process_commonHmset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonHmset", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonHmset");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonHmset");
  }

  CacheService_commonHmset_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonHmset", bytes);
  }

  CacheService_commonHmset_result result;
  try {
    iface_->commonHmset(result.success, args.maxCode, args.minCode, args.key, args.hashMap);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonHmset");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonHmset", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonHmset");
  }

  oprot->writeMessageBegin("commonHmset", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonHmset", bytes);
  }
}

void CacheServiceProcessor::process_commonHsetnx(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonHsetnx", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonHsetnx");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonHsetnx");
  }

  CacheService_commonHsetnx_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonHsetnx", bytes);
  }

  CacheService_commonHsetnx_result result;
  try {
    iface_->commonHsetnx(result.success, args.maxCode, args.minCode, args.key, args.field, args.value);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonHsetnx");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonHsetnx", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonHsetnx");
  }

  oprot->writeMessageBegin("commonHsetnx", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonHsetnx", bytes);
  }
}

void CacheServiceProcessor::process_commonHdel(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonHdel", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonHdel");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonHdel");
  }

  CacheService_commonHdel_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonHdel", bytes);
  }

  CacheService_commonHdel_result result;
  try {
    iface_->commonHdel(result.success, args.maxCode, args.minCode, args.key, args.fields);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonHdel");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonHdel", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonHdel");
  }

  oprot->writeMessageBegin("commonHdel", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonHdel", bytes);
  }
}

void CacheServiceProcessor::process_commonBatchHget(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonBatchHget", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonBatchHget");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonBatchHget");
  }

  CacheService_commonBatchHget_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonBatchHget", bytes);
  }

  CacheService_commonBatchHget_result result;
  try {
    iface_->commonBatchHget(result.success, args.maxCode, args.minCode, args.keys);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonBatchHget");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonBatchHget", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonBatchHget");
  }

  oprot->writeMessageBegin("commonBatchHget", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonBatchHget", bytes);
  }
}

void CacheServiceProcessor::process_commonHgetAll(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonHgetAll", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonHgetAll");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonHgetAll");
  }

  CacheService_commonHgetAll_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonHgetAll", bytes);
  }

  CacheService_commonHgetAll_result result;
  try {
    iface_->commonHgetAll(result.success, args.maxCode, args.minCode, args.key);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonHgetAll");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonHgetAll", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonHgetAll");
  }

  oprot->writeMessageBegin("commonHgetAll", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonHgetAll", bytes);
  }
}

void CacheServiceProcessor::process_commonHget(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonHget", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonHget");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonHget");
  }

  CacheService_commonHget_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonHget", bytes);
  }

  CacheService_commonHget_result result;
  try {
    iface_->commonHget(result.success, args.maxCode, args.minCode, args.key, args.field);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonHget");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonHget", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonHget");
  }

  oprot->writeMessageBegin("commonHget", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonHget", bytes);
  }
}

void CacheServiceProcessor::process_commonHmget(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonHmget", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonHmget");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonHmget");
  }

  CacheService_commonHmget_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonHmget", bytes);
  }

  CacheService_commonHmget_result result;
  try {
    iface_->commonHmget(result.success, args.maxCode, args.minCode, args.key, args.fields);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonHmget");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonHmget", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonHmget");
  }

  oprot->writeMessageBegin("commonHmget", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonHmget", bytes);
  }
}

void CacheServiceProcessor::process_commonHscan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonHscan", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonHscan");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonHscan");
  }

  CacheService_commonHscan_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonHscan", bytes);
  }

  CacheService_commonHscan_result result;
  try {
    iface_->commonHscan(result.success, args.maxCode, args.minCode, args.key, args.cursor, args.match, args.count);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonHscan");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonHscan", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonHscan");
  }

  oprot->writeMessageBegin("commonHscan", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonHscan", bytes);
  }
}

void CacheServiceProcessor::process_commonHvals(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonHvals", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonHvals");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonHvals");
  }

  CacheService_commonHvals_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonHvals", bytes);
  }

  CacheService_commonHvals_result result;
  try {
    iface_->commonHvals(result.success, args.maxCode, args.minCode, args.key);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonHvals");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonHvals", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonHvals");
  }

  oprot->writeMessageBegin("commonHvals", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonHvals", bytes);
  }
}

void CacheServiceProcessor::process_commonHexists(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonHexists", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonHexists");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonHexists");
  }

  CacheService_commonHexists_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonHexists", bytes);
  }

  CacheService_commonHexists_result result;
  try {
    result.success = iface_->commonHexists(args.maxCode, args.minCode, args.key, args.field);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonHexists");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonHexists", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonHexists");
  }

  oprot->writeMessageBegin("commonHexists", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonHexists", bytes);
  }
}

void CacheServiceProcessor::process_commonHlen(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonHlen", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonHlen");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonHlen");
  }

  CacheService_commonHlen_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonHlen", bytes);
  }

  CacheService_commonHlen_result result;
  try {
    result.success = iface_->commonHlen(args.maxCode, args.minCode, args.key);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonHlen");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonHlen", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonHlen");
  }

  oprot->writeMessageBegin("commonHlen", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonHlen", bytes);
  }
}

void CacheServiceProcessor::process_commonZadd(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonZadd", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonZadd");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonZadd");
  }

  CacheService_commonZadd_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonZadd", bytes);
  }

  CacheService_commonZadd_result result;
  try {
    iface_->commonZadd(result.success, args.maxCode, args.minCode, args.key, args.hashMap, args.options);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonZadd");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonZadd", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonZadd");
  }

  oprot->writeMessageBegin("commonZadd", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonZadd", bytes);
  }
}

void CacheServiceProcessor::process_commonZrem(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonZrem", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonZrem");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonZrem");
  }

  CacheService_commonZrem_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonZrem", bytes);
  }

  CacheService_commonZrem_result result;
  try {
    iface_->commonZrem(result.success, args.maxCode, args.minCode, args.key, args.members);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonZrem");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonZrem", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonZrem");
  }

  oprot->writeMessageBegin("commonZrem", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonZrem", bytes);
  }
}

void CacheServiceProcessor::process_commonZremrangeByScore(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonZremrangeByScore", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonZremrangeByScore");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonZremrangeByScore");
  }

  CacheService_commonZremrangeByScore_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonZremrangeByScore", bytes);
  }

  CacheService_commonZremrangeByScore_result result;
  try {
    iface_->commonZremrangeByScore(result.success, args.maxCode, args.minCode, args.key, args.min, args.max);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonZremrangeByScore");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonZremrangeByScore", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonZremrangeByScore");
  }

  oprot->writeMessageBegin("commonZremrangeByScore", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonZremrangeByScore", bytes);
  }
}

void CacheServiceProcessor::process_commonZremrangeByRank(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonZremrangeByRank", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonZremrangeByRank");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonZremrangeByRank");
  }

  CacheService_commonZremrangeByRank_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonZremrangeByRank", bytes);
  }

  CacheService_commonZremrangeByRank_result result;
  try {
    iface_->commonZremrangeByRank(result.success, args.maxCode, args.minCode, args.key, args.min, args.max);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonZremrangeByRank");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonZremrangeByRank", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonZremrangeByRank");
  }

  oprot->writeMessageBegin("commonZremrangeByRank", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonZremrangeByRank", bytes);
  }
}

void CacheServiceProcessor::process_commonZremrangeByLex(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonZremrangeByLex", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonZremrangeByLex");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonZremrangeByLex");
  }

  CacheService_commonZremrangeByLex_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonZremrangeByLex", bytes);
  }

  CacheService_commonZremrangeByLex_result result;
  try {
    iface_->commonZremrangeByLex(result.success, args.maxCode, args.minCode, args.key, args.min, args.max);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonZremrangeByLex");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonZremrangeByLex", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonZremrangeByLex");
  }

  oprot->writeMessageBegin("commonZremrangeByLex", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonZremrangeByLex", bytes);
  }
}

void CacheServiceProcessor::process_commonZcard(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonZcard", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonZcard");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonZcard");
  }

  CacheService_commonZcard_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonZcard", bytes);
  }

  CacheService_commonZcard_result result;
  try {
    result.success = iface_->commonZcard(args.maxCode, args.minCode, args.key);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonZcard");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonZcard", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonZcard");
  }

  oprot->writeMessageBegin("commonZcard", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonZcard", bytes);
  }
}

void CacheServiceProcessor::process_commonZscore(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonZscore", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonZscore");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonZscore");
  }

  CacheService_commonZscore_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonZscore", bytes);
  }

  CacheService_commonZscore_result result;
  try {
    result.success = iface_->commonZscore(args.maxCode, args.minCode, args.key, args.member);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonZscore");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonZscore", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonZscore");
  }

  oprot->writeMessageBegin("commonZscore", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonZscore", bytes);
  }
}

void CacheServiceProcessor::process_commonZrank(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonZrank", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonZrank");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonZrank");
  }

  CacheService_commonZrank_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonZrank", bytes);
  }

  CacheService_commonZrank_result result;
  try {
    result.success = iface_->commonZrank(args.maxCode, args.minCode, args.key, args.member, args.sortType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonZrank");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonZrank", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonZrank");
  }

  oprot->writeMessageBegin("commonZrank", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonZrank", bytes);
  }
}

void CacheServiceProcessor::process_commonPageZrangeByScore(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonPageZrangeByScore", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonPageZrangeByScore");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonPageZrangeByScore");
  }

  CacheService_commonPageZrangeByScore_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonPageZrangeByScore", bytes);
  }

  CacheService_commonPageZrangeByScore_result result;
  try {
    iface_->commonPageZrangeByScore(result.success, args.maxCode, args.minCode, args.key, args.min, args.max, args.sortType, args.offset, args.count);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonPageZrangeByScore");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonPageZrangeByScore", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonPageZrangeByScore");
  }

  oprot->writeMessageBegin("commonPageZrangeByScore", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonPageZrangeByScore", bytes);
  }
}

void CacheServiceProcessor::process_commonPageZrangeByScoreWithScores(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonPageZrangeByScoreWithScores", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonPageZrangeByScoreWithScores");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonPageZrangeByScoreWithScores");
  }

  CacheService_commonPageZrangeByScoreWithScores_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonPageZrangeByScoreWithScores", bytes);
  }

  CacheService_commonPageZrangeByScoreWithScores_result result;
  try {
    iface_->commonPageZrangeByScoreWithScores(result.success, args.maxCode, args.minCode, args.key, args.min, args.max, args.sortType, args.offset, args.count);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonPageZrangeByScoreWithScores");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonPageZrangeByScoreWithScores", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonPageZrangeByScoreWithScores");
  }

  oprot->writeMessageBegin("commonPageZrangeByScoreWithScores", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonPageZrangeByScoreWithScores", bytes);
  }
}

void CacheServiceProcessor::process_commonZrangeByScore(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonZrangeByScore", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonZrangeByScore");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonZrangeByScore");
  }

  CacheService_commonZrangeByScore_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonZrangeByScore", bytes);
  }

  CacheService_commonZrangeByScore_result result;
  try {
    iface_->commonZrangeByScore(result.success, args.maxCode, args.minCode, args.key, args.min, args.max, args.sortType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonZrangeByScore");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonZrangeByScore", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonZrangeByScore");
  }

  oprot->writeMessageBegin("commonZrangeByScore", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonZrangeByScore", bytes);
  }
}

void CacheServiceProcessor::process_commonZrangeByScoreWithScores(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonZrangeByScoreWithScores", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonZrangeByScoreWithScores");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonZrangeByScoreWithScores");
  }

  CacheService_commonZrangeByScoreWithScores_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonZrangeByScoreWithScores", bytes);
  }

  CacheService_commonZrangeByScoreWithScores_result result;
  try {
    iface_->commonZrangeByScoreWithScores(result.success, args.maxCode, args.minCode, args.key, args.min, args.max, args.sortType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonZrangeByScoreWithScores");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonZrangeByScoreWithScores", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonZrangeByScoreWithScores");
  }

  oprot->writeMessageBegin("commonZrangeByScoreWithScores", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonZrangeByScoreWithScores", bytes);
  }
}

void CacheServiceProcessor::process_commonZrange(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonZrange", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonZrange");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonZrange");
  }

  CacheService_commonZrange_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonZrange", bytes);
  }

  CacheService_commonZrange_result result;
  try {
    iface_->commonZrange(result.success, args.maxCode, args.minCode, args.key, args.min, args.max, args.sortType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonZrange");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonZrange", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonZrange");
  }

  oprot->writeMessageBegin("commonZrange", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonZrange", bytes);
  }
}

void CacheServiceProcessor::process_commonZincrby(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonZincrby", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonZincrby");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonZincrby");
  }

  CacheService_commonZincrby_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonZincrby", bytes);
  }

  CacheService_commonZincrby_result result;
  try {
    result.success = iface_->commonZincrby(args.maxCode, args.minCode, args.key, args.sorce, args.member);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonZincrby");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonZincrby", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonZincrby");
  }

  oprot->writeMessageBegin("commonZincrby", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonZincrby", bytes);
  }
}

void CacheServiceProcessor::process_commonZcount(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CacheService.commonZcount", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CacheService.commonZcount");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CacheService.commonZcount");
  }

  CacheService_commonZcount_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CacheService.commonZcount", bytes);
  }

  CacheService_commonZcount_result result;
  try {
    result.success = iface_->commonZcount(args.maxCode, args.minCode, args.key, args.min, args.max);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CacheService.commonZcount");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commonZcount", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CacheService.commonZcount");
  }

  oprot->writeMessageBegin("commonZcount", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CacheService.commonZcount", bytes);
  }
}

::boost::shared_ptr< ::apache::thrift::TProcessor > CacheServiceProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< CacheServiceIfFactory > cleanup(handlerFactory_);
  ::boost::shared_ptr< CacheServiceIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::boost::shared_ptr< ::apache::thrift::TProcessor > processor(new CacheServiceProcessor(handler));
  return processor;
}
}}}}}} // namespace

