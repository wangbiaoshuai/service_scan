/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef bean_TYPES_H
#define bean_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace com { namespace vrv { namespace cems { namespace service { namespace base { namespace bean { namespace cache {

typedef struct _Result__isset {
  _Result__isset() : code(true), info(true) {}
  bool code;
  bool info;
} _Result__isset;

class Result {
 public:

  static const char* ascii_fingerprint; // = "A7801670116150C65ACA43E6F679BA79";
  static const uint8_t binary_fingerprint[16]; // = {0xA7,0x80,0x16,0x70,0x11,0x61,0x50,0xC6,0x5A,0xCA,0x43,0xE6,0xF6,0x79,0xBA,0x79};

  Result() : code(0), info("成功.") {
  }

  virtual ~Result() throw() {}

  int32_t code;
  std::string info;

  _Result__isset __isset;

  void __set_code(const int32_t val) {
    code = val;
    __isset.code = true;
  }

  void __set_info(const std::string& val) {
    info = val;
    __isset.info = true;
  }

  bool operator == (const Result & rhs) const
  {
    if (__isset.code != rhs.__isset.code)
      return false;
    else if (__isset.code && !(code == rhs.code))
      return false;
    if (__isset.info != rhs.__isset.info)
      return false;
    else if (__isset.info && !(info == rhs.info))
      return false;
    return true;
  }
  bool operator != (const Result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Result &a, Result &b);

typedef struct _DeviceCache__isset {
  _DeviceCache__isset() : id(false), devOnlyId(false), ip(false), ipType(false), ipNumber(false), mac(false), osId(false), deviceTypeId(false), registerTime(false), clientId(false), clientName(false), clientSign(false), clientVersion(false), softVersion(false), switchIP(false), switchPort(false), isMutiOs(false), isVm(false), communicateIP(false), routeIp(false), regState(false), protectState(false), roamState(false), deleteState(false), userOnlyId(false), organizationId(false), mask(false) {}
  bool id;
  bool devOnlyId;
  bool ip;
  bool ipType;
  bool ipNumber;
  bool mac;
  bool osId;
  bool deviceTypeId;
  bool registerTime;
  bool clientId;
  bool clientName;
  bool clientSign;
  bool clientVersion;
  bool softVersion;
  bool switchIP;
  bool switchPort;
  bool isMutiOs;
  bool isVm;
  bool communicateIP;
  bool routeIp;
  bool regState;
  bool protectState;
  bool roamState;
  bool deleteState;
  bool userOnlyId;
  bool organizationId;
  bool mask;
} _DeviceCache__isset;

class DeviceCache {
 public:

  static const char* ascii_fingerprint; // = "D1ECE0AF20CE205381B4D690EC1902F8";
  static const uint8_t binary_fingerprint[16]; // = {0xD1,0xEC,0xE0,0xAF,0x20,0xCE,0x20,0x53,0x81,0xB4,0xD6,0x90,0xEC,0x19,0x02,0xF8};

  DeviceCache() : id(), devOnlyId(), ip(), ipType(), ipNumber(), mac(), osId(), deviceTypeId(), registerTime(), clientId(), clientName(), clientSign(), clientVersion(), softVersion(), switchIP(), switchPort(), isMutiOs(0), isVm(0), communicateIP(), routeIp(), regState(0), protectState(0), roamState(0), deleteState(0), userOnlyId(), organizationId(), mask() {
  }

  virtual ~DeviceCache() throw() {}

  std::string id;
  std::string devOnlyId;
  std::string ip;
  std::string ipType;
  std::string ipNumber;
  std::string mac;
  std::string osId;
  std::string deviceTypeId;
  std::string registerTime;
  std::string clientId;
  std::string clientName;
  std::string clientSign;
  std::string clientVersion;
  std::string softVersion;
  std::string switchIP;
  std::string switchPort;
  int32_t isMutiOs;
  int32_t isVm;
  std::string communicateIP;
  std::string routeIp;
  int32_t regState;
  int32_t protectState;
  int32_t roamState;
  int32_t deleteState;
  std::string userOnlyId;
  std::string organizationId;
  std::string mask;

  _DeviceCache__isset __isset;

  void __set_id(const std::string& val) {
    id = val;
  }

  void __set_devOnlyId(const std::string& val) {
    devOnlyId = val;
  }

  void __set_ip(const std::string& val) {
    ip = val;
  }

  void __set_ipType(const std::string& val) {
    ipType = val;
  }

  void __set_ipNumber(const std::string& val) {
    ipNumber = val;
  }

  void __set_mac(const std::string& val) {
    mac = val;
  }

  void __set_osId(const std::string& val) {
    osId = val;
  }

  void __set_deviceTypeId(const std::string& val) {
    deviceTypeId = val;
  }

  void __set_registerTime(const std::string& val) {
    registerTime = val;
  }

  void __set_clientId(const std::string& val) {
    clientId = val;
  }

  void __set_clientName(const std::string& val) {
    clientName = val;
  }

  void __set_clientSign(const std::string& val) {
    clientSign = val;
  }

  void __set_clientVersion(const std::string& val) {
    clientVersion = val;
  }

  void __set_softVersion(const std::string& val) {
    softVersion = val;
  }

  void __set_switchIP(const std::string& val) {
    switchIP = val;
  }

  void __set_switchPort(const std::string& val) {
    switchPort = val;
  }

  void __set_isMutiOs(const int32_t val) {
    isMutiOs = val;
  }

  void __set_isVm(const int32_t val) {
    isVm = val;
  }

  void __set_communicateIP(const std::string& val) {
    communicateIP = val;
  }

  void __set_routeIp(const std::string& val) {
    routeIp = val;
  }

  void __set_regState(const int32_t val) {
    regState = val;
  }

  void __set_protectState(const int32_t val) {
    protectState = val;
  }

  void __set_roamState(const int32_t val) {
    roamState = val;
  }

  void __set_deleteState(const int32_t val) {
    deleteState = val;
  }

  void __set_userOnlyId(const std::string& val) {
    userOnlyId = val;
  }

  void __set_organizationId(const std::string& val) {
    organizationId = val;
  }

  void __set_mask(const std::string& val) {
    mask = val;
  }

  bool operator == (const DeviceCache & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(devOnlyId == rhs.devOnlyId))
      return false;
    if (!(ip == rhs.ip))
      return false;
    if (!(ipType == rhs.ipType))
      return false;
    if (!(ipNumber == rhs.ipNumber))
      return false;
    if (!(mac == rhs.mac))
      return false;
    if (!(osId == rhs.osId))
      return false;
    if (!(deviceTypeId == rhs.deviceTypeId))
      return false;
    if (!(registerTime == rhs.registerTime))
      return false;
    if (!(clientId == rhs.clientId))
      return false;
    if (!(clientName == rhs.clientName))
      return false;
    if (!(clientSign == rhs.clientSign))
      return false;
    if (!(clientVersion == rhs.clientVersion))
      return false;
    if (!(softVersion == rhs.softVersion))
      return false;
    if (!(switchIP == rhs.switchIP))
      return false;
    if (!(switchPort == rhs.switchPort))
      return false;
    if (!(isMutiOs == rhs.isMutiOs))
      return false;
    if (!(isVm == rhs.isVm))
      return false;
    if (!(communicateIP == rhs.communicateIP))
      return false;
    if (!(routeIp == rhs.routeIp))
      return false;
    if (!(regState == rhs.regState))
      return false;
    if (!(protectState == rhs.protectState))
      return false;
    if (!(roamState == rhs.roamState))
      return false;
    if (!(deleteState == rhs.deleteState))
      return false;
    if (!(userOnlyId == rhs.userOnlyId))
      return false;
    if (!(organizationId == rhs.organizationId))
      return false;
    if (!(mask == rhs.mask))
      return false;
    return true;
  }
  bool operator != (const DeviceCache &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DeviceCache & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DeviceCache &a, DeviceCache &b);

typedef struct _DeviceOnlineCache__isset {
  _DeviceOnlineCache__isset() : devOnlyId(false), loginTime(false), activeTime(false), sessionId(false), udpActiveTime(false), routeIp(false), udpPort(false), udpServiceIp(false), udpServicePort(false) {}
  bool devOnlyId;
  bool loginTime;
  bool activeTime;
  bool sessionId;
  bool udpActiveTime;
  bool routeIp;
  bool udpPort;
  bool udpServiceIp;
  bool udpServicePort;
} _DeviceOnlineCache__isset;

class DeviceOnlineCache {
 public:

  static const char* ascii_fingerprint; // = "DFFD290DFC35F6F1BE0790E5EC0C6B55";
  static const uint8_t binary_fingerprint[16]; // = {0xDF,0xFD,0x29,0x0D,0xFC,0x35,0xF6,0xF1,0xBE,0x07,0x90,0xE5,0xEC,0x0C,0x6B,0x55};

  DeviceOnlineCache() : devOnlyId(), loginTime(), activeTime(), sessionId(), udpActiveTime(), routeIp(), udpPort(), udpServiceIp(), udpServicePort() {
  }

  virtual ~DeviceOnlineCache() throw() {}

  std::string devOnlyId;
  std::string loginTime;
  std::string activeTime;
  std::string sessionId;
  std::string udpActiveTime;
  std::string routeIp;
  std::string udpPort;
  std::string udpServiceIp;
  std::string udpServicePort;

  _DeviceOnlineCache__isset __isset;

  void __set_devOnlyId(const std::string& val) {
    devOnlyId = val;
  }

  void __set_loginTime(const std::string& val) {
    loginTime = val;
  }

  void __set_activeTime(const std::string& val) {
    activeTime = val;
  }

  void __set_sessionId(const std::string& val) {
    sessionId = val;
  }

  void __set_udpActiveTime(const std::string& val) {
    udpActiveTime = val;
  }

  void __set_routeIp(const std::string& val) {
    routeIp = val;
  }

  void __set_udpPort(const std::string& val) {
    udpPort = val;
  }

  void __set_udpServiceIp(const std::string& val) {
    udpServiceIp = val;
  }

  void __set_udpServicePort(const std::string& val) {
    udpServicePort = val;
  }

  bool operator == (const DeviceOnlineCache & rhs) const
  {
    if (!(devOnlyId == rhs.devOnlyId))
      return false;
    if (!(loginTime == rhs.loginTime))
      return false;
    if (!(activeTime == rhs.activeTime))
      return false;
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(udpActiveTime == rhs.udpActiveTime))
      return false;
    if (!(routeIp == rhs.routeIp))
      return false;
    if (!(udpPort == rhs.udpPort))
      return false;
    if (!(udpServiceIp == rhs.udpServiceIp))
      return false;
    if (!(udpServicePort == rhs.udpServicePort))
      return false;
    return true;
  }
  bool operator != (const DeviceOnlineCache &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DeviceOnlineCache & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DeviceOnlineCache &a, DeviceOnlineCache &b);

typedef struct _DeviceKeyCache__isset {
  _DeviceKeyCache__isset() : keyType(false), password(false), devOnlyId(false), sessionId(false), offsetVector(false) {}
  bool keyType;
  bool password;
  bool devOnlyId;
  bool sessionId;
  bool offsetVector;
} _DeviceKeyCache__isset;

class DeviceKeyCache {
 public:

  static const char* ascii_fingerprint; // = "BFF0E21728CB005F9AA5774A41542B8D";
  static const uint8_t binary_fingerprint[16]; // = {0xBF,0xF0,0xE2,0x17,0x28,0xCB,0x00,0x5F,0x9A,0xA5,0x77,0x4A,0x41,0x54,0x2B,0x8D};

  DeviceKeyCache() : keyType(), password(), devOnlyId(), sessionId(), offsetVector() {
  }

  virtual ~DeviceKeyCache() throw() {}

  std::string keyType;
  std::string password;
  std::string devOnlyId;
  std::string sessionId;
  std::string offsetVector;

  _DeviceKeyCache__isset __isset;

  void __set_keyType(const std::string& val) {
    keyType = val;
  }

  void __set_password(const std::string& val) {
    password = val;
  }

  void __set_devOnlyId(const std::string& val) {
    devOnlyId = val;
  }

  void __set_sessionId(const std::string& val) {
    sessionId = val;
  }

  void __set_offsetVector(const std::string& val) {
    offsetVector = val;
  }

  bool operator == (const DeviceKeyCache & rhs) const
  {
    if (!(keyType == rhs.keyType))
      return false;
    if (!(password == rhs.password))
      return false;
    if (!(devOnlyId == rhs.devOnlyId))
      return false;
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(offsetVector == rhs.offsetVector))
      return false;
    return true;
  }
  bool operator != (const DeviceKeyCache &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DeviceKeyCache & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DeviceKeyCache &a, DeviceKeyCache &b);

typedef struct _ProductInfoOld__isset {
  _ProductInfoOld__isset() : type(false), productName(false), version(false), productSign(false), installTime(false) {}
  bool type;
  bool productName;
  bool version;
  bool productSign;
  bool installTime;
} _ProductInfoOld__isset;

class ProductInfoOld {
 public:

  static const char* ascii_fingerprint; // = "86F68448E93C4E5249433AA07CAE002F";
  static const uint8_t binary_fingerprint[16]; // = {0x86,0xF6,0x84,0x48,0xE9,0x3C,0x4E,0x52,0x49,0x43,0x3A,0xA0,0x7C,0xAE,0x00,0x2F};

  ProductInfoOld() : type(0), productName(), version(), productSign(), installTime() {
  }

  virtual ~ProductInfoOld() throw() {}

  int32_t type;
  std::string productName;
  std::string version;
  std::string productSign;
  std::string installTime;

  _ProductInfoOld__isset __isset;

  void __set_type(const int32_t val) {
    type = val;
  }

  void __set_productName(const std::string& val) {
    productName = val;
  }

  void __set_version(const std::string& val) {
    version = val;
  }

  void __set_productSign(const std::string& val) {
    productSign = val;
  }

  void __set_installTime(const std::string& val) {
    installTime = val;
  }

  bool operator == (const ProductInfoOld & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(productName == rhs.productName))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(productSign == rhs.productSign))
      return false;
    if (!(installTime == rhs.installTime))
      return false;
    return true;
  }
  bool operator != (const ProductInfoOld &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ProductInfoOld & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ProductInfoOld &a, ProductInfoOld &b);

typedef struct _ProductInfoNew__isset {
  _ProductInfoNew__isset() : type(false), productName(false), version(false), cUpgradePackId(false) {}
  bool type;
  bool productName;
  bool version;
  bool cUpgradePackId;
} _ProductInfoNew__isset;

class ProductInfoNew {
 public:

  static const char* ascii_fingerprint; // = "C4A8A7FE71C2DB9CB73D92862AA4C591";
  static const uint8_t binary_fingerprint[16]; // = {0xC4,0xA8,0xA7,0xFE,0x71,0xC2,0xDB,0x9C,0xB7,0x3D,0x92,0x86,0x2A,0xA4,0xC5,0x91};

  ProductInfoNew() : type(0), productName(), version(), cUpgradePackId() {
  }

  virtual ~ProductInfoNew() throw() {}

  int32_t type;
  std::string productName;
  std::string version;
  std::string cUpgradePackId;

  _ProductInfoNew__isset __isset;

  void __set_type(const int32_t val) {
    type = val;
  }

  void __set_productName(const std::string& val) {
    productName = val;
  }

  void __set_version(const std::string& val) {
    version = val;
  }

  void __set_cUpgradePackId(const std::string& val) {
    cUpgradePackId = val;
  }

  bool operator == (const ProductInfoNew & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(productName == rhs.productName))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(cUpgradePackId == rhs.cUpgradePackId))
      return false;
    return true;
  }
  bool operator != (const ProductInfoNew &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ProductInfoNew & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ProductInfoNew &a, ProductInfoNew &b);

typedef struct _DeviceProduct__isset {
  _DeviceProduct__isset() : osType(false), productType(false), productInfoOldList(false), productInfoNewList(false) {}
  bool osType;
  bool productType;
  bool productInfoOldList;
  bool productInfoNewList;
} _DeviceProduct__isset;

class DeviceProduct {
 public:

  static const char* ascii_fingerprint; // = "E80E67B3185CF26AFC5F526B742E1E77";
  static const uint8_t binary_fingerprint[16]; // = {0xE8,0x0E,0x67,0xB3,0x18,0x5C,0xF2,0x6A,0xFC,0x5F,0x52,0x6B,0x74,0x2E,0x1E,0x77};

  DeviceProduct() : osType(), productType() {
  }

  virtual ~DeviceProduct() throw() {}

  std::string osType;
  std::string productType;
  std::vector<ProductInfoOld>  productInfoOldList;
  std::vector<ProductInfoNew>  productInfoNewList;

  _DeviceProduct__isset __isset;

  void __set_osType(const std::string& val) {
    osType = val;
  }

  void __set_productType(const std::string& val) {
    productType = val;
  }

  void __set_productInfoOldList(const std::vector<ProductInfoOld> & val) {
    productInfoOldList = val;
  }

  void __set_productInfoNewList(const std::vector<ProductInfoNew> & val) {
    productInfoNewList = val;
  }

  bool operator == (const DeviceProduct & rhs) const
  {
    if (!(osType == rhs.osType))
      return false;
    if (!(productType == rhs.productType))
      return false;
    if (!(productInfoOldList == rhs.productInfoOldList))
      return false;
    if (!(productInfoNewList == rhs.productInfoNewList))
      return false;
    return true;
  }
  bool operator != (const DeviceProduct &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DeviceProduct & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DeviceProduct &a, DeviceProduct &b);

typedef struct _DevicePolicyCache__isset {
  _DevicePolicyCache__isset() : devOnlyId(false), policyVersion(false), policyIds(false) {}
  bool devOnlyId;
  bool policyVersion;
  bool policyIds;
} _DevicePolicyCache__isset;

class DevicePolicyCache {
 public:

  static const char* ascii_fingerprint; // = "AB879940BD15B6B25691265F7384B271";
  static const uint8_t binary_fingerprint[16]; // = {0xAB,0x87,0x99,0x40,0xBD,0x15,0xB6,0xB2,0x56,0x91,0x26,0x5F,0x73,0x84,0xB2,0x71};

  DevicePolicyCache() : devOnlyId(), policyVersion(), policyIds() {
  }

  virtual ~DevicePolicyCache() throw() {}

  std::string devOnlyId;
  std::string policyVersion;
  std::string policyIds;

  _DevicePolicyCache__isset __isset;

  void __set_devOnlyId(const std::string& val) {
    devOnlyId = val;
  }

  void __set_policyVersion(const std::string& val) {
    policyVersion = val;
  }

  void __set_policyIds(const std::string& val) {
    policyIds = val;
  }

  bool operator == (const DevicePolicyCache & rhs) const
  {
    if (!(devOnlyId == rhs.devOnlyId))
      return false;
    if (!(policyVersion == rhs.policyVersion))
      return false;
    if (!(policyIds == rhs.policyIds))
      return false;
    return true;
  }
  bool operator != (const DevicePolicyCache &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DevicePolicyCache & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DevicePolicyCache &a, DevicePolicyCache &b);

typedef struct _UserCache__isset {
  _UserCache__isset() : id(false), userOnlyId(false), account(false), password(false), accountTypeId(false), organizationId(false), registeTime(false), lastLoginTime(false), approvalState(false), type(false) {}
  bool id;
  bool userOnlyId;
  bool account;
  bool password;
  bool accountTypeId;
  bool organizationId;
  bool registeTime;
  bool lastLoginTime;
  bool approvalState;
  bool type;
} _UserCache__isset;

class UserCache {
 public:

  static const char* ascii_fingerprint; // = "619E98DF6C68D89B878DB87A6616B9D7";
  static const uint8_t binary_fingerprint[16]; // = {0x61,0x9E,0x98,0xDF,0x6C,0x68,0xD8,0x9B,0x87,0x8D,0xB8,0x7A,0x66,0x16,0xB9,0xD7};

  UserCache() : id(), userOnlyId(), account(), password(), accountTypeId(), organizationId(), registeTime(), lastLoginTime(), approvalState(0), type(0) {
  }

  virtual ~UserCache() throw() {}

  std::string id;
  std::string userOnlyId;
  std::string account;
  std::string password;
  std::string accountTypeId;
  std::string organizationId;
  std::string registeTime;
  std::string lastLoginTime;
  int32_t approvalState;
  int32_t type;

  _UserCache__isset __isset;

  void __set_id(const std::string& val) {
    id = val;
  }

  void __set_userOnlyId(const std::string& val) {
    userOnlyId = val;
  }

  void __set_account(const std::string& val) {
    account = val;
  }

  void __set_password(const std::string& val) {
    password = val;
  }

  void __set_accountTypeId(const std::string& val) {
    accountTypeId = val;
  }

  void __set_organizationId(const std::string& val) {
    organizationId = val;
  }

  void __set_registeTime(const std::string& val) {
    registeTime = val;
  }

  void __set_lastLoginTime(const std::string& val) {
    lastLoginTime = val;
  }

  void __set_approvalState(const int32_t val) {
    approvalState = val;
  }

  void __set_type(const int32_t val) {
    type = val;
  }

  bool operator == (const UserCache & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(userOnlyId == rhs.userOnlyId))
      return false;
    if (!(account == rhs.account))
      return false;
    if (!(password == rhs.password))
      return false;
    if (!(accountTypeId == rhs.accountTypeId))
      return false;
    if (!(organizationId == rhs.organizationId))
      return false;
    if (!(registeTime == rhs.registeTime))
      return false;
    if (!(lastLoginTime == rhs.lastLoginTime))
      return false;
    if (!(approvalState == rhs.approvalState))
      return false;
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const UserCache &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserCache & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(UserCache &a, UserCache &b);

typedef struct _UserOnlineCache__isset {
  _UserOnlineCache__isset() : userOnlyId(false), account(false), devOnlyId(false), loginTime(false), loginAccount(false), userDevId(false) {}
  bool userOnlyId;
  bool account;
  bool devOnlyId;
  bool loginTime;
  bool loginAccount;
  bool userDevId;
} _UserOnlineCache__isset;

class UserOnlineCache {
 public:

  static const char* ascii_fingerprint; // = "873CB9E5A4C10A7ECE7476FD192F55EE";
  static const uint8_t binary_fingerprint[16]; // = {0x87,0x3C,0xB9,0xE5,0xA4,0xC1,0x0A,0x7E,0xCE,0x74,0x76,0xFD,0x19,0x2F,0x55,0xEE};

  UserOnlineCache() : userOnlyId(), account(), devOnlyId(), loginTime(), loginAccount(), userDevId() {
  }

  virtual ~UserOnlineCache() throw() {}

  std::string userOnlyId;
  std::string account;
  std::string devOnlyId;
  std::string loginTime;
  std::string loginAccount;
  std::string userDevId;

  _UserOnlineCache__isset __isset;

  void __set_userOnlyId(const std::string& val) {
    userOnlyId = val;
  }

  void __set_account(const std::string& val) {
    account = val;
  }

  void __set_devOnlyId(const std::string& val) {
    devOnlyId = val;
  }

  void __set_loginTime(const std::string& val) {
    loginTime = val;
  }

  void __set_loginAccount(const std::string& val) {
    loginAccount = val;
  }

  void __set_userDevId(const std::string& val) {
    userDevId = val;
  }

  bool operator == (const UserOnlineCache & rhs) const
  {
    if (!(userOnlyId == rhs.userOnlyId))
      return false;
    if (!(account == rhs.account))
      return false;
    if (!(devOnlyId == rhs.devOnlyId))
      return false;
    if (!(loginTime == rhs.loginTime))
      return false;
    if (!(loginAccount == rhs.loginAccount))
      return false;
    if (!(userDevId == rhs.userDevId))
      return false;
    return true;
  }
  bool operator != (const UserOnlineCache &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserOnlineCache & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(UserOnlineCache &a, UserOnlineCache &b);

typedef struct _UserPolicyCache__isset {
  _UserPolicyCache__isset() : userOnlyId(false), policyVersion(false), policyIds(false) {}
  bool userOnlyId;
  bool policyVersion;
  bool policyIds;
} _UserPolicyCache__isset;

class UserPolicyCache {
 public:

  static const char* ascii_fingerprint; // = "AB879940BD15B6B25691265F7384B271";
  static const uint8_t binary_fingerprint[16]; // = {0xAB,0x87,0x99,0x40,0xBD,0x15,0xB6,0xB2,0x56,0x91,0x26,0x5F,0x73,0x84,0xB2,0x71};

  UserPolicyCache() : userOnlyId(), policyVersion(), policyIds() {
  }

  virtual ~UserPolicyCache() throw() {}

  std::string userOnlyId;
  std::string policyVersion;
  std::string policyIds;

  _UserPolicyCache__isset __isset;

  void __set_userOnlyId(const std::string& val) {
    userOnlyId = val;
  }

  void __set_policyVersion(const std::string& val) {
    policyVersion = val;
  }

  void __set_policyIds(const std::string& val) {
    policyIds = val;
  }

  bool operator == (const UserPolicyCache & rhs) const
  {
    if (!(userOnlyId == rhs.userOnlyId))
      return false;
    if (!(policyVersion == rhs.policyVersion))
      return false;
    if (!(policyIds == rhs.policyIds))
      return false;
    return true;
  }
  bool operator != (const UserPolicyCache &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserPolicyCache & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(UserPolicyCache &a, UserPolicyCache &b);

typedef struct _CInstallPackCache__isset {
  _CInstallPackCache__isset() : cInstallPackId(false), name(false), version(false), size(false), path(false), osType(false), productType(false), pubTime(false), crc(false) {}
  bool cInstallPackId;
  bool name;
  bool version;
  bool size;
  bool path;
  bool osType;
  bool productType;
  bool pubTime;
  bool crc;
} _CInstallPackCache__isset;

class CInstallPackCache {
 public:

  static const char* ascii_fingerprint; // = "2949B60FFAC069A76CE9CFBFC602E1D5";
  static const uint8_t binary_fingerprint[16]; // = {0x29,0x49,0xB6,0x0F,0xFA,0xC0,0x69,0xA7,0x6C,0xE9,0xCF,0xBF,0xC6,0x02,0xE1,0xD5};

  CInstallPackCache() : cInstallPackId(), name(), version(), size(0), path(), osType(), productType(), pubTime(), crc() {
  }

  virtual ~CInstallPackCache() throw() {}

  std::string cInstallPackId;
  std::string name;
  std::string version;
  int32_t size;
  std::string path;
  std::string osType;
  std::string productType;
  std::string pubTime;
  std::string crc;

  _CInstallPackCache__isset __isset;

  void __set_cInstallPackId(const std::string& val) {
    cInstallPackId = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_version(const std::string& val) {
    version = val;
  }

  void __set_size(const int32_t val) {
    size = val;
  }

  void __set_path(const std::string& val) {
    path = val;
  }

  void __set_osType(const std::string& val) {
    osType = val;
  }

  void __set_productType(const std::string& val) {
    productType = val;
  }

  void __set_pubTime(const std::string& val) {
    pubTime = val;
  }

  void __set_crc(const std::string& val) {
    crc = val;
  }

  bool operator == (const CInstallPackCache & rhs) const
  {
    if (!(cInstallPackId == rhs.cInstallPackId))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(size == rhs.size))
      return false;
    if (!(path == rhs.path))
      return false;
    if (!(osType == rhs.osType))
      return false;
    if (!(productType == rhs.productType))
      return false;
    if (!(pubTime == rhs.pubTime))
      return false;
    if (!(crc == rhs.crc))
      return false;
    return true;
  }
  bool operator != (const CInstallPackCache &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CInstallPackCache & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(CInstallPackCache &a, CInstallPackCache &b);

typedef struct _PolicyCache__isset {
  _PolicyCache__isset() : id(false), objType(false), name(false), content(false), crc(false), contentCRC(false), organizationId(false), publishTime(false), policyTemplateId(false), obj(false), objCRC(false) {}
  bool id;
  bool objType;
  bool name;
  bool content;
  bool crc;
  bool contentCRC;
  bool organizationId;
  bool publishTime;
  bool policyTemplateId;
  bool obj;
  bool objCRC;
} _PolicyCache__isset;

class PolicyCache {
 public:

  static const char* ascii_fingerprint; // = "7C659ED3D0F6071DB427E0D8A3A5A85F";
  static const uint8_t binary_fingerprint[16]; // = {0x7C,0x65,0x9E,0xD3,0xD0,0xF6,0x07,0x1D,0xB4,0x27,0xE0,0xD8,0xA3,0xA5,0xA8,0x5F};

  PolicyCache() : id(), objType(), name(), content(), crc(), contentCRC(), organizationId(), publishTime(), policyTemplateId(), obj(), objCRC() {
  }

  virtual ~PolicyCache() throw() {}

  std::string id;
  std::string objType;
  std::string name;
  std::string content;
  std::string crc;
  std::string contentCRC;
  std::string organizationId;
  std::string publishTime;
  std::string policyTemplateId;
  std::string obj;
  std::string objCRC;

  _PolicyCache__isset __isset;

  void __set_id(const std::string& val) {
    id = val;
  }

  void __set_objType(const std::string& val) {
    objType = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_content(const std::string& val) {
    content = val;
  }

  void __set_crc(const std::string& val) {
    crc = val;
  }

  void __set_contentCRC(const std::string& val) {
    contentCRC = val;
  }

  void __set_organizationId(const std::string& val) {
    organizationId = val;
  }

  void __set_publishTime(const std::string& val) {
    publishTime = val;
  }

  void __set_policyTemplateId(const std::string& val) {
    policyTemplateId = val;
  }

  void __set_obj(const std::string& val) {
    obj = val;
  }

  void __set_objCRC(const std::string& val) {
    objCRC = val;
  }

  bool operator == (const PolicyCache & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(objType == rhs.objType))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(content == rhs.content))
      return false;
    if (!(crc == rhs.crc))
      return false;
    if (!(contentCRC == rhs.contentCRC))
      return false;
    if (!(organizationId == rhs.organizationId))
      return false;
    if (!(publishTime == rhs.publishTime))
      return false;
    if (!(policyTemplateId == rhs.policyTemplateId))
      return false;
    if (!(obj == rhs.obj))
      return false;
    if (!(objCRC == rhs.objCRC))
      return false;
    return true;
  }
  bool operator != (const PolicyCache &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PolicyCache & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(PolicyCache &a, PolicyCache &b);

typedef struct _CUpgradePackCache__isset {
  _CUpgradePackCache__isset() : cUpgradePackId(false), name(false), version(false), size(false), path(false), osType(false), productType(false), pubTime(false), crc(false), type(false) {}
  bool cUpgradePackId;
  bool name;
  bool version;
  bool size;
  bool path;
  bool osType;
  bool productType;
  bool pubTime;
  bool crc;
  bool type;
} _CUpgradePackCache__isset;

class CUpgradePackCache {
 public:

  static const char* ascii_fingerprint; // = "CC3C1B46B4C8633346064A3ABEDBC993";
  static const uint8_t binary_fingerprint[16]; // = {0xCC,0x3C,0x1B,0x46,0xB4,0xC8,0x63,0x33,0x46,0x06,0x4A,0x3A,0xBE,0xDB,0xC9,0x93};

  CUpgradePackCache() : cUpgradePackId(), name(), version(), size(0), path(), osType(), productType(), pubTime(), crc(), type(0) {
  }

  virtual ~CUpgradePackCache() throw() {}

  std::string cUpgradePackId;
  std::string name;
  std::string version;
  int32_t size;
  std::string path;
  std::string osType;
  std::string productType;
  std::string pubTime;
  std::string crc;
  int32_t type;

  _CUpgradePackCache__isset __isset;

  void __set_cUpgradePackId(const std::string& val) {
    cUpgradePackId = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_version(const std::string& val) {
    version = val;
  }

  void __set_size(const int32_t val) {
    size = val;
  }

  void __set_path(const std::string& val) {
    path = val;
  }

  void __set_osType(const std::string& val) {
    osType = val;
  }

  void __set_productType(const std::string& val) {
    productType = val;
  }

  void __set_pubTime(const std::string& val) {
    pubTime = val;
  }

  void __set_crc(const std::string& val) {
    crc = val;
  }

  void __set_type(const int32_t val) {
    type = val;
  }

  bool operator == (const CUpgradePackCache & rhs) const
  {
    if (!(cUpgradePackId == rhs.cUpgradePackId))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(size == rhs.size))
      return false;
    if (!(path == rhs.path))
      return false;
    if (!(osType == rhs.osType))
      return false;
    if (!(productType == rhs.productType))
      return false;
    if (!(pubTime == rhs.pubTime))
      return false;
    if (!(crc == rhs.crc))
      return false;
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const CUpgradePackCache &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CUpgradePackCache & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(CUpgradePackCache &a, CUpgradePackCache &b);

typedef struct _SensitiveCache__isset {
  _SensitiveCache__isset() : id(false), name(false), path(false), crc(false), createTime(false), lastUpdateTime(false) {}
  bool id;
  bool name;
  bool path;
  bool crc;
  bool createTime;
  bool lastUpdateTime;
} _SensitiveCache__isset;

class SensitiveCache {
 public:

  static const char* ascii_fingerprint; // = "873CB9E5A4C10A7ECE7476FD192F55EE";
  static const uint8_t binary_fingerprint[16]; // = {0x87,0x3C,0xB9,0xE5,0xA4,0xC1,0x0A,0x7E,0xCE,0x74,0x76,0xFD,0x19,0x2F,0x55,0xEE};

  SensitiveCache() : id(), name(), path(), crc(), createTime(), lastUpdateTime() {
  }

  virtual ~SensitiveCache() throw() {}

  std::string id;
  std::string name;
  std::string path;
  std::string crc;
  std::string createTime;
  std::string lastUpdateTime;

  _SensitiveCache__isset __isset;

  void __set_id(const std::string& val) {
    id = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_path(const std::string& val) {
    path = val;
  }

  void __set_crc(const std::string& val) {
    crc = val;
  }

  void __set_createTime(const std::string& val) {
    createTime = val;
  }

  void __set_lastUpdateTime(const std::string& val) {
    lastUpdateTime = val;
  }

  bool operator == (const SensitiveCache & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(path == rhs.path))
      return false;
    if (!(crc == rhs.crc))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(lastUpdateTime == rhs.lastUpdateTime))
      return false;
    return true;
  }
  bool operator != (const SensitiveCache &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SensitiveCache & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SensitiveCache &a, SensitiveCache &b);

typedef struct _MsgCache__isset {
  _MsgCache__isset() : msgId(false), msgType(false), msgData(false), createTime(false) {}
  bool msgId;
  bool msgType;
  bool msgData;
  bool createTime;
} _MsgCache__isset;

class MsgCache {
 public:

  static const char* ascii_fingerprint; // = "C93D890311F28844166CF6E571EB3AC2";
  static const uint8_t binary_fingerprint[16]; // = {0xC9,0x3D,0x89,0x03,0x11,0xF2,0x88,0x44,0x16,0x6C,0xF6,0xE5,0x71,0xEB,0x3A,0xC2};

  MsgCache() : msgId(), msgType(), msgData(), createTime() {
  }

  virtual ~MsgCache() throw() {}

  std::string msgId;
  std::string msgType;
  std::string msgData;
  std::string createTime;

  _MsgCache__isset __isset;

  void __set_msgId(const std::string& val) {
    msgId = val;
  }

  void __set_msgType(const std::string& val) {
    msgType = val;
  }

  void __set_msgData(const std::string& val) {
    msgData = val;
  }

  void __set_createTime(const std::string& val) {
    createTime = val;
  }

  bool operator == (const MsgCache & rhs) const
  {
    if (!(msgId == rhs.msgId))
      return false;
    if (!(msgType == rhs.msgType))
      return false;
    if (!(msgData == rhs.msgData))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    return true;
  }
  bool operator != (const MsgCache &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MsgCache & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(MsgCache &a, MsgCache &b);

typedef struct _TokenCache__isset {
  _TokenCache__isset() : token(false), appId(false), createTime(false), expiredTime(false), refreshTime(false) {}
  bool token;
  bool appId;
  bool createTime;
  bool expiredTime;
  bool refreshTime;
} _TokenCache__isset;

class TokenCache {
 public:

  static const char* ascii_fingerprint; // = "BFF0E21728CB005F9AA5774A41542B8D";
  static const uint8_t binary_fingerprint[16]; // = {0xBF,0xF0,0xE2,0x17,0x28,0xCB,0x00,0x5F,0x9A,0xA5,0x77,0x4A,0x41,0x54,0x2B,0x8D};

  TokenCache() : token(), appId(), createTime(), expiredTime(), refreshTime() {
  }

  virtual ~TokenCache() throw() {}

  std::string token;
  std::string appId;
  std::string createTime;
  std::string expiredTime;
  std::string refreshTime;

  _TokenCache__isset __isset;

  void __set_token(const std::string& val) {
    token = val;
  }

  void __set_appId(const std::string& val) {
    appId = val;
  }

  void __set_createTime(const std::string& val) {
    createTime = val;
  }

  void __set_expiredTime(const std::string& val) {
    expiredTime = val;
  }

  void __set_refreshTime(const std::string& val) {
    refreshTime = val;
  }

  bool operator == (const TokenCache & rhs) const
  {
    if (!(token == rhs.token))
      return false;
    if (!(appId == rhs.appId))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(expiredTime == rhs.expiredTime))
      return false;
    if (!(refreshTime == rhs.refreshTime))
      return false;
    return true;
  }
  bool operator != (const TokenCache &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenCache & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TokenCache &a, TokenCache &b);

}}}}}}} // namespace

#endif
