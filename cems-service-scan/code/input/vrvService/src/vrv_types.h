/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef vrv_TYPES_H
#define vrv_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>




typedef struct _BizMethodInfo__isset {
  _BizMethodInfo__isset() : name(false), argsNum(false), argsType(false) {}
  bool name;
  bool argsNum;
  bool argsType;
} _BizMethodInfo__isset;

class BizMethodInfo {
 public:

  static const char* ascii_fingerprint; // = "86E364DD5256DED80DC5D0204BE11EE4";
  static const uint8_t binary_fingerprint[16]; // = {0x86,0xE3,0x64,0xDD,0x52,0x56,0xDE,0xD8,0x0D,0xC5,0xD0,0x20,0x4B,0xE1,0x1E,0xE4};

  BizMethodInfo() : name(), argsNum(0) {
  }

  virtual ~BizMethodInfo() throw() {}

  std::string name;
  int8_t argsNum;
  std::vector<std::string>  argsType;

  _BizMethodInfo__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_argsNum(const int8_t val) {
    argsNum = val;
  }

  void __set_argsType(const std::vector<std::string> & val) {
    argsType = val;
  }

  bool operator == (const BizMethodInfo & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(argsNum == rhs.argsNum))
      return false;
    if (!(argsType == rhs.argsType))
      return false;
    return true;
  }
  bool operator != (const BizMethodInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BizMethodInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(BizMethodInfo &a, BizMethodInfo &b);

typedef struct _BizMethodInvokeInfo__isset {
  _BizMethodInvokeInfo__isset() : totalCount(false), successCount(false), failureCount(false), successAverageTime(false), successMinTime(false), successMaxTime(false) {}
  bool totalCount;
  bool successCount;
  bool failureCount;
  bool successAverageTime;
  bool successMinTime;
  bool successMaxTime;
} _BizMethodInvokeInfo__isset;

class BizMethodInvokeInfo {
 public:

  static const char* ascii_fingerprint; // = "FD11249ACE8A1CE79C544B3DBECE03F7";
  static const uint8_t binary_fingerprint[16]; // = {0xFD,0x11,0x24,0x9A,0xCE,0x8A,0x1C,0xE7,0x9C,0x54,0x4B,0x3D,0xBE,0xCE,0x03,0xF7};

  BizMethodInvokeInfo() : totalCount(0), successCount(0), failureCount(0), successAverageTime(0), successMinTime(0), successMaxTime(0) {
  }

  virtual ~BizMethodInvokeInfo() throw() {}

  int64_t totalCount;
  int64_t successCount;
  int64_t failureCount;
  int64_t successAverageTime;
  int64_t successMinTime;
  int64_t successMaxTime;

  _BizMethodInvokeInfo__isset __isset;

  void __set_totalCount(const int64_t val) {
    totalCount = val;
  }

  void __set_successCount(const int64_t val) {
    successCount = val;
  }

  void __set_failureCount(const int64_t val) {
    failureCount = val;
  }

  void __set_successAverageTime(const int64_t val) {
    successAverageTime = val;
  }

  void __set_successMinTime(const int64_t val) {
    successMinTime = val;
  }

  void __set_successMaxTime(const int64_t val) {
    successMaxTime = val;
  }

  bool operator == (const BizMethodInvokeInfo & rhs) const
  {
    if (!(totalCount == rhs.totalCount))
      return false;
    if (!(successCount == rhs.successCount))
      return false;
    if (!(failureCount == rhs.failureCount))
      return false;
    if (!(successAverageTime == rhs.successAverageTime))
      return false;
    if (!(successMinTime == rhs.successMinTime))
      return false;
    if (!(successMaxTime == rhs.successMaxTime))
      return false;
    return true;
  }
  bool operator != (const BizMethodInvokeInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BizMethodInvokeInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(BizMethodInvokeInfo &a, BizMethodInvokeInfo &b);



#endif
