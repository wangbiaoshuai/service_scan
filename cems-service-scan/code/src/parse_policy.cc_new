#include "parse_policy.h"

#include "log.h"
#include "tinyxml.h"
#include "common_function.h"

namespace cems{ namespace service{ namespace scan{
using namespace std;

ParsePolicy::ParsePolicy() :
policy_mutex_(),
policy_file_("")
{
}

ParsePolicy::~ParsePolicy()
{
}

void ParsePolicy::Init(const string& file_name)
{
    policy_file_ = file_name;
    return;
}

ParsePolicy& ParsePolicy::GetInstance()
{
    static ParsePolicy parse_policy;
    return parse_policy;
}

long long ParsePolicy::SwitchTime(string cycle)
{
    if(cycle.empty())
        return 0;

    long long time = 1;
    int i = 1;
    size_t pos = cycle.find(" ");
    while(pos != string::npos)
    {
        string time_circle = cycle.substr(0, pos+1);
        size_t time_pos = time_circle.find("/");
        if(time_pos != string::npos)
        {
            time_circle.erase(0, time_pos+1);
            switch(i)
            {
                case 1:
                    time *= atoi(time_circle.c_str());
                    break;
                case 2:
                    time *= 60 * atoi(time_circle.c_str());
                    break;
                case 3:
                    time *= 60 * 60 * atoi(time_circle.c_str());
                    break;
                case 4:
                    time *= 60 * 60 * 24 * atoi(time_circle.c_str());
                    break;
                case 5:
                    time *= 60 * 60 * 24 * 30 * atoi(time_circle.c_str());
                    break;
                default:
                    break;
            }

            return time;
        }
        cycle.erase(0, pos+1);
        pos = cycle.find(" ");
        i++;
    }
    if(!cycle.empty() && i == 5)
    {
        pos = cycle.find("/");
        if(pos != string::npos)
        {
            time *= 60 * 60 * 24 * 30;
        }
    }
    return time;
}

int ParsePolicy::ReadPolicy(PolicyParam& policy_param)
{
    TiXmlDocument *document = NULL;
    TiXmlElement  *root_element = NULL;
    TiXmlNode  *timer_node  = NULL;
    TiXmlNode  *child_node  = NULL;
    TiXmlNode* params_node = NULL;
    document = new TiXmlDocument(policy_file_.c_str());
    if(!document)
    {
        return -1;
        LOG_ERROR("ReadPolicy: document is NULL.");
    }

    int ret = 0;
    do
    {
        policy_mutex_.Lock();
        if(document->LoadFile() == false)
        {
            ret = -1;
            LOG_ERROR("ReadPolicy: load file failed");
            policy_mutex_.Unlock();
            break;
        }
        policy_mutex_.Unlock();

        root_element = document->RootElement();
        if(root_element == NULL)
        {
            ret = -1;
            LOG_ERROR("ReadPolicy: policy file is empty");
            break;
        }

        string circle_time;
        timer_node = root_element->FirstChild("timers");
        if(timer_node)
        {
            child_node = timer_node->FirstChild("timerBean");
            if(child_node)
            {
                child_node = child_node->FirstChild("cycle");
                if(child_node != NULL)
                {
                    circle_time = child_node->ToElement()->Value();
                    if(circle_time.empty())
                    {
                        LOG_WARN("ReadPolicy: cycle time is empty in policy.xml");
                    }
                    policy_param.update_time = SwitchTime(circle_time);
                }
            }
        }

        params_node = root_element->FirstChild("params");
        if(params_node != NULL)
        {
            child_node = NULL;
            for(child_node = params_node->FirstChild(); child_node; child_node = child_node->NextSibling())
            {
                string key, value;
                key = child_node->ToElement()->Attribute("key");
                value = child_node->ToElement()->Attribute("value");
                if(key == "intervalTime")
                    policy_param.interval_time = value;
                if(key == "ipRange")
                {
                    TiXmlNode* child_param = NULL;
                    for(child_param = child_node->FirstChild(); child_param; child_param = child_param->NextSibling())
                    {
                        string ip, orgId;
                        TiXmlNode* child = NULL;
                        child = child_param->FirstChild("ip");
                        if(child && child->ToElement())
                        {
                            ip = child->ToElement()->Value();
                        }

                        child = child_param->FirstChild("orgId");
                        if(child)
                        {
                            orgId = child->ToElement()->Value();
                        }

                        if(!orgId.empty() && !ip.empty())
                        {
                            policy_param.ip_range.insert(std::pair<string, string>(ip, orgId));
                        }
                    }
                }
            }
        }
        else
        {
            ret = -1;
            LOG_ERROR("ReadPolicy: params is empty in policy.xml");
            break;
        }

        if(policy_param.interval_time.empty())
            policy_param.interval_time = DEFAULT_INTERVAL; //60S
        if(circle_time.empty())
            policy_param.update_time = DEFAULT_UPDATE_TIME;

        /*string key, value;
        key = "service.serverAreaId";
        if(ParseConfigure::GetInstance().GetProperty(key, value) && !value.empty())
        {
            policy_param.area_id = value;
        }
        else
        {
            policy_param.area_id = DEFAULT_AREA_ID;
        }*/

    }while(0);

    if(!document)
    {
        delete document;
    }
    return ret;
}

bool ParsePolicy::GetPolicyCrc(std::string& crc)
{
    if(policy_file_.empty())
    {
        LOG_WARN("GetPolicyCrc: ParsePolicy not been init.");
        policy_file_ = POLICY_FILE;
    }
    policy_mutex_.Lock();
    FILE* fp = fopen(policy_file_.c_str(), "r");
    if(fp == NULL)
    {
        policy_mutex_.Unlock();
        LOG_ERROR("GetPolicyCrc: open file "<<policy_file_<<" failed.");
        return false;
    }
    fseek(fp, 0, SEEK_END);
    int size = ftell(fp);
    fseek(fp, 0, SEEK_SET);

    char* buf = new char[size + 1];
    memset(buf, 0, size + 1);
    
    fread(buf, size, 1, fp);
    crc = calCRC(buf);
    delete[] buf;
    fclose(fp);
    policy_mutex_.Unlock();
    return true;
}

int ParsePolicy::WritePolicy(const std::string& data)
{
    if(data.empty())
    {
        LOG_ERROR("WritePolicy: data is empty.");
        return -1;
    }

    if(policy_file_.empty())
    {
        LOG_WARN("GetPolicyCrc: ParsePolicy not been init.");
        policy_file_ = POLICY_FILE;
    }

    policy_mutex_.Lock();
    FILE* fp = fopen(policy_file_.c_str(), "w+");
    if(fp == NULL)
    {
        LOG_ERROR("WritePolicy: open file "<<policy_file_<<" failed.");
        return -1;
    }

    int size = fwrite(data.c_str(), data.size(), 1, fp);
    fclose(fp);
    policy_mutex_.Unlock();
    return size;
}
}}}
